<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logique Combinatoire - Chapitre IV</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 900px; margin: auto; }
        h1, h2, h3, h4, h5, h6 { color: #333; }
        h1 { text-align: center; margin-bottom: 30px; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 40px; }
        h3 { margin-top: 30px; }
        h4 { margin-top: 20px; }
        .chapter-intro { display: flex; align-items: flex-start; border-bottom: 1px solid #ccc; padding-bottom: 20px; margin-bottom: 20px; }
        .chapter-intro .text { flex-grow: 1; padding-right: 20px; }
        .chapter-intro figure { margin: 0; text-align: center; }
        .chapter-intro img { max-width: 150px; height: auto; border: 1px solid #ccc; }
        .quote { font-style: italic; text-align: right; margin: 20px 0; }
        .example { border: 1px solid #e0e0e0; padding: 15px; margin: 15px 0; background-color: #f9f9f9; }
        .example-title { font-weight: bold; margin-bottom: 10px; }
        table { border-collapse: collapse; margin: 20px 0; width: auto; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        th { background-color: #f2f2f2; }
        code { background-color: #eee; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        .placeholder { display: block; min-height: 100px; border: 1px dashed #aaa; background-color: #f0f0f0; text-align: center; padding: 20px; margin: 15px 0; font-style: italic; color: #666; }
        footer { text-align: center; margin-top: 50px; font-size: 0.9em; color: #555; border-top: 1px solid #eee; padding-top: 10px;}
        /* KaTeX display style */
        .katex-display { text-align: center; margin: 1em 0; }
    </style>
</head>
<body>

    <!-- Page 1: Title Page -->
    <header>
        <h1>Deuxième partie</h1>
        <h2>La logique combinatoire</h2>
        <figure style="text-align: center;">
            <div class="placeholder">[Placeholder: Image composite de divers systèmes de numération et symboles logiques]</div>
            <figcaption>Représentation visuelle des concepts de numération et de logique.</figcaption>
        </figure>
    </header>

    <main>
        <!-- Page 3: Chapter IV Introduction -->
        <article>
            <div class="chapter-intro">
                <div class="text">
                    <h2>Chapitre IV</h2>
                    <h3>Algèbre booléenne et opérateurs logiques</h3>
                </div>
                <figure>
                    <div class="placeholder">[Placeholder: Portrait de George Boole]</div>
                    <figcaption>
                        George Boole<br>
                        * 2 nov. 1815, Lincoln, R.-U.<br>
                        † 8 déc. 1864, Ballintemple, Irlande
                    </figcaption>
                </figure>
            </div>

            <p class="quote">« Une proposition peut être vraie ou fausse, mais ne peut pas être vraie et fausse. »<br> (Aristote * 384, † 322 av. J.-C.)</p>

            <section id="intro">
                <h4>IV.1 Introduction</h4>
                <p>Les systèmes logiques fonctionnent en mode binaire, ce qui signifie que les variables d'entrée et de sortie ne peuvent prendre que deux valeurs distinctes : <code>0</code> ou <code>1</code>. Ces valeurs, aussi appelées états, correspondent à des plages physiques (par exemple, des niveaux de tension ou de pression) définies à l'avance.</p>

                <div class="example">
                    <div class="example-title">▷ Exemple 4.1 : Niveaux logiques</div>
                    <p><strong>Technologie électrique TTL (Transistor-Transistor Logic) :</strong></p>
                    <ul>
                        <li>Niveau logique <code>1</code> \( \leftrightarrow \) Tension entre 2,4 V et 5 V</li>
                        <li>Niveau logique <code>0</code> \( \leftrightarrow \) Tension entre 0 V et 0,8 V</li>
                    </ul>
                    <p><strong>Technologie pneumatique :</strong></p>
                    <ul>
                        <li>Niveau logique <code>1</code> \( \leftrightarrow \) Présence de pression</li>
                        <li>Niveau logique <code>0</code> \( \leftrightarrow \) Absence de pression</li>
                    </ul>
                </div>

                <p>Les valeurs <code>0</code> et <code>1</code> ne représentent pas directement des nombres réels dans ce contexte, mais plutôt l'état d'une variable logique. On les appelle donc « niveaux logiques ».</p>

                <section id="naming">
                    <h5>IV.1.1 Convention de nommage des synonymes des « 0 » et « 1 »</h5>
                    <p>Ces deux niveaux logiques peuvent être désignés de nombreuses manières, selon le contexte :</p>
                    <ul>
                        <li><strong>Niveau logique <code>1</code> :</strong> Vrai, Fermé, Marche, Haut (High), Allumé, Oui, True, On, Set.</li>
                        <li><strong>Niveau logique <code>0</code> :</strong> Faux, Ouvert, Arrêt, Bas (Low), Éteint, Non, False, Off, Reset.</li>
                    </ul>
                </section>
            </section>

            <!-- Page 4: Types of Logic, Variables, Convention -->
            <section id="types-logic">
                <h4>IV.1.2 Types de logiques</h4>
                <p>On distingue principalement deux types de conventions pour interpréter les niveaux physiques en niveaux logiques :</p>
                <ul>
                    <li><strong>Logique positive :</strong>
                        <ul>
                            <li>niveau physique haut \( \rightarrow \) état logique <code>1</code> (ex: 5V)</li>
                            <li>niveau physique bas \( \rightarrow \) état logique <code>0</code> (ex: 0V)</li>
                        </ul>
                    </li>
                    <li><strong>Logique négative :</strong>
                        <ul>
                            <li>niveau physique haut \( \rightarrow \) état logique <code>0</code> (ex: 0V ou autre seuil bas)</li>
                            <li>niveau physique bas \( \rightarrow \) état logique <code>1</code> (ex: 5V ou autre seuil haut)</li>
                        </ul>
                    </li>
                </ul>
                <p>La logique binaire, formalisée par l'algèbre de Boole, fournit un modèle mathématique pour décrire, manipuler et analyser les informations binaires et les systèmes numériques.</p>
                <p>L'algèbre de Boole repose sur trois fonctions élémentaires :</p>
                <ul>
                    <li><strong>Addition logique :</strong> appelée <strong>OU</strong> (OR), symbolisée par un plus : <code>+</code>.</li>
                    <li><strong>Multiplication logique :</strong> appelée <strong>ET</strong> (AND), symbolisée par un point : <code>.</code> (souvent omis, ex: \(AB\) au lieu de \(A \cdot B\)).</li>
                    <li><strong>Complémentation :</strong> appelée <strong>NON</strong> (NOT) ou inversion, symbolisée par un surlignement : \( \overline{A} \) (ou parfois par une apostrophe A' ou le symbole ¬A).</li>
                </ul>
                <p>\( \rightarrow \) Tout circuit numérique peut être décrit par une fonction logique (expression booléenne) qui représente la variable de sortie en fonction des variables d'entrée.</p>
            </section>

            <section id="variables">
                <h4>IV.1.3 Variables logiques (binaires)</h4>
                <p>Ce sont des variables qui ne peuvent prendre que deux valeurs distinctes : <code>0</code> ou <code>1</code>. Une variable binaire peut représenter l'état de n'importe quel dispositif à deux états (interrupteur, contact, lampe, électro-vanne, etc.).</p>
            </section>

            <section id="convention">
                <h4>IV.1.4 Convention</h4>
                <p>Dans les schémas, tout appareil est généralement représenté dans son état de repos (non actionné, non alimenté).</p>
                <p>L'action sur un appareil (par exemple, appuyer sur un bouton, alimenter un relais) est souvent notée par la variable elle-même (ex: <code>a</code>, <code>b</code>, ...). L'absence d'action (état de repos) est notée par le complément de la variable (ex: \( \overline{a} \), \( \overline{b} \), ...).</p>

                <div class="example">
                    <div class="example-title">▷ Exemple 4.2 : Bouton poussoir</div>
                    <p>Un bouton poussoir peut avoir des contacts qui sont ouverts ou fermés au repos.</p>
                    <ul>
                        <li><strong>Contact travail :</strong> Schéma d'un contact ouvert au repos (se ferme lorsqu'on appuie).</li>
                        <li><strong>Contact repos :</strong> Schéma d'un contact fermé au repos (s'ouvre lorsqu'on appuie).</li>
                    </ul>
                     <div class="placeholder">[Placeholder: Schéma d'un contact travail et d'un contact repos]</div>
               </div>

                <div class="example">
                    <div class="example-title">▷ Exemple 4.3 : Relais</div>
                    <p>Un relais est un interrupteur commandé électromagnétiquement. Lorsqu'un courant approprié circule dans sa bobine (charbon), un champ magnétique déplace une armature qui ouvre ou ferme des contacts.</p>
                    <p>Il est représenté dans sa position non alimentée (au repos).</p>
                    <div class="placeholder">[Placeholder: Icône symbolisant un relais]</div>
                    <p>Les contacts d'un relais peuvent être :</p>
                     <ul>
                         <li><strong>Normalement Ouverts (NO) :</strong> Ouverts au repos, se ferment quand le relais est activé.</li>
                         <li><strong>Normalement Fermés (NC) :</strong> Fermés au repos, s'ouvrent quand le relais est activé.</li>
                     </ul>
                 </div>
            </section>

            <!-- Page 5: Properties of Boolean Algebra -->
            <section id="properties">
                <h4>IV.2 Propriétés de l'algèbre booléenne</h4>

                 <figure style="display: flex; justify-content: space-around; align-items: center;">
                    <div>
                        <div class="placeholder">[Placeholder: Schéma d'un relais simple (bobine + contact)]</div>
                        <figcaption>Charbon (Bobine)</figcaption>
                        <p>Symbole d'un relais double normalement ouvert et fermé.</p>
                         <div class="placeholder">[Placeholder: Schéma d'un relais double (NO/NC)]</div>
                   </div>
                    <div>
                        <div class="placeholder">[Placeholder: Schéma circuit avec relais A, B, C]</div>
                        <figcaption>Circuit exemple : \( T = (A+B) \cdot C \)</figcaption>
                    </div>
                </figure>

                <section id="presentation">
                    <h5>IV.2.1 Présentation</h5>
                    <p>L'algèbre booléenne fournit un cadre mathématique pour étudier les propositions logiques opérant sur des ensembles d'éléments.</p>
                    
                    <div class="definition" style="border-left: 3px solid #4CAF50; padding-left: 15px; margin: 15px 0; background-color: #e8f5e9;">
                        <strong>Définition 4.1 : Algèbre booléenne</strong><br>
                        Un ensemble \(E\) d'éléments (notés \(a, b, c, ...\)) associé à deux opérations binaires \(+\) (OU logique) et \( \cdot \) (ET logique) constitue une algèbre booléenne si et seulement si les postulats suivants sont satisfaits :
                        <ul>
                            <li><strong>P1 : Commutativité :</strong> Les opérations sont commutatives.
                                <br>\( a + b = b + a \)
                                <br>\( a \cdot b = b \cdot a \)
                            </li>
                            <li><strong>P2 : Distributivité :</strong> Chacune des opérations est distributive par rapport à l'autre.
                                <br>\( a \cdot (b + c) = (a \cdot b) + (a \cdot c) \)
                                <br>\( a + (b \cdot c) = (a + b) \cdot (a + c) \) (Note: cette seconde distributivité est spécifique à l'algèbre booléenne)
                            </li>
                            <li><strong>P3 : Éléments Identité :</strong> Il existe des éléments identité (neutres) : <code>0</code> pour l'opération \(+\) et <code>1</code> pour l'opération \( \cdot \).
                                <br>\( a + 0 = a \)
                                <br>\( a \cdot 1 = a \)
                            </li>
                            <li><strong>P4 : Complément :</strong> Pour chaque élément \( a \in E \), il existe un élément complémentaire \( \overline{a} \in E \) tel que :
                                <br>\( a + \overline{a} = 1 \)
                                <br>\( a \cdot \overline{a} = 0 \)
                            </li>
                        </ul>
                    </div>

                    <p>À partir de ces postulats fondamentaux, il est possible de démontrer d'autres propriétés et théorèmes importants, tels que :</p>
                    <ul>
                        <li>Théorème d'idempotence (voir §IV.4.3)</li>
                        <li>Propriété de l'élément nul (absorbant) (voir §IV.4.2)</li>
                        <li>Théorème d'involution (double négation) (voir §IV.4.5)</li>
                        <li>Théorème d'absorption (voir §IV.5.6)</li>
                        <li>Associativité (voir §IV.5.3)</li>
                        <li>Lois de De Morgan (voir §IV.5.8)</li>
                    </ul>
                    <p>Ces théorèmes seront présentés plus loin.</p>
                    <p><em>Note importante :</em> Le lecteur attentif remarquera que la définition formelle d'une algèbre booléenne ne spécifie pas que l'ensemble \(E\) doit contenir uniquement deux éléments. Une algèbre booléenne peut avoir plus de deux éléments (voire une infinité), mais elle doit toujours contenir au moins les éléments distincts <code>0</code> et <code>1</code>.</p>
                    <p>L'algèbre booléenne n'est donc pas restreinte aux seuls ensembles binaires. Cependant, l'algèbre binaire est la plus simple et la plus utilisée en électronique numérique.</p>
                </section>
            </section>

            <!-- Page 6: Binary Algebra -->
            <p>En fait, le nombre d'éléments dans \(E\) peut être infini, mais doit au moins comporter les éléments <code>0</code> et <code>1</code>. Ainsi l'algèbre binaire, qui ne contient que les éléments <code>0</code> et <code>1</code>, constitue l'algèbre booléenne la plus simple et la plus fondamentale pour les circuits logiques.</p>

            <div class="example">
                 <div class="example-title">▷ Exemple 4.4 : Algèbre booléenne à 4 éléments</div>
                 <p>Il est possible de définir une algèbre booléenne sur un ensemble avec plus de deux éléments, par exemple \( E = \{0, a, b, 1\} \). Les opérations \(+\) et \( \cdot \) doivent satisfaire les postulats P1-P4. Voici un exemple de tables d'opérations possibles :</p>
                 <div style="display: flex; justify-content: space-around;">
                     <table>
                         <caption>Opération + (OU)</caption>
                         <thead><tr><th>+</th><th>0</th><th>a</th><th>b</th><th>1</th></tr></thead>
                         <tbody>
                             <tr><th>0</th><td>0</td><td>a</td><td>b</td><td>1</td></tr>
                             <tr><th>a</th><td>a</td><td>a</td><td>1</td><td>1</td></tr>
                             <tr><th>b</th><td>b</td><td>1</td><td>b</td><td>1</td></tr>
                             <tr><th>1</th><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                         </tbody>
                     </table>
                     <table>
                         <caption>Opération ⋅ (ET)</caption>
                         <thead><tr><th>⋅</th><th>0</th><th>a</th><th>b</th><th>1</th></tr></thead>
                         <tbody>
                             <tr><th>0</th><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                             <tr><th>a</th><td>0</td><td>a</td><td>0</td><td>a</td></tr>
                             <tr><th>b</th><td>0</td><td>0</td><td>b</td><td>b</td></tr>
                             <tr><th>1</th><td>0</td><td>a</td><td>b</td><td>1</td></tr>
                         </tbody>
                     </table>
                </div>
                <p>(Note: Dans cet exemple, les compléments seraient \( \overline{0}=1, \overline{1}=0, \overline{a}=b, \overline{b}=a \))</p>
             </div>

            <section id="binary-algebra">
                <h4>IV.3 Algèbre binaire ou algèbre de commutation</h4>
                <p>C'est le cas particulier de l'algèbre booléenne où l'ensemble \(E\) ne contient que deux éléments : \( B_2 = \{0, 1\} \). C'est cette algèbre qui est directement applicable aux circuits numériques.</p>

                <section id="base-postulates">
                    <h5>IV.3.1 Postulats de base (pour l'algèbre binaire)</h5>
                    <p>Si \(a\) est une variable logique (pouvant valoir <code>0</code> ou <code>1</code>), on a les définitions et propriétés suivantes :</p>
                    <ul>
                        <li><strong>P1 :</strong> \( a = 0 \) si et seulement si \( a \neq 1 \)</li>
                        <li><strong>P1* :</strong> \( a = 1 \) si et seulement si \( a \neq 0 \)</li>
                    </ul>
                    <p><strong>Opération NON (complément), notée \( \overline{\phantom{A}} \) :</strong></p>
                    <ul>
                        <li><strong>P2 :</strong> \( \overline{0} = 1 \)</li>
                        <li><strong>P2* :</strong> \( \overline{1} = 0 \)</li>
                    </ul>
                    <p><strong>Opération OU (disjonction), notée \( + \) :</strong></p>
                    <ul>
                        <li><strong>P3 :</strong> \( 1+1 = 1 \), \( 1+0 = 1 \), \( 0+1 = 1 \)</li>
                        <li><strong>P4 :</strong> \( 0+0 = 0 \)</li>
                    </ul>
                     <p><strong>Opération ET (intersection), notée \( \cdot \) :</strong></p>
                    <ul>
                        <li><strong>P3* :</strong> \( 0 \cdot 0 = 0 \), \( 0 \cdot 1 = 0 \), \( 1 \cdot 0 = 0 \)</li>
                        <li><strong>P4* :</strong> \( 1 \cdot 1 = 1 \)</li>
                    </ul>
                    <p>L'algèbre de commutation est donc le système algébrique constitué de l'ensemble \( \{0, 1\} \) et des opérateurs ET, OU, NON.</p>
                    <p>À partir de ces postulats spécifiques au binaire, on peut (re)démontrer les théorèmes présentés dans les sections §IV.4 et §IV.5.</p>
                </section>

                <section id="hierarchy">
                    <h5>IV.3.2 Hiérarchie des opérations</h5>
                    <p>Dans une expression booléenne écrite sans parenthèses, la convention est d'effectuer d'abord les opérations ET (multiplication logique), puis les opérations OU (addition logique). L'opération NON (complémentation) a la priorité la plus élevée.</p>
                    <p>Exemple : \( A + B \cdot C \) signifie \( A + (B \cdot C) \).</p>
                    <p>Exemple : \( \overline{A} \cdot B + C \) signifie \( (\overline{A}) \cdot B + C \).</p>
                </section>
            </section>

            <!-- Page 7: Perfect Induction, Monovariable Theorems -->
            <section id="perfect-induction">
                <h4>IV.3.3 Induction parfaite</h4>
                <p>Contrairement aux domaines continus (comme l'algèbre linéaire), où vérifier une équation pour quelques valeurs ne suffit pas à la prouver, en logique binaire, il est possible de prouver l'égalité de deux expressions ou la validité d'une propriété en la vérifiant pour <strong>toutes les combinaisons possibles</strong> des valeurs des variables d'entrée.</p>
                <p>Puisque chaque variable ne peut prendre que deux états (<code>0</code> ou <code>1</code>), pour \(n\) variables, il y a \(2^n\) combinaisons à tester. Cette méthode de preuve, appelée <strong>induction parfaite</strong> ou preuve par table de vérité, est exhaustive et rigoureuse pour l'algèbre binaire.</p>
                <p>Ainsi, toutes les propriétés (théorèmes) présentées ci-dessous (§IV.4 et §IV.5) peuvent être démontrées simplement en construisant les tables de vérité correspondantes.</p>
                <p>On notera cependant que si le nombre de variables devient grand, cette méthode devient fastidieuse. Démontrer ces théorèmes dans le cadre général d'une algèbre booléenne (potentiellement non binaire) requiert l'utilisation des postulats P1-P4 (comme mentionné dans [WHI61] - Whitehead, A. N. "A Treatise on Universal Algebra." Vol. 1. Cambridge University Press, 1898. Bien que la référence [WHI61] soit probablement une erreur et pourrait pointer vers un ouvrage plus récent sur l'algèbre de Boole ou la logique).</p>
             </section>

            <section id="monovariable-theorems">
                <h4>IV.4 Théorèmes monovariables</h4>
                <p>Ces théorèmes concernent des expressions avec une seule variable logique \(A\).</p>

                <section id="identity">
                    <h5>IV.4.1 Identité</h5>
                    <p>Chaque opérateur (OU et ET) possède un élément neutre qui, lorsqu'il est combiné avec une variable \(A\), donne \(A\) comme résultat.</p>
                    <p>\( A + 0 = A \)</p>
                    <p>\( A \cdot 1 = A \)</p>
                </section>

                <section id="null-element">
                    <h5>IV.4.2 Élément nul (ou Absorbant)</h5>
                    <p>Chaque opérateur (OU et ET) possède un élément absorbant qui, lorsqu'il est combiné avec une variable \(A\), donne cet élément absorbant comme résultat.</p>
                     <p>\( A + 1 = 1 \)</p>
                     <p>\( A \cdot 0 = 0 \)</p>
                 </section>

                <section id="idempotence">
                    <h5>IV.4.3 Idempotence</h5>
                    <p>Combiner une variable \(A\) avec elle-même via l'opération OU ou ET donne la variable \(A\) comme résultat.</p>
                    <p>\( A + A = A \)</p>
                    <p>\( A \cdot A = A \)</p>
                </section>

                <section id="complementation">
                    <h5>IV.4.4 Complémentation</h5>
                    <p>Combiner une variable \(A\) avec son complément \( \overline{A} \) donne l'élément identité de l'autre opération.</p>
                    <p>\( A + \overline{A} = 1 \)</p>
                    <p>\( A \cdot \overline{A} = 0 \)</p>
                    <p>(Ceci est le postulat P4, mais il est souvent listé comme un théorème fondamental).</p>
                </section>

                <section id="involution">
                    <h5>IV.4.5 Involution (Double complémentation)</h5>
                    <p>Le complément du complément d'une variable \(A\) est égal à la variable \(A\) elle-même.</p>
                    <p>\( \overline{\overline{A}} = A \)</p>
                </section>
            </section>

            <!-- Page 8: Multivariable Theorems -->
            <section id="multivariable-theorems">
                <h4>IV.5 Théorèmes multivariables</h4>
                <p>Ces théorèmes impliquent plusieurs variables logiques (A, B, C, ...).</p>

                <section id="equivalence">
                    <h5>IV.5.1 Équivalence</h5>
                    <p>Deux fonctions logiques (expressions booléennes) sont dites équivalentes si elles produisent la même sortie pour toutes les combinaisons possibles des variables d'entrée. Autrement dit, si leurs tables de vérité sont identiques.</p>
                    <p>Exemple : Si \( F = \overline{A \cdot B} \) et \( G = \overline{A} + \overline{B} \) (Loi de De Morgan), alors \( F \) est équivalente à \( G \), noté \( F = G \) ou \( F \equiv G \).</p>
                </section>

                <section id="complementarity">
                    <h5>IV.5.2 Complémentarité</h5>
                    <p>Deux fonctions sont dites complémentaires si l'une est l'inverse logique (le complément) de l'autre pour toutes les combinaisons d'entrées possibles.</p>
                     <p>Exemple : Si \( F = A \cdot B \) et \( G = \overline{A} + \overline{B} \), alors \( F = \overline{G} \) (ou \( G = \overline{F} \)), et on dit que \( F \) et \( G \) sont complémentaires.</p>
                </section>

                <section id="associativity">
                    <h5>IV.5.3 Associativité</h5>
                    <p>Les opérations OU (\(+\)), ET (\( \cdot \)), et OU Exclusif (\(\oplus\)) sont associatives. L'ordre de groupement des opérandes n'affecte pas le résultat lorsque le même opérateur est utilisé consécutivement.</p>
                    <p>\( (A + B) + C = A + (B + C) = A + B + C \)</p>
                    <p>\( (A \cdot B) \cdot C = A \cdot (B \cdot C) = A \cdot B \cdot C \)</p>
                    <p>\( (A \oplus B) \oplus C = A \oplus (B \oplus C) = A \oplus B \oplus C \)</p>
                </section>

                <section id="commutativity">
                    <h5>IV.5.4 Commutativité</h5>
                    <p>Les opérations OU (\(+\)), ET (\( \cdot \)), et OU Exclusif (\(\oplus\)) sont commutatives. L'ordre des opérandes n'affecte pas le résultat.</p>
                     <p>\( A + B = B + A \)</p>
                     <p>\( A \cdot B = B \cdot A \)</p>
                     <p>\( A \oplus B = B \oplus A \)</p>
                     <p>(Ceci est le postulat P1, rappelé ici pour les opérations multi-variables).</p>
                </section>

                <section id="distributivity">
                    <h5>IV.5.5 Distributivité</h5>
                    <p>L'opération ET est distributive sur l'opération OU, et l'opération OU est distributive sur l'opération ET.</p>
                    <p>\( A \cdot (B + C) = (A \cdot B) + (A \cdot C) \)</p>
                    <p>\( A + (B \cdot C) = (A + B) \cdot (A + C)
