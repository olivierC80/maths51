<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circuits Combinatoires et Séquentiels</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }

        h1,
        h2,
        h3,
        h4 {
            color: #0056b3;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-top: 30px;
        }

        h1 {
            text-align: center;
            border-bottom: 2px solid #0056b3;
        }

        table {
            border-collapse: collapse;
            margin: 20px 0;
            width: auto;
            box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }

        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        code {
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }

        .placeholder {
            border: 1px dashed #ccc;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            color: #888;
            background-color: #f9f9f9;
        }

        ul {
            margin-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <h1>Chapitre 4 Circuits combinatoires</h1>

    <p>
        Un <strong>circuit combinatoire</strong> est un type de circuit logique où l'état de chacune des sorties dépend <em>uniquement</em> de l'état actuel des entrées. Il n'y a pas de notion de mémoire ou d'état antérieur. Mathématiquement, chaque sortie est une fonction booléenne des entrées.
    </p>

    <h2>4-1 Synthèse d'un circuit combinatoire</h2>

    <p>
        La synthèse d'un circuit combinatoire consiste à concevoir le circuit (trouver les équations logiques et le schéma des portes) à partir d'une description de son comportement, souvent donnée sous forme de table de vérité.
    </p>

    <p>
        <strong>Exemple :</strong> On désire concevoir un circuit logique avec trois entrées (notées a, b, c) et deux sorties (notées s₁ et s₀). Le comportement souhaité est défini par la table de vérité suivante (table 13) :
    </p>

    <h4>Table de Vérité (Table 13)</h4>
    <table>
        <thead>
            <tr>
                <th>a</th>
                <th>b</th>
                <th>c</th>
                <th>s₁</th>
                <th>s₀</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
            <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
            <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
            <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
            <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
            <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
            <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
            <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
        </tbody>
    </table>
    <div class="placeholder">
        [Image Placeholder: Truth Table for s1 and s0 from slide 21]
        <img src="placeholder_table_13.png" alt="Table de vérité pour s1 et s0" style="max-width: 200px; display: block; margin: 10px auto;">
    </div>

    <h3>Équations logiques (dérivées de la table de vérité)</h3>
    <p>
        Pour obtenir l'équation logique de chaque sortie, on utilise la forme "somme de produits" (ou première forme canonique). On identifie les combinaisons d'entrées pour lesquelles la sortie vaut 1, et on additionne (OU logique) les termes produits (mintermes) correspondants. Une variable d'entrée apparaît non-inversée si elle vaut 1 dans la combinaison, et inversée (avec une barre au-dessus) si elle vaut 0.
    </p>
    <p><strong>Pour la sortie s₀ :</strong></p>
    <p>\( s₀ = a \bar{b} \bar{c} + a \bar{b} c \)</p>
    <p><strong>Pour la sortie s₁ :</strong></p>
    <p>\( s₁ = \bar{a} \bar{b} \bar{c} + a \bar{b} \bar{c} + a b c \)</p>
    <div class="placeholder">
        [Image Placeholder: Equations derived from truth table from slide 22]
        <img src="placeholder_equations_s0_s1.png" alt="Equations logiques pour s0 et s1" style="max-width: 400px; display: block; margin: 10px auto;">
    </div>

    <h3>Simplification des équations logiques</h3>
    <p><strong>Simplification algébrique de s₀ :</strong></p>
    <p>\( s₀ = a \bar{b} \bar{c} + a \bar{b} c = a \bar{b} (\bar{c} + c) = a \bar{b} (1) = a \bar{b} \)</p>
    <p><strong>Simplification algébrique de s₁ :</strong></p>
    <p>\( s₁ = \bar{a} \bar{b} \bar{c} + a \bar{b} \bar{c} + a b c = (\bar{a} + a) \bar{b} \bar{c} + a b c = (1) \bar{b} \bar{c} + a b c = \bar{b} \bar{c} + a b c \)</p>
    <div class="placeholder">
         [Image Placeholder: Algebraic simplification from slide 22]
         <img src="placeholder_simplification_algebra.png" alt="Simplification algébrique des équations" style="max-width: 400px; display: block; margin: 10px auto;">
    </div>

    <h3>Simplification avec les Tableaux de Karnaugh</h3>
    <h4>Tableau de Karnaugh pour s₀</h4>
    <div class="placeholder">
        [Image Placeholder: Karnaugh Map for s0 from slide 23]
        <img src="placeholder_kmap_s0.png" alt="Tableau de Karnaugh pour s0" style="max-width: 300px; display: block; margin: 10px auto;">
         <p>\( s₀ = a \bar{b} \)</p>
    </div>
    <h4>Tableau de Karnaugh pour s₁</h4>
     <div class="placeholder">
        [Image Placeholder: Karnaugh Map for s1 from slide 23]
        <img src="placeholder_kmap_s1.png" alt="Tableau de Karnaugh pour s1" style="max-width: 300px; display: block; margin: 10px auto;">
         <p>\( s₁ = \bar{b} \bar{c} + a b c \)</p>
    </div>

    <h3>Logigramme (Circuit Logique - fig. 6)</h3>
    <p>Équations : \( s₀ = a \bar{b} \), \( s₁ = \bar{b} \bar{c} + a b c \)</p>
    <div class="placeholder">
        [Image Placeholder: Logic Diagram for s0 and s1 from slide 24]
        <img src="placeholder_logigramme_s0_s1.png" alt="Logigramme pour s0 et s1" style="max-width: 450px; display: block; margin: 10px auto;">
    </div>

    <hr style="margin: 40px 0;">

    <h2>4-2 Circuits arithmétiques</h2>
    <p>
        À partir des fonctions logiques de base, on peut construire des circuits combinatoires plus complexes capables d'effectuer des opérations arithmétiques sur des nombres binaires.
    </p>

    <h3>4-2-1 Comparateur 1 bit</h3>
    <p>Compare deux bits 'a' et 'b'. Sortie 's' = 1 si a=b, 0 sinon.</p>
    <h4>Table de vérité (Table 14)</h4>
    <table>
        <thead><tr><th>a</th><th>b</th><th>s</th></tr></thead>
        <tbody>
            <tr><td>0</td><td>0</td><td>1</td></tr>
            <tr><td>0</td><td>1</td><td>0</td></tr>
            <tr><td>1</td><td>0</td><td>0</td></tr>
            <tr><td>1</td><td>1</td><td>1</td></tr>
        </tbody>
    </table>
    <div class="placeholder">
        [Image Placeholder: Truth Table for 1-bit Comparator from slide 26]
        <img src="placeholder_table_14.png" alt="Table de vérité comparateur 1 bit" style="max-width: 200px; display: block; margin: 10px auto;">
    </div>
    <h4>Équation booléenne</h4>
    <p>\( s = \bar{a} \bar{b} + a b = \overline{a \oplus b} \) (Fonction XNOR)</p>
    <h4>Logigramme (fig. 7)</h4>
     <div class="placeholder">
        [Image Placeholder: Logic Diagram for 1-bit Comparator (XNOR) from slide 26]
        <img src="placeholder_logigramme_comp1bit.png" alt="Logigramme comparateur 1 bit (XNOR)" style="max-width: 250px; display: block; margin: 10px auto;">
    </div>

    <h3>4-2-2 Additionneur 1 bit (Demi-Additionneur)</h3>
    <p>Additionne deux bits 'a' et 'b'. Sorties : s₀ (Somme LSB) et s₁ (Retenue MSB).</p>
    <h4>Table de vérité (Table 15)</h4>
    <table>
        <thead><tr><th>a</th><th>b</th><th>s₁ (Retenue)</th><th>s₀ (Somme)</th></tr></thead>
        <tbody>
            <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
            <tr><td>0</td><td>1</td><td>0</td><td>1</td></tr>
            <tr><td>1</td><td>0</td><td>0</td><td>1</td></tr>
            <tr><td>1</td><td>1</td><td>1</td><td>0</td></tr>
        </tbody>
    </table>
    <div class="placeholder">
        [Image Placeholder: Truth Table for Half-Adder from slide 27]
        <img src="placeholder_table_15.png" alt="Table de vérité demi-additionneur" style="max-width: 250px; display: block; margin: 10px auto;">
    </div>
    <h4>Équations booléennes</h4>
    <p>\( s₀ = a \oplus b \) (XOR)</p>
    <p>\( s₁ = a \cdot b \) (AND)</p>
    <h4>Logigramme (fig. 8)</h4>
    <div class="placeholder">
        [Image Placeholder: Logic Diagram for Half-Adder from slide 27]
        <img src="placeholder_logigramme_halfadder.png" alt="Logigramme demi-additionneur" style="max-width: 350px; display: block; margin: 10px auto;">
    </div>

    <hr style="margin: 40px 0;">

    <h1>Chapitre 5 Circuits séquentiels</h1>
    <p>
        Dans un <strong>circuit séquentiel</strong>, les sorties dépendent non seulement des entrées actuelles mais aussi de l'<strong>état antérieur</strong> du circuit, stocké dans des éléments de mémoire.
    </p>

    <h2>5-1 Fonction mémoire</h2>
    <p>
        Les éléments fondamentaux pour stocker l'information (un bit) sont les <strong>bascules</strong> (flip-flops) et les <strong>verrous</strong> (latches).
    </p>

    <h3>5-1-1 Verrou RS (RS Latch)</h3>
    <p>
        Le verrou RS (Reset-Set) a deux entrées (R et S) et deux sorties complémentaires (Q et \( \bar{Q} \)). Il est souvent construit avec des portes NOR ou NAND interconnectées.
    </p>
    <h4>Symbole (fig. 10)</h4>
    <div class="placeholder">
        [Image Placeholder: RS Latch Symbol from slide 28]
        <img src="placeholder_symbol_rs_latch.png" alt="Symbole du verrou RS" style="max-width: 150px; display: block; margin: 10px auto;">
    </div>
    <h4>Logigramme (fig. 9 - Implémentation avec portes NON-OU / NOR)</h4>
     <div class="placeholder">
        [Image Placeholder: RS Latch Logic Diagram (NOR gates) from slide 29]
        <img src="placeholder_logigramme_rs_nor.png" alt="Logigramme du verrou RS avec portes NOR" style="max-width: 300px; display: block; margin: 10px auto;">
    </div>

    <h4>Analyse du fonctionnement (Verrou RS NOR)</h4>
    <p><strong>Rappel Porte NOR :</strong> Sortie = 1 si et seulement si toutes les entrées = 0.</p>
    <ul>
        <li><strong>État Interdit (R=1, S=1) :</strong> Force Q=0 et \( \bar{Q}=0 \). Viole la complémentarité et peut causer des problèmes au retour à (0,0). À éviter.</li>
        <li><strong>État Mémoire (R=0, S=0) :</strong> Les sorties Q et \( \bar{Q} \) conservent leur valeur précédente. Le verrou "mémorise" l'état.</li>
        <li><strong>Fonction SET (R=0, S=1) :</strong> Force la sortie Q à 1 (et \( \bar{Q} \) à 0). C'est la mise à 1 de la sortie Q.
            <div class="placeholder">
                [Image Placeholder: RS Latch SET operation (00 -> 01) from slide 30 - fig 11a]
                <img src="placeholder_rs_set_transition.png" alt="Transition SET du verrou RS" style="max-width: 300px; display: block; margin: 10px auto;">
            </div>
            <p>Transition (01) → (00) : Après le SET, si les entrées reviennent à (0,0), l'état Q=1 est mémorisé.</p>
             <div class="placeholder">
                [Image Placeholder: RS Latch Memory operation (after SET: 01 -> 00) from slide 30 - fig 11b]
                <img src="placeholder_rs_memory_after_set.png" alt="Fonction Mémoire du verrou RS après SET" style="max-width: 300px; display: block; margin: 10px auto;">
            </div>
        </li>
        <li><strong>Fonction RESET (R=1, S=0) :</strong> Force la sortie Q à 0 (et \( \bar{Q} \) à 1). C'est la mise à 0 de la sortie Q.
            <div class="placeholder">
                [Image Placeholder: RS Latch RESET operation (00 -> 10) from slide 31 - fig 11c]
                <img src="placeholder_rs_reset_transition.png" alt="Transition RESET du verrou RS" style="max-width: 300px; display: block; margin: 10px auto;">
            </div>
            <p>Transition (10) → (00) : Après le RESET, si les entrées reviennent à (0,0), l'état Q=0 est mémorisé.</p>
             <div class="placeholder">
                [Image Placeholder: RS Latch Memory operation (after RESET: 10 -> 00) from slide 31 - fig 11d]
                <img src="placeholder_rs_memory_after_reset.png" alt="Fonction Mémoire du verrou RS après RESET" style="max-width: 300px; display: block; margin: 10px auto;">
            </div>
        </li>
    </ul>

    <h4>Table de vérité fonctionnelle (Table 16)</h4>
    <p>On note \( Q_n \) l'état de la sortie Q avant l'application des entrées R et S, et \( Q_{n+1} \) l'état après.
    </p>
    <table>
        <thead>
            <tr><th>R</th><th>S</th><th>\( Q_{n+1} \)</th><th>Fonction</th></tr>
        </thead>
        <tbody>
            <tr><td>0</td><td>0</td><td>\( Q_n \)</td><td>Mémoire</td></tr>
            <tr><td>0</td><td>1</td><td>1</td><td>Set (Mise à 1)</td></tr>
            <tr><td>1</td><td>0</td><td>0</td><td>Reset (Mise à 0)</td></tr>
            <tr><td>1</td><td>1</td><td>X (Indéterminé/Interdit)</td><td>Interdit</td></tr>
        </tbody>
    </table>
    <div class="placeholder">
        [Image Placeholder: RS Latch Function Table and small diagram from slide 32]
        <img src="placeholder_table_16_and_diag.png" alt="Table de vérité fonctionnelle Verrou RS" style="max-width: 350px; display: block; margin: 10px auto;">
    </div>

    <h4>Équation Caractéristique (Tableau de Karnaugh)</h4>
    <p>L'équation caractéristique exprime l'état futur \( Q_{n+1} \) en fonction des entrées (R, S) et de l'état présent \( Q_n \).</p>
    <p>Table de vérité détaillée pour \( Q_{n+1} \) :</p>
    <table>
        <thead><tr><th>R</th><th>S</th><th>\( Q_n \)</th><th>\( Q_{n+1} \)</th></tr></thead>
        <tbody>
            <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
            <tr><td>0</td><td>0</td><td>1</td><td>1</td></tr>
            <tr><td>0</td><td>1</td><td>0</td><td>1</td></tr>
            <tr><td>0</td><td>1</td><td>1</td><td>1</td></tr>
            <tr><td>1</td><td>0</td><td>0</td><td>0</td></tr>
            <tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
            <tr><td>1</td><td>1</td><td>0</td><td>X</td></tr>
            <tr><td>1</td><td>1</td><td>1</td><td>X</td></tr>
        </tbody>
    </table>

    <p>Tableau de Karnaugh pour \( Q_{n+1} \) (en fonction de R, S, \( Q_n \)):</p>
    <div class="placeholder">
        [Image Placeholder: Detailed Truth Table and Karnaugh Map for Qn+1 from slide 33]
        <img src="placeholder_kmap_qnplus1.png" alt="Tableau de Karnaugh pour Qn+1" style="max-width: 400px; display: block; margin: 10px auto;">
    </div>
    <p>En regroupant les '1' dans le K-map (on peut utiliser les 'X' comme '1' si cela aide à faire un plus grand groupe), on obtient :</p>
    <ul>
        <li>Un groupe pour S=1 (couvrant \(Q_n=0\) et \(Q_n=1\), avec R=0) donne le terme \( S \).</li>
        <li>Un groupe pour R=0 et \(Q_n=1\) (avec S=0) donne le terme \( \bar{R} Q_n \).</li>
    </ul>
    <p>L'équation logique (caractéristique) du verrou RS (NOR) est :</p>
    <p>\( Q_{n+1} = S + \bar{R} Q_n \)</p>
    <p>(Condition : \( R \cdot S = 0 \) pour éviter l'état interdit)</p>

    <h4>Exercice : Chronogramme (fig. 12)</h4>
    <p>Compléter le chronogramme de la sortie Q d'un verrou RS (NOR) en fonction des entrées R et S données. On suppose que Q est initialement à 0.</p>
    <div class="placeholder">
        [Image Placeholder: Timing Diagram Exercise for RS Latch from slide 34]
        <img src="placeholder_chrono_exercise_rs.png" alt="Exercice chronogramme Verrou RS" style="max-width: 500px; display: block; margin: 10px auto;">
    </div>
    <p>Correction :</p>
    <div class="placeholder">
        [Image Placeholder: Timing Diagram Solution for RS Latch from slide 34]
        <img src="placeholder_chrono_solution_rs.png" alt="Correction chronogramme Verrou RS" style="max-width: 500px; display: block; margin: 10px auto;">
    </div>
    <p>Explication de la correction :</p>
    <ol>
        <li>Initialement Q=0. R=1, S=0 (Reset) → Q reste/va à 0.</li>
        <li>R=0, S=0 (Mémoire) → Q reste à 0.</li>
        <li>R=0, S=1 (Set) → Q passe à 1.</li>
        <li>R=0, S=0 (Mémoire) → Q reste à 1.</li>
        <li>R=1, S=0 (Reset) → Q passe à 0.</li>
        <li>R=0, S=0 (Mémoire) → Q reste à 0.</li>
    </ol>

    <h3>5-1-2 Verrou RSH (Gated RS Latch)</h3>
    <p>
        Le verrou RSH (parfois appelé verrou RS synchronisé par niveau, ou Gated RS Latch) est un verrou RS auquel on ajoute une entrée de commande, souvent appelée H (Horloge, ou E pour Enable/Validation).
    </p>
    <ul>
        <li>Quand H est <strong>active</strong> (niveau 1 dans cet exemple), le verrou se comporte comme un verrou RS normal : les entrées R et S déterminent l'état de sortie Q.</li>
        <li>Quand H est <strong>inactive</strong> (niveau 0), les entrées R et S sont ignorées, et le verrou conserve son état précédent (fonction mémoire). On dit que la sortie est "verrouillée".</li>
    </ul>

    <h4>Symbole (fig. 13a)</h4>
    <div class="placeholder">
        [Image Placeholder: Gated RS Latch Symbol and Clock signal example from slide 35]
        <img src="placeholder_symbol_rsh_latch.png" alt="Symbole du Verrou RSH et signal H" style="max-width: 300px; display: block; margin: 10px auto;">
    </div>

    <h4>Table de vérité (Table 17 - Verrou RSH)</h4>
    <table>
        <thead>
            <tr><th>R</th><th>S</th><th>H</th><th>\( Q_{n+1} \)</th><th>Fonction</th></tr>
        </thead>
        <tbody>
            <tr><td>X</td><td>X</td><td>0 (inactive)</td><td>\( Q_n \)</td><td>Mémoire (Verrouillage)</td></tr>
            <tr><td>0</td><td>0</td><td>1 (active)</td><td>\( Q_n \)</td><td>Mémoire</td></tr>
            <tr><td>0</td><td>1</td><td>1 (active)</td><td>1</td><td>Set</td></tr>
            <tr><td>1</td><td>0</td><td>1 (active)</td><td>0</td><td>Reset</td></tr>
            <tr><td>1</td><td>1</td><td>1 (active)</td><td>X</td><td>Interdit</td></tr>
        </tbody>
        <tfoot><tr><td colspan="5">X = Indifférent (0 ou 1)</td></tr></tfoot>
    </table>
     <div class="placeholder">
        [Image Placeholder: Gated RS Latch Truth Table from slide 35]
        <img src="placeholder_table_17_rsh.png" alt="Table de vérité Verrou RSH" style="max-width: 400px; display: block; margin: 10px auto;">
    </div>

    <h4>Équation logique (Caractéristique)</h4>
    <p>L'équation caractéristique du verrou RSH peut être dérivée de celle du verrou RS simple en ajoutant la condition H :</p>
    <p>\( Q_{n+1} = H \cdot (S + \bar{R} Q_n) + \bar{H} \cdot Q_n \)</p>
    <p>Explication :</p>
    <ul>
        <li>Si H=1 (active), \( Q_{n+1} = 1 \cdot (S + \bar{R} Q_n) + 0 \cdot Q_n = S + \bar{R} Q_n \) (comportement RS normal).</li>
        <li>Si H=0 (inactive), \( Q_{n+1} = 0 \cdot (S + \bar{R} Q_n) + 1 \cdot Q_n = Q_n \) (mémorisation).</li>
    </ul>
     <p><em>Note: La formule donnée dans le slide \( Q_{n+1} = H \cdot (\bar{R} \cdot Q_n + S) + \bar{H} \cdot Q_n \) est correcte mais l'écriture dans l'image \( Q_{n+1} = H \cdot (\overline{R \cdot Q_n} + S) + \bar{H} \cdot Q_n \) semble contenir une erreur de barre sur le terme R.Qn. La version \( S + \bar{R} Q_n \) est standard. L'équation dans l'image du slide 36 est \( Q_{n+1} = H \cdot (\overline{R \cdot Q_n} + S) + \bar{H} \cdot Q_n \), ce qui est une forme différente, probablement issue d'une implémentation spécifique (peut-être basée NAND). En supposant une implémentation standard dérivée du RS NOR, l'équation est \( Q_{n+1} = H \cdot (S + \bar{R} Q_n) + \bar{H} \cdot Q_n \).</em></p>

    <h4>Logigramme</h4>
    <p>Un logigramme possible pour le verrou RSH (correspondant à \( Q_{n+1} = H \cdot (S + \bar{R} Q_n) + \bar{H} \cdot Q_n \) ou une forme équivalente) utilise des portes ET pour "conditionner" les entrées R et S par H, avant de les appliquer à un verrou RS interne, ou utilise une structure comme celle montrée.</p>
    <div class="placeholder">
        [Image Placeholder: Gated RS Latch Logic Diagram from slide 36]
        <img src="placeholder_logigramme_rsh.png" alt="Logigramme Verrou RSH" style="max-width: 400px; display: block; margin: 10px auto;">
        <p><em>Le logigramme montré sur la diapo 36 semble implémenter une logique différente, peut-être basée sur un verrou RS NAND interne. Il faut analyser les portes pour dériver l'équation exacte qu'il représente. Les portes '&' sont des AND, les '≥1' sont des OR. La structure est celle d'un verrou RS NOR mais avec des portes AND ajoutées aux entrées R et S, conditionnées par H. Cependant, la rétroaction semble venir après les portes OR, ce qui est inhabituel. Une structure plus typique mettrait les AND avant un verrou RS de base.</em></p>
    </div>


    <h3>5-1-3 Bascule RSH (RS Flip-Flop)</h3>
    <p>
        Alors qu'un <em>verrou</em> (latch) est sensible au <strong>niveau</strong> de l'entrée d'horloge/validation H (l'état peut changer pendant toute la durée où H est active), une <strong>bascule</strong> (flip-flop) est sensible à une <strong>transition</strong> (un front) de l'entrée d'horloge H.
    </p>
    <p>Il existe deux types principaux de bascules RSH (edge-triggered RS flip-flops) :</p>
    <ul>
        <li><strong>À front montant (positive edge-triggered) :</strong> La bascule ne prend en compte les entrées R et S et ne change éventuellement d'état qu'à l'instant précis où l'horloge H passe de 0 à 1.</li>
        <li><strong>À front descendant (negative edge-triggered) :</strong> La bascule ne prend en compte les entrées R et S et ne change éventuellement d'état qu'à l'instant précis où l'horloge H passe de 1 à 0.</li>
    </ul>
    <p>En dehors de l'instant du front actif, les changements sur les entrées R et S n'ont aucun effet sur la sortie.</p>

    <h4>Symboles (fig. 13b)</h4>
    <p>Le symbole d'une bascule ressemble à celui du verrou, mais l'entrée d'horloge H est marquée d'un triangle (▷) pour indiquer la sensibilité au front.</p>
    <ul>
        <li>Triangle seul : sensible au front montant (0 → 1).</li>
        <li>Triangle précédé d'un cercle d'inversion (○▷) : sensible au front descendant (1 → 0).</li>
    </ul>
     <div class="placeholder">
        [Image Placeholder: RS Flip-Flop Symbols (positive and negative edge) from slide 37]
        <img src="placeholder_symbols_rsh_ff.png" alt="Symboles Bascule RSH (front montant et descendant)" style="max-width: 500px; display: block; margin: 10px auto;">
    </div>
    <p>
        La <strong>table de vérité</strong> fonctionnelle (reliant \( Q_{n+1} \) à R, S, et \( Q_n \) lors du front actif de l'horloge) est la <strong>même</strong> que celle du verrou RSH lorsque H=1. La différence réside dans le moment où ce changement a lieu (uniquement sur le front).
    </p>

    <h4>Exercice : Chronogrammes (fig. 14)</h4>
    <p>Compléter les chronogrammes pour les sorties Q de trois dispositifs différents (un verrou RSH, une bascule RSH à front montant, une bascule RSH à front descendant) soumis aux mêmes signaux d'entrée R, S et H. Supposer Q initialement à 0.</p>
     <div class="placeholder">
        [Image Placeholder: Timing Diagram Exercise for RSH Latch and Flip-Flops from slide 38]
        <img src="placeholder_chrono_exercise_rsh_all.png" alt="Exercice chronogrammes Verrou et Bascules RSH" style="max-width: 600px; display: block; margin: 10px auto;">
    </div>

    <h4>Correction (fig. 14)</h4>
    <div class="placeholder">
        [Image Placeholder: Timing Diagram Solution for RSH Latch and Flip-Flops from slide 39]
        <img src="placeholder_chrono_solution_rsh_all.png" alt="Correction chronogrammes Verrou et Bascules RSH" style="max-width: 600px; display: block; margin: 10px auto;">
    </div>
    <p>Explication de la correction :</p>
    <ul>
        <li><strong>Verrou RSH (1er Q) :</strong> Q suit la logique RS (Set/Reset/Mémoire) pendant les périodes où H=1. Quand H=0, Q est mémorisé.
            <ul>
                <li>H=1 (1ère impulsion) : R=0, S=0 → Q reste 0 (Mémoire).</li>
                <li>H=0 : Q reste 0.</li>
                <li>H=1 (2ème impulsion) : S passe à 1 → Q passe à 1 (Set). Reste 1 même si S revient à 0 car H est encore active.</li>
                <li>H=0 : Q reste 1 (Mémoire).</li>
                <li>H=1 (3ème impulsion) : R passe à 1 → Q passe à 0 (Reset). Reste 0.</li>
                <li>H=0 : Q reste 0.</li>
                <li>H=1 (4ème impulsion) : R=0, S=0 → Q reste 0 (Mémoire).</li>
            </ul>
        </li>
        <li><strong>Bascule RSH front montant (2ème Q) :</strong> Q change uniquement aux instants où H passe de 0 à 1, en fonction de R et S à cet instant précis.
             <ul>
                <li>1er front ↑ : R=0, S=0 → Q reste 0 (Mémoire).</li>
                <li>2ème front ↑ : R=0, S=1 → Q passe à 1 (Set).</li>
                <li>3ème front ↑ : R=1, S=0 → Q passe à 0 (Reset).</li>
                <li>4ème front ↑ : R=0, S=0 → Q reste 0 (Mémoire).</li>
            </ul>
       </li>
       <li><strong>Bascule RSH front descendant (3ème Q) :</strong> Q change uniquement aux instants où H passe de 1 à 0, en fonction de R et S à cet instant précis.
            <ul>
                <li>1er front ↓ : R=0, S=0 → Q reste 0 (Mémoire).</li>
                <li>2ème front ↓ : R=0, S=0 → Q reste 1 (Mémoire - état après le set sur H=1).</li>
                <li>3ème front ↓ : R=0, S=0 → Q reste 0 (Mémoire - état après le reset sur H=1).</li>
                <li>4ème front ↓ : R=0, S=0 → Q reste 0 (Mémoire).</li>
           </ul>
       </li>
    </ul>
     <p><em>Attention: L'analyse ci-dessus et le graphique de correction (slide 39) semblent montrer que la bascule front descendant prend en compte R=0, S=0 au 2ème front descendant, et Q conserve l'état qu'il avait juste avant le front (Q=1). De même au 3ème front descendant, R=0, S=0 et Q conserve l'état précédent (Q=0). C'est le comportement attendu.</em></p>


    <h3>5-1-4 Verrou D (D Latch)</h3>
    <p>
        Le verrou D (Data Latch), aussi appelé verrou transparent, est une évolution du verrou RSH qui élimine l'état interdit (R=1, S=1) et simplifie le contrôle. Il a une seule entrée de données D et une entrée de validation H (ou E).
    </p>
    <ul>
        <li>Lorsque H est <strong>active</strong> (niveau 1), la sortie Q suit (est "transparente" à) l'entrée D. Si D=1, Q=1. Si D=0, Q=0.</li>
        <li>Lorsque H est <strong>inactive</strong> (niveau 0), la sortie Q conserve la dernière valeur qu'elle avait lorsque H était active. La valeur de D est ignorée. La sortie est "verrouillée" ou "latched".</li>
    </ul>
    <p>Le verrou D est souvent construit à partir d'un verrou RSH en connectant D à l'entrée S et \( \bar{D} \) (D inversé) à l'entrée R. Ainsi, on ne peut jamais avoir R=S=1 activement.</p>

    <h4>Symbole</h4>
    <div class="placeholder">
        [Image Placeholder: D Latch Symbol from slide 40]
        <img src="placeholder_symbol_d_latch.png" alt="Symbole Verrou D" style="max-width: 150px; display: block; margin: 10px auto;">
    </div>

    <h4>Table de vérité (Table 18 - Verrou D)</h4>
    <table>
        <thead>
            <tr><th>D</th><th>H</th><th>\( Q_{n+1} \)</th><th>Fonction</th></tr>
        </thead>
        <tbody>
            <tr><td>X</td><td>0 (inactive)</td><td>\( Q_n \)</td><td>Mémoire (Verrouillage)</td></tr>
            <tr><td>0</td><td>1 (active)</td><td>0</td><td>Reset (Q suit D)</td></tr>
            <tr><td>1</td><td>1 (active)</td><td>1</td><td>Set (Q suit D)</td></tr>
        </tbody>
         <tfoot><tr><td colspan="4">X = Indifférent (0 ou 1)</td></tr></tfoot>
   </table>
     <div class="placeholder">
        [Image Placeholder: D Latch Truth Table from slide 40]
        <img src="placeholder_table_18_d_latch.png" alt="Table de vérité Verrou D" style="max-width: 350px; display: block; margin: 10px auto;">
    </div>
    <p>En résumé : Si H=1, \( Q_{n+1} = D \). Si H=0, \( Q_{n+1} = Q_n \).</p>


    <script>
        // Ensure KaTeX rendering after page load and updates
        function doRenderMath() {
             renderMathInElement(document.body, {
                 delimiters: [
                     { left: "$$", right: "$$", display: true },
                     { left: "\\[", right: "\\]", display: true },
                     { left: "$", right: "$", display: false },
                     { left: "\\(", right: "\\)", display: false }
                 ],
                 throwOnError: false
             });
        }
        // Defer initial rendering until KaTeX is loaded
        window.addEventListener('load', doRenderMath);
    </script>
</body>
</html>
