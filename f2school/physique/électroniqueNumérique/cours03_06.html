<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logique Combinatoire - Chapitre IV & V</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"
        onload="renderMathInElement(document.body,{delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\(', right: '\\)', display: false}, {left: '\\[', right: '\\]', display: true} ]});"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 900px; margin: auto; }
        h1, h2, h3, h4, h5, h6 { color: #333; }
        h1 { text-align: center; margin-bottom: 30px; }
        h2 { border-bottom: 2px solid #eee; padding-bottom: 5px; margin-top: 40px; }
        h3 { margin-top: 30px; color: #444; }
        h4 { margin-top: 20px; color: #555; }
        h5 { margin-top: 15px; color: #666; }
        .chapter-intro { display: flex; align-items: flex-start; border-bottom: 1px solid #ccc; padding-bottom: 20px; margin-bottom: 20px; }
        .chapter-intro .text { flex-grow: 1; padding-right: 20px; }
        .chapter-intro figure { margin: 0; text-align: center; }
        .chapter-intro img { max-width: 150px; height: auto; border: 1px solid #ccc; }
        .quote { font-style: italic; text-align: right; margin: 20px 0; color: #555; }
        .example { border: 1px solid #e0e0e0; padding: 15px; margin: 15px 0; background-color: #f9f9f9; border-left: 3px solid #007bff; }
        .example-title { font-weight: bold; margin-bottom: 10px; color: #007bff;}
        .definition { border-left: 3px solid #4CAF50; padding-left: 15px; margin: 15px 0; background-color: #e8f5e9; }
        .note { border-left: 3px solid #ffc107; padding: 10px 15px; margin: 15px 0; background-color: #fff8e1; }
        table { border-collapse: collapse; margin: 20px auto; width: auto; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; vertical-align: middle; }
        th { background-color: #f2f2f2; }
        code, .mono { background-color: #eee; padding: 2px 5px; border-radius: 3px; font-family: monospace; }
        .placeholder { display: block; min-height: 80px; border: 1px dashed #aaa; background-color: #f0f0f0; text-align: center; padding: 20px; margin: 15px 0; font-style: italic; color: #666; box-sizing: border-box; }
        footer { text-align: right; margin-top: 50px; font-size: 0.9em; color: #555; border-top: 1px solid #eee; padding-top: 10px;}
        .page-break { page-break-after: always; border-top: 1px dashed #ccc; margin-top: 20px; }
        /* KaTeX display style */
        .katex-display { text-align: center; margin: 1em 0; overflow-x: auto; overflow-y: hidden; }
        .inline-katex .katex { font-size: 1em; } /* Adjust if needed */
        .op-summary-table td, .op-summary-table th { min-width: 40px; }
        .gate-section { margin-bottom: 25px; padding-bottom: 15px; border-bottom: 1px solid #eee; }
        .gate-symbol { display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; }
        .gate-symbol > div { margin: 10px; }
        .truth-table-inline table { margin: 5px 0; }
    </style>
</head>
<body>

    <!-- Page 1: Title Page (Already present in previous turn) -->
    <!-- <header> ... </header> -->

    <main>
        <!-- Content from previous turn (Pages 3-10 / OCR Pages 1-8) -->
        <!-- ... Chapter IV Introduction ... -->
        <!-- ... Properties of Boolean Algebra ... -->
        <!-- ... Binary Algebra ... -->
        <!-- ... Monovariable Theorems ... -->
        <!-- ... Multivariable Theorems (up to Absorption) ... -->

                    <p>\( A + (B \cdot C) = (A + B) \cdot (A + C) \)</p>
                    <p>On peut remarquer que ce théorème est particulier dans l'algèbre booléenne puisqu'ici les deux expressions sont vraies, alors que seule la première l'est dans l'algèbre ordinaire des nombres réels.</p>
                </section> <!-- End Distributivity -->

                <section id="absorption">
                    <h5>IV.5.6 Absorption</h5>
                    <p>Ce théorème permet de simplifier des expressions où une variable apparaît à la fois seule et dans un terme combiné avec une autre variable.</p>
                    <ul>
                        <li><strong>Absorption 1 :</strong> \( A + (A \cdot B) = A \)</li>
                        <li><strong>Absorption 2 :</strong> \( A \cdot (A + B) = A \)</li>
                    </ul>
                    <p>Variantes utiles :</p>
                    <ul>
                         <li>\( A + (\overline{A} \cdot B) = A + B \)</li>
                         <li>\( A \cdot (\overline{A} + B) = A \cdot B \)</li>
                     </ul>
                    <p>Ce théorème est particulièrement intéressant pour la conception de circuits numériques puisqu'il permet d'éliminer les termes inutiles et par là-même de réduire la complexité du circuit.</p>
                </section> <!-- End Absorption -->

            <!-- Page 9: Duality, De Morgan, Canonical Forms -->
                 <section id="duality">
                     <h5>IV.5.7 Dualité</h5>
                     <p>Deux expressions booléennes sont dites <strong>duales</strong> si l'on peut obtenir l'une à partir de l'autre en remplaçant les opérateurs ET par OU, les opérateurs OU par ET, les <code>0</code> par des <code>1</code>, et les <code>1</code> par des <code>0</code>. Les variables et leurs compléments restent inchangés.</p>
                     <p>Si une identité booléenne est vraie, son identité duale est également vraie.</p>
                     <p>Exemple : On sait que \( A \cdot (A + B) = A \) (Absorption 2). Son expression duale est \( A + (A \cdot B) = A \) (Absorption 1). Si l'une est prouvée, l'autre l'est aussi par dualité.</p>
                     <p>Exemple : Si on sait que \( A \cdot B = \overline{\overline{A} + \overline{B}} \), alors, par dualité, on saura que \( A + B = \overline{\overline{A} \cdot \overline{B}} \).</p>
                </section> <!-- End Duality -->

                <section id="demorgan">
                    <h5>IV.5.8 Théorème de De Morgan</h5>
                    <p>Le théorème (ou les lois) de De Morgan est une application directe du principe de dualité et est fondamental pour la manipulation des expressions booléennes et la simplification des circuits.</p>
                    <ul>
                        <li><strong>Première forme :</strong> Le complément d'une somme (OU) est égal au produit (ET) des compléments.
                           <br> \( \overline{A + B + C + \dots} = \overline{A} \cdot \overline{B} \cdot \overline{C} \cdot \dots \)
                           <br> Pour deux variables : \( \overline{A + B} = \overline{A} \cdot \overline{B} \)
                        </li>
                        <li><strong>Deuxième forme :</strong> Le complément d'un produit (ET) est égal à la somme (OU) des compléments.
                           <br> \( \overline{A \cdot B \cdot C \cdot \dots} = \overline{A} + \overline{B} + \overline{C} + \dots \)
                           <br> Pour deux variables : \( \overline{A \cdot B} = \overline{A} + \overline{B} \)
                        </li>
                    </ul>
                     <p>Voir §IV.7 page 55 pour plus de précisions et conséquences.</p>
                 </section> <!-- End De Morgan -->

                 <section id="canonical-forms">
                     <h5>IV.5.9 Sommes de produits, produits de sommes et forme canonique</h5>
                     <p>Les expressions booléennes peuvent être manipulées et réécrites sous différentes formes. Deux formes standard sont particulièrement utiles :</p>
                     <ul>
                         <li><strong>Somme de Produits (SOP - Sum Of Products) :</strong> L'expression est une somme (OU) de plusieurs termes produits (ET).
                             <br>Exemple : \( F(A,B,C,D) = A \cdot B + A \cdot C \cdot D + B \cdot D \)
                         </li>
                         <li><strong>Produit de Sommes (POS - Product Of Sums) :</strong> L'expression est un produit (ET) de plusieurs termes sommes (OU).
                             <br>Exemple : \( F(A,B,C,D) = (A + B) \cdot (\overline{A} + C + \overline{D}) \cdot (B + \overline{D}) \)
                         </li>
                     </ul>
                     <p>Une expression est dite sous sa <strong>forme canonique</strong> si chaque terme de l'expression contient toutes les variables (soit sous forme directe, soit sous forme complémentée).</p>

                     <h6>IV.5.9.a Forme canonique disjonctive (Somme de Mintermes)</h6>
                     <p>Si une fonction est écrite comme une somme de produits où chaque produit (appelé <strong>minterme</strong>) contient toutes les variables de la fonction, on a une forme canonique disjonctive (ou première forme canonique).</p>
                     <p>Un minterme est un terme produit qui est vrai (égal à 1) pour une seule combinaison spécifique des variables d'entrée.</p>
                     <p>Exemple d'expression canonique disjonctive : \( F = \overline{A}.\overline{B}.C + \overline{A}.B.C + A.\overline{B}.\overline{C} + A.B.C \)</p>
                     <p>Les mintermes correspondent aux lignes de la table de vérité où la sortie de la fonction est <code>1</code>. Ils sont souvent désignés par \(m_i\), où \(i\) est la valeur décimale de la combinaison d'entrée (en considérant A comme le bit de poids fort).</p>
                     <p>Table des mintermes pour une fonction de trois variables (A, B, C) :</p>
                     <table>
                         <thead>
                             <tr><th>A</th><th>B</th><th>C</th><th>Indice (i)</th><th>Minterme (\(m_i\))</th><th>Valeur si A=0, B=0, C=0</th><th>...</th><th>Valeur si A=1, B=1, C=1</th></tr>
                         </thead>
                         <tbody>
                            <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>\(m_0 = \overline{A}\overline{B}\overline{C}\)</td><td>1</td><td>...</td><td>0</td></tr>
                            <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>\(m_1 = \overline{A}\overline{B}C\)</td><td>0</td><td>...</td><td>0</td></tr>
                            <tr><td>0</td><td>1</td><td>0</td><td>2</td><td>\(m_2 = \overline{A}B\overline{C}\)</td><td>0</td><td>...</td><td>0</td></tr>
                            <tr><td>0</td><td>1</td><td>1</td><td>3</td><td>\(m_3 = \overline{A}BC\)</td><td>0</td><td>...</td><td>0</td></tr>
                            <tr><td>1</td><td>0</td><td>0</td><td>4</td><td>\(m_4 = A\overline{B}\overline{C}\)</td><td>0</td><td>...</td><td>0</td></tr>
                            <tr><td>1</td><td>0</td><td>1</td><td>5</td><td>\(m_5 = A\overline{B}C\)</td><td>0</td><td>...</td><td>0</td></tr>
                            <tr><td>1</td><td>1</td><td>0</td><td>6</td><td>\(m_6 = AB\overline{C}\)</td><td>0</td><td>...</td><td>0</td></tr>
                            <tr><td>1</td><td>1</td><td>1</td><td>7</td><td>\(m_7 = ABC\)</td><td>0</td><td>...</td><td>1</td></tr>
                         </tbody>
                     </table>
                     <p>Une fonction peut être exprimée comme la somme (OU logique) des mintermes pour lesquels la fonction vaut 1 : \( F = \sum m_i \). Par exemple, \( F = m_1 + m_4 + m_6 \).</p>
                 </section> <!-- End Canonical Forms SOP -->

            <!-- Page 10: Canonical Forms POS, Representation Example -->
                <section id="canonical-forms-pos">
                    <h6>IV.5.9.b Forme canonique conjonctive (Produit de Maxtermes)</h6>
                    <p>Si une fonction est écrite comme un produit de sommes où chaque somme (appelée <strong>maxterme</strong>) contient toutes les variables de la fonction, on a une forme canonique conjonctive (ou deuxième forme canonique).</p>
                    <p>Un maxterme est un terme somme qui est faux (égal à 0) pour une seule combinaison spécifique des variables d'entrée.</p>
                    <p>Exemple d'expression canonique conjonctive : \( G = (A + B + \overline{C}) \cdot (A + \overline{B} + C) \cdot (\overline{A} + \overline{B} + \overline{C}) \)</p>
                     <p>Les maxtermes correspondent aux lignes de la table de vérité où la sortie de la fonction est <code>0</code>. Ils sont souvent désignés par \(M_i\), où \(i\) est la valeur décimale de la combinaison d'entrée.</p>
                     <p>Table des maxtermes pour une fonction de trois variables (A, B, C) :</p>
                     <table>
                         <thead>
                             <tr><th>A</th><th>B</th><th>C</th><th>Indice (i)</th><th>Maxterme (\(M_i\))</th><th>Valeur si A=0, B=0, C=0</th><th>...</th><th>Valeur si A=1, B=1, C=1</th></tr>
                         </thead>
                         <tbody>
                            <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>\(M_0 = A+B+C\)</td><td>0</td><td>...</td><td>1</td></tr>
                            <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>\(M_1 = A+B+\overline{C}\)</td><td>1</td><td>...</td><td>1</td></tr>
                            <tr><td>0</td><td>1</td><td>0</td><td>2</td><td>\(M_2 = A+\overline{B}+C\)</td><td>1</td><td>...</td><td>1</td></tr>
                            <tr><td>0</td><td>1</td><td>1</td><td>3</td><td>\(M_3 = A+\overline{B}+\overline{C}\)</td><td>1</td><td>...</td><td>1</td></tr>
                            <tr><td>1</td><td>0</td><td>0</td><td>4</td><td>\(M_4 = \overline{A}+B+C\)</td><td>1</td><td>...</td><td>1</td></tr>
                            <tr><td>1</td><td>0</td><td>1</td><td>5</td><td>\(M_5 = \overline{A}+B+\overline{C}\)</td><td>1</td><td>...</td><td>1</td></tr>
                            <tr><td>1</td><td>1</td><td>0</td><td>6</td><td>\(M_6 = \overline{A}+\overline{B}+C\)</td><td>1</td><td>...</td><td>1</td></tr>
                            <tr><td>1</td><td>1</td><td>1</td><td>7</td><td>\(M_7 = \overline{A}+\overline{B}+\overline{C}\)</td><td>1</td><td>...</td><td>0</td></tr>
                         </tbody>
                     </table>
                     <p>Une fonction peut être exprimée comme le produit (ET logique) des maxtermes pour lesquels la fonction vaut 0 : \( F = \prod M_i \). Par exemple, \( F = M_0 \cdot M_2 \cdot M_3 \cdot M_5 \cdot M_7 \).</p>
                     <p>Note : \( m_i = \overline{M_i} \) et \( M_i = \overline{m_i} \).</p>
                 </section> <!-- End Canonical Forms POS -->

                 <section id="representation-conversion">
                     <h6>IV.5.9.c Représentations d'une fonction sous forme de mintermes et maxtermes</h6>
                     <p>Soit la fonction \( F(A, B, C) = A \cdot B + \overline{B} \cdot (A + C) \).</p>
                     <p>Pour la représenter sous forme canonique, on peut suivre ces étapes :</p>
                     <ol>
                         <li><strong>Développer en somme de produits (SOP) :</strong>
                            <br> \( F = A \cdot B + \overline{B} \cdot A + \overline{B} \cdot C \)
                            <br> \( F = A B + A \overline{B} + \overline{B} C \)
                         </li>
                         <li><strong>Introduire les variables manquantes dans chaque terme (expansion en mintermes) :</strong>
                            <br> Un terme comme \(AB\) manque de \(C\). On le multiplie par \( (C + \overline{C}) \), qui vaut 1.
                            <br> \( A B = A B \cdot (C + \overline{C}) = ABC + AB\overline{C} \)
                            <br> \( A \overline{B} = A \overline{B} \cdot (C + \overline{C}) = A\overline{B}C + A\overline{B}\overline{C} \)
                            <br> \( \overline{B} C = \overline{B} C \cdot (A + \overline{A}) = A\overline{B}C + \overline{A}\overline{B}C \)
                         </li>
                         <li><strong>Combiner les termes et éliminer les doublons (Idempotence : \(X+X=X\)) :</strong>
                             <br> \( F = ABC + AB\overline{C} + A\overline{B}C + A\overline{B}\overline{C} + A\overline{B}C + \overline{A}\overline{B}C \)
                             <br> \( F = ABC + AB\overline{C} + A\overline{B}C + A\overline{B}\overline{C} + \overline{A}\overline{B}C \)
                         </li>
                         <li><strong>Identifier les mintermes :</strong>
                             <br> \( ABC \rightarrow m_7 \)
                             <br> \( AB\overline{C} \rightarrow m_6 \)
                             <br> \( A\overline{B}C \rightarrow m_5 \)
                             <br> \( A\overline{B}\overline{C} \rightarrow m_4 \)
                             <br> \( \overline{A}\overline{B}C \rightarrow m_1 \)
                          </li>
                          <li><strong>Écrire la forme canonique disjonctive :</strong>
                              <br> \( F(A,B,C) = m_1 + m_4 + m_5 + m_6 + m_7 \)
                              <br> \( F = \sum m(1, 4, 5, 6, 7) \)
                          </li>
                      </ol>
                     <p>Pour obtenir la <strong>forme canonique conjonctive (produit de maxtermes)</strong> :</p>
                     <ol>
                         <li>Identifier les indices des mintermes qui ne sont *pas* dans la somme (ce sont les indices où F=0) : Les indices de 0 à 7 sont {0, 1, 2, 3, 4, 5, 6, 7}. Les mintermes présents sont {1, 4, 5, 6, 7}. Les mintermes absents (où F=0) sont {0, 2, 3}.</li>
                         <li>La fonction est le produit des maxtermes correspondants aux indices où F=0.
                             <br> \( F(A,B,C) = M_0 \cdot M_2 \cdot M_3 \)
                             <br> \( F = \prod M(0, 2, 3) \)
                         </li>
                         <li>Explicitement :
                             <br> \( M_0 = A+B+C \)
                             <br> \( M_2 = A+\overline{B}+C \)
                             <br> \( M_3 = A+\overline{B}+\overline{C} \)
                             <br> \( F = (A+B+C) \cdot (A+\overline{B}+C) \cdot (A+\overline{B}+\overline{C}) \)
                         </li>
                     </ol>

                     <div class="example">
                         <div class="example-title">▷ Exemple 4.5 (Repris de la page 10/OCR)</div>
                         <p>Représentation sous forme de somme de mintermes pour \( F(A,B,C) = A.\overline{B} + B.(A+C) \)</p>
                         <p>Développement initial : \( F = A\overline{B} + BA + BC = A\overline{B} + AB + BC \)</p>
                         <p>Expansion :</p>
                         <ul>
                             <li>\( A\overline{B} = A\overline{B}(C+\overline{C}) = A\overline{B}C + A\overline{B}\overline{C} \) ( \(m_5 + m_4\) )</li>
                             <li>\( AB = AB(C+\overline{C}) = ABC + AB\overline{C} \) ( \(m_7 + m_6\) )</li>
                             <li>\( BC = BC(A+\overline{A}) = ABC + \overline{A}BC \) ( \(m_7 + m_3\) )</li>
                         </ul>
                         <p>Combinaison et suppression des doublons :</p>
                         <p>\( F = A\overline{B}C + A\overline{B}\overline{C} + ABC + AB\overline{C} + ABC + \overline{A}BC \)</p>
                         <p>\( F = A\overline{B}\overline{C} + A\overline{B}C + \overline{A}BC + AB\overline{C} + ABC \)</p>
                         <p>\( F = m_4 + m_5 + m_3 + m_6 + m_7 \)</p>
                         <p>Donc, \( F = \sum m(3, 4, 5, 6, 7) \)</p>
                         <p><em>(Note : L'OCR original indiquait m(0,1,4,6,7), ce qui correspond à une fonction différente. L'exemple ci-dessus suit le développement standard de l'expression donnée \(A\overline{B} + B(A+C)\).)</em></p>
                     </div>

                     <div class="example">
                        <div class="example-title">▷ Exemple 4.6 (Repris de la page 11/OCR)</div>
                        <p>Représentation sous forme de produit de maxtermes pour \( F(A,B,C) = A.\overline{B} + B.(A+C) \)</p>
                        <p>Nous avons trouvé que \( F = \sum m(3, 4, 5, 6, 7) \).</p>
                        <p>Les indices manquants (où F=0) sont {0, 1, 2}.</p>
                        <p>La fonction est donc le produit des maxtermes correspondants :</p>
                        <p>\( F = M_0 \cdot M_1 \cdot M_2 \)</p>
                        <p>\( F = \prod M(0, 1, 2) \)</p>
                         <p>Explicitement :</p>
                         <p>\( F = (A+B+C) \cdot (A+B+\overline{C}) \cdot (A+\overline{B}+C) \)</p>
                         <p><em>(Note : L'OCR de l'exemple 4.6 montre une dérivation différente et aboutit à \( \prod M(2,3,5) \). Cela semble incohérent avec l'expression de départ si elle est identique à l'exemple 4.5. Il est possible que l'expression de départ ou les étapes intermédiaires dans l'OCR de l'exemple 4.6 soient erronées ou correspondent à une fonction différente. La méthode générale reste cependant valide : trouver les lignes où F=0 et multiplier les maxtermes correspondants.)</em></p>
                        <p>Dérivation alternative via distributivité (tentative de suivre l'OCR) :</p>
                        <p>L'OCR semble partir de \( F = A\overline{B} + AB + BC \) (forme SOP)</p>
                        <p>Puis applique la distributivité \(X+YZ = (X+Y)(X+Z)\) pour obtenir une forme POS. C'est plus complexe :</p>
                        <p>\( F = A\overline{B} + B(A+C) \)</p>
                        <p>\( F = (A\overline{B} + B) \cdot (A\overline{B} + A+C) \)</p>
                        <p>\( F = (A+B)(\overline{B}+B) \cdot (A(1+\overline{B}) + C) \) [Utilisation de \(X+ \overline{X}Y = X+Y\) et \(X+X=X\)]</p>
                        <p>\( F = (A+B)(1) \cdot (A+C) \)</p>
                        <p>\( F = (A+B)(A+C) \)</p>
                        <p>Expansion en maxtermes :</p>
                        <p>\( A+B = A+B + (C\overline{C}) = (A+B+C)(A+B+\overline{C}) \rightarrow M_0 \cdot M_1 \)</p>
                        <p>\( A+C = A+C + (B\overline{B}) = (A+B+C)(A+\overline{B}+C) \rightarrow M_0 \cdot M_2 \)</p>
                        <p>\( F = (M_0 \cdot M_1) \cdot (M_0 \cdot M_2) = M_0 \cdot M_1 \cdot M_2 \)</p>
                        <p>Le résultat est \( \prod M(0,1,2) \). L'OCR \( \prod M(2,3,5) \) reste inexpliqué avec cette fonction de départ.</p>
                    </div>
                 </section> <!-- End Representation Conversion -->

                <section id="summary-properties">
                    <h5>IV.5.10 Résumé des propriétés des opérateurs OU et ET</h5>
                    <p>Tableau récapitulatif des principaux théorèmes et postulats pour les opérations OU (+) et ET (⋅) dans l'algèbre booléenne (binaire).</p>
                    <table class="op-summary-table">
                        <thead>
                            <tr><th>Propriété</th><th>OU (+)</th><th>ET (⋅)</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Identité / Élément neutre</td><td>\( a + 0 = a \)</td><td>\( a \cdot 1 = a \)</td></tr>
                            <tr><td>Élément absorbant / nul</td><td>\( a + 1 = 1 \)</td><td>\( a \cdot 0 = 0 \)</td></tr>
                            <tr><td>Idempotence</td><td>\( a + a = a \)</td><td>\( a \cdot a = a \)</td></tr>
                            <tr><td>Complémentation</td><td>\( a + \overline{a} = 1 \)</td><td>\( a \cdot \overline{a} = 0 \)</td></tr>
                            <tr><td>Involution</td><td colspan="2">\( \overline{\overline{a}} = a \)</td></tr>
                            <tr><td>Commutativité</td><td>\( a + b = b + a \)</td><td>\( a \cdot b = b \cdot a \)</td></tr>
                            <tr><td>Associativité</td><td>\( a + (b + c) = (a + b) + c \)</td><td>\( a \cdot (b \cdot c) = (a \cdot b) \cdot c \)</td></tr>
                            <tr><td rowspan="2">Distributivité</td><td>\( a + (b \cdot c) = (a + b) \cdot (a + c) \)</td><td>\( a \cdot (b + c) = (a \cdot b) + (a \cdot c) \)</td></tr>
                            <tr><td><span class="mono">(a+b)(a+c)</span></td><td><span class="mono">a.b + a.c</span></td></tr>
                            <tr><td>Absorption 1</td><td>\( a + a \cdot b = a \)</td><td>\( a \cdot (a + b) = a \)</td></tr>
                             <tr><td>Absorption 2 (variante)</td><td>\( a + \overline{a} \cdot b = a + b \)</td><td>\( a \cdot (\overline{a} + b) = a \cdot b \)</td></tr>
                             <tr><td rowspan="2">Consensus</td><td>\( a.b + \overline{a}.c + b.c = a.b + \overline{a}.c \)</td><td>\( (a+b).(\overline{a}+c).(b+c) = (a+b).(\overline{a}+c) \)</td></tr>
                             <tr><td><span class="mono">ab + ac</span> (implique bc)</td><td><span class="mono">(a+b)(a+c)</span> (implique b+c)</td></tr>
                            <tr><td>De Morgan</td><td>\( \overline{a+b} = \overline{a} \cdot \overline{b} \)</td><td>\( \overline{a \cdot b} = \overline{a} + \overline{b} \)</td></tr>
                        </tbody>
                    </table>
                </section> <!-- End Summary Properties -->
            </section> <!-- End Multivariable Theorems -->

        </article> <!-- End Chapter IV Part 1 -->

        <div class="page-break"></div>

        <article> <!-- Chapter IV Part 2: Logic Gates -->
            <section id="logic-gates">
                <h3>IV.6 Opérateurs logiques élémentaires et composés (Portes Logiques)</h3>
                <p>Les fonctions logiques sont physiquement réalisées dans les circuits numériques à l'aide de composants électroniques appelés <strong>portes logiques</strong> (logic gates). Chaque opérateur booléen de base (ET, OU, NON) ainsi que certaines combinaisons courantes (NON-ET, NON-OU, OU-exclusif) correspondent à une porte logique.</p>
                <p>Chaque porte est représentée par un symbole graphique standardisé (normes ANSI/IEEE ou IEC) et sa fonction est définie par sa table de vérité ou son équation booléenne.</p>

                <div class="gate-section" id="gate-yes">
                    <h4>IV.6.1 OUI (Buffer) : identité ou transfert</h4>
                    <p>La porte OUI, souvent appelée buffer ou tampon, ne réalise pas d'opération logique à proprement parler : sa sortie est identique à son entrée (\(S = A\)). Son utilité principale est d'amplifier le signal (capacité de courant en sortie, "fan-out") ou d'isoler des parties de circuit.</p>
                    <div class="gate-symbol">
                        <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte OUI (triangle)]</div></div>
                        <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte OUI IEC (rectangle avec '1')]</div> \(S=A\)</div>
                        <div class="truth-table-inline">Table de vérité:<br>
                            <table><thead><tr><th>A</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td></tr></tbody></table>
                        </div>
                    </div>
                </div>

                <div class="gate-section" id="gate-not">
                    <h4>IV.6.2 NON (NOT) : complément « \( \overline{\phantom{A}} \) »</h4>
                    <p>La porte NON, ou inverseur, produit en sortie le complément logique de son entrée (\( S = \overline{A} \)).</p>
                    <div class="gate-symbol">
                        <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte NON (triangle avec cercle)]</div></div>
                         <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte NON IEC (rectangle avec '1' et sortie inversée)]</div> \(S=\overline{A}\)</div>
                        <div class="truth-table-inline">Table de vérité:<br>
                            <table><thead><tr><th>A</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table>
                        </div>
                    </div>
                 </div>

                <div class="gate-section" id="gate-and">
                    <h4>IV.6.3 ET (AND) : produit logique « \( \cdot \) »</h4>
                    <p>La porte ET produit une sortie <code>1</code> si et seulement si <strong>toutes</strong> ses entrées sont à <code>1</code> (\( S = A \cdot B \)).</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte ET (forme D)]</div></div>
                         <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte ET IEC (rectangle avec '&')]</div> \(S=A \cdot B\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                             <table><thead><tr><th>A</th><th>B</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                         </div>
                     </div>
                    <p><strong>Propriétés du ET :</strong></p>
                    <ul>
                        <li>Élément neutre : 1 (\( a \cdot 1 = a \))</li>
                        <li>Élément absorbant : 0 (\( a \cdot 0 = 0 \))</li>
                        <li>Idempotence : \( a \cdot a = a \)</li>
                        <li>Commutativité : \( a \cdot b = b \cdot a \)</li>
                        <li>Associativité : \( (a \cdot b) \cdot c = a \cdot (b \cdot c) \)</li>
                    </ul>
                </div>

                <div class="gate-section" id="gate-or">
                     <h4>IV.6.4 OU (OR) : somme logique « \( + \) »</h4>
                     <p>La porte OU produit une sortie <code>1</code> si <strong>au moins une</strong> de ses entrées est à <code>1</code> (\( S = A + B \)).</p>
                    <div class="gate-symbol">
                        <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte OU (forme courbe)]</div></div>
                        <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte OU IEC (rectangle avec '≥1')]</div> \(S=A + B\)</div>
                        <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                            <table><thead><tr><th>A</th><th>B</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                        </div>
                    </div>
                     <p><strong>Propriétés du OU :</strong></p>
                     <ul>
                         <li>Élément neutre : 0 (\( a + 0 = a \))</li>
                         <li>Élément absorbant : 1 (\( a + 1 = 1 \))</li>
                         <li>Idempotence : \( a + a = a \)</li>
                         <li>Commutativité : \( a + b = b + a \)</li>
                         <li>Associativité : \( (a + b) + c = a + (b + c) \)</li>
                     </ul>
                     <div class="note">
                        <strong>► Remarque 4.1 : Groupes complets d'opérateurs</strong><br>
                        Les opérateurs {ET, OU, NON} forment un ensemble <strong>complet</strong>, ce qui signifie que toute fonction logique, aussi complexe soit-elle, peut être réalisée en utilisant uniquement une combinaison de ces trois types de portes.
                        <br>Grâce aux lois de De Morgan, on peut montrer que les ensembles {ET, NON} et {OU, NON} sont également complets.
                     </div>
                 </div>

                <div class="gate-section" id="gate-nor">
                     <h4>IV.6.5 NON-OU (NOR) « \( \downarrow \) »</h4>
                     <p>La porte NON-OU (NOR) est l'équivalent d'une porte OU suivie d'une porte NON. Sa sortie est <code>1</code> si et seulement si <strong>toutes</strong> ses entrées sont à <code>0</code> (\( S = \overline{A + B} \)).</p>
                     <p>La porte NOR est un opérateur <strong>universel</strong> ou <strong>complet</strong> : toute fonction logique peut être réalisée en utilisant uniquement des portes NOR.</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte NOR (OU avec cercle)]</div></div>
                         <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte NOR IEC (OU IEC avec sortie inversée)]</div> \(S=\overline{A+B}\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                            <table><thead><tr><th>A</th><th>B</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                         </div>
                     </div>
                </div>

                <div class="gate-section" id="gate-nand">
                     <h4>IV.6.6 NON-ET (NAND) « \( \uparrow \) »</h4>
                     <p>La porte NON-ET (NAND) est l'équivalent d'une porte ET suivie d'une porte NON. Sa sortie est <code>0</code> si et seulement si <strong>toutes</strong> ses entrées sont à <code>1</code> (\( S = \overline{A \cdot B} \)).</p>
                     <p>Comme la porte NOR, la porte NAND est également un opérateur <strong>universel</strong> ou <strong>complet</strong>.</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte NAND (ET avec cercle)]</div></div>
                         <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte NAND IEC (ET IEC avec sortie inversée)]</div> \(S=\overline{A \cdot B}\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                            <table><thead><tr><th>A</th><th>B</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                         </div>
                     </div>
                 </div>

                <div class="gate-section" id="gate-xor">
                     <h4>IV.6.7 OUX (XOR) : ou exclusif ou dilemme « \( \oplus \) »</h4>
                     <p>La porte OU-Exclusif (XOR) produit une sortie <code>1</code> si et seulement si ses entrées ont des niveaux logiques <strong>différents</strong> (un nombre impair d'entrées à 1 pour le cas général). Pour deux entrées : \( S = A \oplus B = A\overline{B} + \overline{A}B \).</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte XOR (OU avec ligne additionnelle)]</div></div>
                         <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte XOR IEC (rectangle avec '=1')]</div> \(S=A \oplus B\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                            <table><thead><tr><th>A</th><th>B</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                         </div>
                     </div>
                     <p><strong>Propriétés du OUX :</strong></p>
                     <ul>
                         <li>Commutativité : \( a \oplus b = b \oplus a \)</li>
                         <li>Associativité : \( (a \oplus b) \oplus c = a \oplus (b \oplus c) = a \oplus b \oplus c \)</li>
                         <li>Élément neutre : 0 (\( a \oplus 0 = a \))</li>
                         <li>\( a \oplus 1 = \overline{a} \) (Inverseur commandé)</li>
                         <li>\( a \oplus a = 0 \)</li>
                         <li>\( a \oplus \overline{a} = 1 \)</li>
                         <li>Distributivité de ET sur XOR : \( a \cdot (b \oplus c) = (a \cdot b) \oplus (a \cdot c) \)</li>
                     </ul>
                     <div class="note">
                        <strong>► Remarque 4.2 : Utilisation du XOR</strong><br>
                        Le XOR est très utilisé en arithmétique binaire et logique :
                        <ul>
                            <li><strong>Additionneur Modulo 2 :</strong> La somme de deux bits sans retenue est \( S = A \oplus B \). Dans un additionneur complet, \( S = A \oplus B \oplus C_{in} \).</li>
                            <li><strong>Détection/Correction d'erreurs :</strong> Le calcul de parité utilise des XOR en cascade : \( P = b_0 \oplus b_1 \oplus b_2 \oplus \dots \oplus b_n \). \(P=0\) si le nombre de bits à 1 est pair, \(P=1\) si impair.</li>
                            <li><strong>Inverseur commandé :</strong> Comme \( a \oplus 1 = \overline{a} \) et \( a \oplus 0 = a \), une porte XOR peut servir d'inverseur contrôlé par une entrée de commande.</li>
                        </ul>
                        Le XOR n'est pas un opérateur complet par lui-même. Cependant, comme il permet de réaliser l'inversion (\( \overline{A} = A \oplus 1 \)), les ensembles {XOR, ET} et {XOR, OU} sont des groupes complets.
                     </div>
                     <div class="note">
                         <strong>► Remarque 4.3 : Relations d'identité avec XOR</strong><br>
                         Quelques identités utiles impliquant l'opérateur XOR :
                         <ol>
                            <li>\( a \oplus b = a\overline{b} + \overline{a}b = (a+b) \cdot (\overline{a}+\overline{b}) = (a+b) \cdot \overline{(a \cdot b)} \)</li>
                            <li>\( \overline{(a \oplus b)} = \overline{a} \oplus b = a \oplus \overline{b} = a b + \overline{a}\overline{b} = \overline{(\overline{a} b + a \overline{b})} \) (c'est la fonction XNOR)</li>
                            <li>\( a \oplus a = 0 \)</li>
                             <li>\( a \oplus \overline{a} = 1 \)</li>
                             <li>\( a \oplus 0 = a \)</li>
                             <li>\( a \oplus 1 = \overline{a} \)</li>
                             <li>\( a(b \oplus c) = ab \oplus ac \) (Distributivité du ET sur XOR)</li>
                             <!-- Les identités suivantes de l'OCR sont moins standard ou potentiellement erronées/mal interprétées. Je les commente ou les reformule -->
                             <li>\( a+b = a \oplus b \oplus ab = a \oplus b(1 \oplus a) \) <!-- OCR: 6. a b a⊕b⊕ab a⊕āb ? --> </li>
                             <li>\( a \oplus b = a+b \) si \( ab = 0 \) (si a et b sont mutuellement exclusifs) <!-- OCR: 7. a b a⊕b si ab 0 ? --></li>
                             <li>Si \( a \oplus b = c \), alors \( c \oplus b = a \), \( c \oplus a = b \), et \( a \oplus b \oplus c = 0 \) <!-- OCR: 8. a⊕b c ⇒ c⊕b a, c⊕a b, a⊕b⊕c 0 --></li>
                             <li>\( a \oplus (ab) = a\overline{b} \) <!-- OCR: 9. a⊕(ab) āb ? (L'OCR a un āb, mais le calcul donne a\overline{b}) --></li>
                             <li>\( a \oplus (\overline{a}b) = a+b \) <!-- OCR: 10. a ab ab ? (L'OCR a a + ab ??) --></li>
                         </ol>
                    </div>
                </div>

                <div class="gate-section" id="gate-xnor">
                    <h4>IV.6.8 NON-OUX (XNOR) : coïncidence ou équivalence « \( \odot \) » ou « \( \equiv \) »</h4>
                    <p>La porte NON-OU-Exclusif (XNOR), aussi appelée porte d'équivalence ou de coïncidence, est l'inverse de la porte XOR. Sa sortie est <code>1</code> si et seulement si ses entrées ont des niveaux logiques <strong>identiques</strong>. Pour deux entrées : \( S = \overline{A \oplus B} = A B + \overline{A}\overline{B} \).</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br><div class="placeholder">[Placeholder: Symbole porte XNOR (XOR avec cercle)]</div></div>
                         <div>Symbole IEC:<br><div class="placeholder">[Placeholder: Symbole porte XNOR IEC (XOR IEC avec sortie inversée)]</div> \(S=\overline{A \oplus B}\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                            <table><thead><tr><th>A</th><th>B</th><th>S</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                         </div>
                     </div>
                 </div>

                <div class="gate-section" id="gate-imp">
                    <h4>IV.6.9 IMP (IMP) : implication « \( \rightarrow \) » ou « \( \supset \) »</h4>
                    <p>La porte Implication logique (\( A \rightarrow B \)) est fausse (<code>0</code>) uniquement lorsque l'antécédent (A) est vrai (<code>1</code>) et le conséquent (B) est faux (<code>0</code>). Elle est équivalente à \( \overline{A} + B \).</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br>(Pas de symbole standard très répandu)</div>
                         <div>Symbole IEC:<br>(Peut être construit ou utilise notation logique)<br><div class="placeholder">[Placeholder: Symbole porte Implication (si existant, ou construction)]</div> \(S = \overline{A} + B\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                             <table><thead><tr><th>A</th><th>B</th><th>S (\(A \rightarrow B\))</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                         </div>
                     </div>
                     <p><em>Note: Le symbole IEC avec '≥1' et une entrée inversée (\(\overline{A}\)) suivi d'une porte OU correspondrait à l'implication. Le symbole dans l'OCR avec '≥1' seul est celui de la porte OU.</em></p>
                 </div>

                <div class="gate-section" id="gate-inh">
                     <h4>IV.6.10 INH (INHIBIT) : inhibition « \( / \) »</h4>
                     <p>La porte Inhibition (\( A / B \), lire A inhibé par B) a une sortie vraie (<code>1</code>) seulement si A est vrai (<code>1</code>) et B est faux (<code>0</code>). Elle est équivalente à \( A \cdot \overline{B} \).</p>
                     <div class="gate-symbol">
                         <div>Symbole ANSI/IEEE:<br>(Pas de symbole standard unique, souvent ET avec une entrée inversée)</div>
                         <div>Symbole IEC:<br>(Peut être construit ou utilise notation logique)<br><div class="placeholder">[Placeholder: Symbole porte Inhibition (si existant, ou ET avec B inversé)]</div> \(S = A \cdot \overline{B}\)</div>
                         <div class="truth-table-inline">Table de vérité (2 entrées):<br>
                             <table><thead><tr><th>A</th><th>B</th><th>S (\(A / B\))</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                         </div>
                     </div>
                     <p><em>Note: Le symbole dans l'OCR (rectangle '&' avec une entrée inversée) correspond bien à \( A \cdot \overline{B} \) si B est l'entrée inversée.</em></p>
                </div>

                <section id="summary-operators">
                    <h4>IV.6.11 Résumé : les différents opérateurs (Fonctions logiques de deux variables)</h4>
                    <p>Il existe \( 2^{(2^n)} \) fonctions logiques possibles pour \(n\) variables. Pour \(n=2\), il y a \( 2^{(2^2)} = 2^4 = 16 \) fonctions possibles. Le tableau suivant les résume.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Nom</th>
                                <!-- <th>Symbole (Op)</th> -->
                                <th colspan="4">Valeur de F(x,y) pour xy =</th>
                                <th>Expression Algébrique (F)</th>
                                <th>Fonction (F<sub>i</sub>)</th>
                            </tr>
                            <tr>
                                <th></th>
                                <!-- <th></th> -->
                                <th>00</th><th>01</th><th>10</th><th>11</th>
                                <th></th>
                                <th></th>
                             </tr>
                        </thead>
                        <tbody>
                            <tr><td>Zéro (Contradiction)</td><td>0</td><td>0</td><td>0</td><td>0</td><td>\( 0 \)</td><td>\( F_0 \)</td></tr>
                            <tr><td>ET (AND)</td><td>0</td><td>0</td><td>0</td><td>1</td><td>\( x \cdot y \)</td><td>\( F_1 \)</td></tr>
                            <tr><td>Inhibition (x/y)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>\( x \cdot \overline{y} \)</td><td>\( F_2 \)</td></tr>
                            <tr><td>Transfert x</td><td>0</td><td>0</td><td>1</td><td>1</td><td>\( x \)</td><td>\( F_3 \)</td></tr>
                            <tr><td>Inhibition (y/x)</td><td>0</td><td>1</td><td>0</td><td>0</td><td>\( \overline{x} \cdot y \)</td><td>\( F_4 \)</td></tr>
                            <tr><td>Transfert y</td><td>0</td><td>1</td><td>0</td><td>1</td><td>\( y \)</td><td>\( F_5 \)</td></tr>
                            <tr><td>OU Exclusif (XOR)</td><td>0</td><td>1</td><td>1</td><td>0</td><td>\( x \oplus y \) <br> \( x\overline{y} + \overline{x}y \)</td><td>\( F_6 \)</td></tr>
                            <tr><td>OU (OR)</td><td>0</td><td>1</td><td>1</td><td>1</td><td>\( x + y \)</td><td>\( F_7 \)</td></tr>
                            <tr><td>NON-OU (NOR)</td><td>1</td><td>0</td><td>0</td><td>0</td><td>\( \overline{x+y} \) <br> \( \overline{x} \cdot \overline{y} \)</td><td>\( F_8 \)</td></tr>
                            <tr><td>Équivalence (XNOR)</td><td>1</td><td>0</td><td>0</td><td>1</td><td>\( \overline{x \oplus y} \) <br> \( xy + \overline{x}\overline{y} \)</td><td>\( F_9 \)</td></tr>
                            <tr><td>Complément y</td><td>1</td><td>0</td><td>1</td><td>0</td><td>\( \overline{y} \)</td><td>\( F_{10} \)</td></tr>
                            <tr><td>Implication (y ⇒ x)</td><td>1</td><td>0</td><td>1</td><td>1</td><td>\( x + \overline{y} \)</td><td>\( F_{11} \)</td></tr>
                            <tr><td>Complément x</td><td>1</td><td>1</td><td>0</td><td>0</td><td>\( \overline{x} \)</td><td>\( F_{12} \)</td></tr>
                            <tr><td>Implication (x ⇒ y)</td><td>1</td><td>1</td><td>0</td><td>1</td><td>\( \overline{x} + y \)</td><td>\( F_{13} \)</td></tr>
                            <tr><td>NON-ET (NAND)</td><td>1</td><td>1</td><td>1</td><td>0</td><td>\( \overline{x \cdot y} \) <br> \( \overline{x} + \overline{y} \)</td><td>\( F_{14} \)</td></tr>
                             <tr><td>Un (Tautologie)</td><td>1</td><td>1</td><td>1</td><td>1</td><td>\( 1 \)</td><td>\( F_{15} \)</td></tr>
                         </tbody>
                     </table>
                 </section> <!-- End Summary Operators -->
             </section> <!-- End Logic Gates -->

            <div class="page-break"></div>

            <section id="universality">
                <h3>IV.7 Universalité des portes NON-ET et NON-OU</h3>
                <p>Comme mentionné précédemment (§IV.6.5, §IV.6.6), les portes NAND et NOR sont dites <strong>universelles</strong> car n'importe quelle fonction logique peut être réalisée en utilisant uniquement des portes NAND, ou uniquement des portes NOR. C'est très important en pratique car cela permet de fabriquer des circuits intégrés en utilisant un seul type de porte de base.</p>
                 <div class="note">
                    <strong>► Note 4.1 : Théorème de De Morgan (Rappel et Conséquences)</strong><br>
                    Les lois de De Morgan sont cruciales pour comprendre l'universalité et pour manipuler les expressions :
                    <ol>
                        <li>Le complément d'un produit est égal à la somme des compléments : \( \overline{A \cdot B} = \overline{A} + \overline{B} \)</li>
                        <li>Le complément d'une somme est égal au produit des compléments : \( \overline{A + B} = \overline{A} \cdot \overline{B} \)</li>
                    </ol>
                    Ce théorème est très utile pour :
                    <ul>
                        <li>Simplifier des expressions booléennes.</li>
                         <li>Convertir une expression d'une forme (SOP/POS) à une autre.</li>
                         <li>Convertir un circuit utilisant des portes AND/OR/NOT en un circuit équivalent utilisant uniquement des portes NAND ou uniquement des portes NOR.</li>
                         <li>Prouver l'équivalence de circuits.</li>
                    </ul>
                    Il est valable également si A ou B sont des expressions contenant plusieurs variables.
                     <br><strong>Exemple 4.7 (Illustrant De Morgan graphiquement) :</strong>
                     <ol>
                         <li>Une porte NON-OU (NOR) est équivalente à une porte ET dont les entrées sont inversées :
                            <br>\( \overline{A+B} = \overline{A} \cdot \overline{B} \)
                            <div style="display: flex; align-items: center; justify-content: space-around; margin: 10px 0;">
                                <div class="placeholder">[Placeholder: Porte NOR]</div>
                                <div>\( \equiv \)</div>
                                <div class="placeholder">[Placeholder: Porte ET avec cercles (inverseurs) sur les entrées]</div>
                             </div>
                          </li>
                          <li>Une porte NON-ET (NAND) est équivalente à une porte OU dont les entrées sont inversées :
                            <br>\( \overline{A \cdot B} = \overline{A} + \overline{B} \)
                            <div style="display: flex; align-items: center; justify-content: space-around; margin: 10px 0;">
                                 <div class="placeholder">[Placeholder: Porte NAND]</div>
                                 <div>\( \equiv \)</div>
                                 <div class="placeholder">[Placeholder: Porte OU avec cercles (inverseurs) sur les entrées]</div>
                            </div>
                         </li>
                     </ol>
                 </div>
                 <div class="note">
                     <strong>► Note 4.2 : Universalité des portes NON-ET et des portes NON-OU</strong><br>
                     Toutes les portes logiques élémentaires (ET, OU, NON) peuvent être réalisées avec des portes NON-OU (NOR) ou des portes NON-ET (NAND). Puisque {ET, OU, NON} est un ensemble complet, cela prouve l'universalité de NAND et NOR.
                 </div>

                <section id="nor-universality">
                    <h4>IV.7.1 Universalité des portes NON-OU (NOR)</h4>
                    <p>Implémentation des portes de base avec uniquement des portes NOR :</p>
                    <ul>
                        <li><strong>NON :</strong> \( \overline{A} = \overline{A+A} \) (Connecter les entrées d'une porte NOR ensemble)
                            <div class="placeholder">[Placeholder: Schéma NON avec NOR (entrées A connectées à une porte NOR)]</div>
                            \( \qquad a \rightarrow [\text{NOR gate}] \rightarrow \overline{a+a} = \overline{a} \)
                        </li>
                         <li><strong>OU :</strong> \( A+B = \overline{\overline{A+B}} \) (Une porte NOR suivie d'un inverseur NOR)
                             <div class="placeholder">[Placeholder: Schéma OU avec NOR (Porte NOR suivie d'un inverseur NOR)]</div>
                             \( \qquad a, b \rightarrow [\text{NOR gate}] \rightarrow \overline{a+b} \rightarrow [\text{NOR inverter}] \rightarrow \overline{\overline{a+b}} = a+b \)
                        </li>
                        <li><strong>ET :</strong> \( A \cdot B = \overline{\overline{A}} \cdot \overline{\overline{B}} = \overline{\overline{A} + \overline{B}} \) (Inverser les entrées A et B avec des portes NOR, puis les faire entrer dans une troisième porte NOR)
                             <div class="placeholder">[Placeholder: Schéma ET avec NOR (Inverseurs NOR sur A et B, puis NOR)]</div>
                             \( \qquad a \rightarrow [\text{NOR inv}] \rightarrow \overline{a} \)
                             <br>\( \qquad b \rightarrow [\text{NOR inv}] \rightarrow \overline{b} \)
                             <br>\( \qquad \overline{a}, \overline{b} \rightarrow [\text{NOR gate}] \rightarrow \overline{\overline{a}+\overline{b}} = \overline{\overline{a \cdot b}} = a \cdot b \)
                         </li>
                     </ul>
                 </section> <!-- End NOR Universality -->

                <section id="nand-universality">
                     <h4>IV.7.2 Universalité des portes NON-ET (NAND)</h4>
                     <p>Implémentation des portes de base avec uniquement des portes NAND :</p>
                    <ul>
                         <li><strong>NON :</strong> \( \overline{A} = \overline{A \cdot A} \) (Connecter les entrées d'une porte NAND ensemble)
                             <div class="placeholder">[Placeholder: Schéma NON avec NAND (entrées A connectées à une porte NAND)]</div>
                             \( \qquad a \rightarrow [\text{NAND gate}] \rightarrow \overline{a \cdot a} = \overline{a} \)
                         </li>
                         <li><strong>ET :</strong> \( A \cdot B = \overline{\overline{A \cdot B}} \) (Une porte NAND suivie d'un inverseur NAND)
                             <div class="placeholder">[Placeholder: Schéma ET avec NAND (Porte NAND suivie d'un inverseur NAND)]</div>
                             \( \qquad a, b \rightarrow [\text{NAND gate}] \rightarrow \overline{a \cdot b} \rightarrow [\text{NAND inverter}] \rightarrow \overline{\overline{a \cdot b}} = a \cdot b \)
                         </li>
                         <li><strong>OU :</strong> \( A + B = \overline{\overline{A}} + \overline{\overline{B}} = \overline{\overline{A} \cdot \overline{B}} \) (Inverser les entrées A et B avec des portes NAND, puis les faire entrer dans une troisième porte NAND)
                             <div class="placeholder">[Placeholder: Schéma OU avec NAND (Inverseurs NAND sur A et B, puis NAND)]</div>
                             \( \qquad a \rightarrow [\text{NAND inv}] \rightarrow \overline{a} \)
                             <br>\( \qquad b \rightarrow [\text{NAND inv}] \rightarrow \overline{b} \)
                             <br>\( \qquad \overline{a}, \overline{b} \rightarrow [\text{NAND gate}] \rightarrow \overline{\overline{a} \cdot \overline{b}} = \overline{\overline{a+b}} = a+b \)
                         </li>
                     </ul>

                    <div class="example">
                         <div class="example-title">▷ Exemple 4.8 : Réalisation d'une fonction avec CI NAND</div>
                         <p>Réaliser la fonction \( X = AB + CD \) à l'aide uniquement de portes NAND, par exemple en utilisant un circuit intégré (CI) 7400 qui contient 4 portes NAND à 2 entrées.</p>
                         <p><strong>Méthode :</strong></p>
                         <ol>
                            <li>Double complémentation : \( X = \overline{\overline{AB + CD}} \)</li>
                            <li>Appliquer De Morgan : \( X = \overline{ (\overline{AB}) \cdot (\overline{CD}) } \)</li>
                         </ol>
                         <p>Cette expression se traduit directement en un circuit à 3 niveaux de portes NAND :</p>
                         <ul>
                             <li>Niveau 1 : Une porte NAND pour calculer \( \overline{AB} \). Une autre porte NAND pour calculer \( \overline{CD} \).</li>
                             <li>Niveau 2 : Une porte NAND pour combiner les résultats : \( \overline{ (\overline{AB}) \cdot (\overline{CD}) } \).</li>
                         </ul>
                         <p>Schéma du circuit et brochage du CI 7400 :</p>
                         <div style="display: flex; justify-content: space-around; align-items: flex-start; flex-wrap: wrap;">
                            <div style="text-align: center;">
                                Brochage du CI 7400 (Quad 2-input NAND)
                                <div class="placeholder">[Placeholder: Brochage CI 7400 (14 pins, VCC, GND, 4x NAND gates)]</div>
                                <p>VCC (14), GND (7)</p>
                            </div>
                            <div style="text-align: center;">
                                Schéma de câblage pour \( X = AB+CD \)
                                <div class="placeholder">[Placeholder: Schéma de la fonction X=AB+CD utilisant 3 portes NAND (ex: U1A, U1B, U1C du 7400)]</div>
                                <p>Entrées: A, B, C, D. Sortie: X.</p>
                                <p>U1A: entrées A, B -> sortie (pin 3) = \( \overline{AB} \)</p>
                                <p>U1B: entrées C, D -> sortie (pin 6) = \( \overline{CD} \)</p>
                                <p>U1C: entrées (pin 3), (pin 6) -> sortie (pin 8) = \( \overline{(\overline{AB}) \cdot (\overline{CD})} = X \)</p>
                                <p>(Utilise 3 des 4 portes du CI)</p>
                            </div>
                         </div>
                    </div>

                    <div class="note">
                        <strong>► Remarque 4.4 : Récapitulatif sur les groupes complets</strong><br>
                        <ul>
                            <li>Le groupe {ET, OU, NON} est complet.</li>
                            <li>Les groupes {ET, NON} et {OU, NON} sont complets (par De Morgan).</li>
                             <li>Les opérateurs NON-ET (NAND) et NON-OU (NOR) sont chacun complets (universels).</li>
                             <li>Comme l'opérateur OUX (XOR) permet de réaliser l'inverseur (\( A \oplus 1 = \overline{A} \)), les groupes {ET, OUX} et {OU, OUX} sont également des groupes complets.</li>
                             <li>Le groupe {ET, OUX} (AND, XOR) est particulièrement intéressant car il forme une structure algébrique appelée <strong>anneau booléen</strong> (ou corps de Galois GF(2) si on considère l'ensemble {0, 1}). L'addition est le XOR (\(\oplus\)) et la multiplication est le ET (\(\cdot\)).</li>
                        </ul>
                    </div>
                </section> <!-- End NAND Universality -->
            </section> <!-- End Universality -->
        </article> <!-- End Chapter IV Part 2 -->

        <div class="page-break"></div>

        <!-- Page 19: Chapter V Start -->
        <article>
            <div class="chapter-intro">
                <div class="text">
                    <h2>Chapitre V</h2>
                    <h3>Représentation et simplification des fonctions logiques</h3>
                </div>
                <figure>
                    <div class="placeholder">[Placeholder: Portrait de George Boole]</div>
                     <figcaption>
                         George Boole<br>
                         * 2 nov. 1815, Lincoln, R.-U.<br>
                         † 8 déc. 1864, Ballintemple, Irlande
                     </figcaption>
                 </figure>
            </div>

            <p class="quote">« Une proposition peut être vraie ou fausse, mais ne peut pas être vraie et fausse. »<br> (Aristote * 384, † 322 av. J.-C.)</p>

            <p>Tout circuit logique peut être décrit par une ou plusieurs <strong>fonctions logiques</strong> (expressions booléennes) reliant ses sorties à ses entrées, ou par une <strong>table de vérité</strong>. Un circuit peut ensuite être réalisé (construit) à partir des opérateurs logiques élémentaires (portes).</p>
            <p>Ce chapitre explore différentes méthodes pour représenter ces fonctions logiques et, surtout, des techniques pour les <strong>simplifier</strong> afin d'obtenir des circuits plus efficaces (moins de portes, moins coûteux, plus rapides).</p>

            <section id="representation-methods">
                <h4>V.1 Méthodes de représentation des fonctions logiques</h4>
                <p>En dehors de la représentation algébrique (équation booléenne) que nous avons utilisée jusqu'à présent, d'autres méthodes sont couramment employées pour décrire le comportement d'un circuit logique :</p>
                <ul>
                    <li><strong>Représentations tabulaires :</strong> Table de vérité, Table de Karnaugh, Diagramme de Veitch.</li>
                    <li><strong>Représentations implicites :</strong> Utilisation de notations compactes comme la somme de mintermes (\(\sum m\)) ou le produit de maxtermes (\(\prod M\)).</li>
                    <li><strong>Représentations graphiques :</strong> Schéma logique (avec symboles de portes), Diagrammes de décision binaire (BDD).</li>
                </ul>
                <p>Les plus couramment employées (en plus de l'équation) sont les représentations tabulaires, notamment la table de vérité et le tableau (ou diagramme) de Karnaugh.</p>

                <section id="tabular-repr">
                    <h5>V.1.1 Représentations tabulaires</h5>

                    <section id="truth-table">
                        <h6>V.1.1.a Table de vérité</h6>
                        <p>La table de vérité est la représentation la plus fondamentale. Elle liste exhaustivement toutes les combinaisons possibles des variables d'entrée et indique, pour chaque combinaison, la valeur correspondante de la ou des sorties.</p>
                        <p>Elle permet de connaître précisément la réaction (sortie) d'un circuit logique pour n'importe quelle situation d'entrée.</p>

                        <div class="example">
                            <div class="example-title">▷ Exemple 5.1 : Table de vérité d'un additionneur complet</div>
                            <p>Un additionneur complet (Full Adder) est un circuit qui additionne trois bits : A, B, et une retenue entrante (C<sub>in</sub> ou C). Il produit deux sorties : la Somme (S) et la Retenue sortante (R ou C<sub>out</sub>).</p>
                            <p>La table de vérité est la suivante :</p>
                             <table>
                                 <thead>
                                    <tr><th>A</th><th>B</th><th>C (C<sub>in</sub>)</th><th>S (Somme)</th><th>R (C<sub>out</sub>)</th></tr>
                                 </thead>
                                 <tbody>
                                    <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                    <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
                                    <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                                    <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
                                    <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
                                    <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
                                    <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                    <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                                 </tbody>
                             </table>
                             <p>Les équations logiques correspondantes (dérivées de la table) sont :</p>
                             <p>\( S = \overline{A}\overline{B}C + \overline{A}B\overline{C} + A\overline{B}\overline{C} + ABC \)<br>
                                \( S = A \oplus B \oplus C \)</p>
                             <p>\( R = \overline{A}BC + A\overline{B}C + AB\overline{C} + ABC \)<br>
                                \( R = AB + AC + BC = AB + C(A \oplus B) \)</p>
                        </div>

                        <div class="example">
                            <div class="example-title">▷ Exemple 5.2 : Circuit à 3 entrées, 2 sorties</div>
                            <p>Donner la table de vérité d'un circuit à 3 entrées A,B,C et 2 sorties X,Y tel que :</p>
                            <ul>
                                <li>\( X = 1 \) si les 3 entrées ont le même niveau (toutes 0 ou toutes 1)</li>
                                <li>\( Y = 1 \) si A = B</li>
                            </ul>
                             <table>
                                 <thead>
                                     <tr><th>A</th><th>B</th><th>C</th><th>X</th><th>Y</th></tr>
                                 </thead>
                                 <tbody>
                                     <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
                                     <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
                                     <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
                                     <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td></tr>
                                     <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                     <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
                                     <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                     <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                                 </tbody>
                             </table>
                             <p>Équations : \( X = \overline{A}\overline{B}\overline{C} + ABC \) (Fonction XNOR à 3 entrées)</p>
                             <p>\( Y = \overline{A}\overline{B}\overline{C} + \overline{A}\overline{B}C + AB\overline{C} + ABC = \overline{A}\overline{B} + AB = \overline{A \oplus B} \) (Fonction XNOR de A et B)</p>
                         </div>
                         <p>Le principal inconvénient de la table de vérité est sa taille : elle croît exponentiellement avec le nombre de variables d'entrée (\(2^n\) lignes pour \(n\) variables). Elle devient rapidement très encombrante et difficile à utiliser pour la simplification manuelle pour \( n > 4 \).</p>
                     </section> <!-- End Truth Table -->

                    <section id="veitch-diagram">
                        <h6>V.1.1.b Diagramme de Veitch</h6>
                        <p>Le diagramme de Veitch (proche du tableau de Karnaugh, mais utilisant un ordre binaire naturel pour les axes) est une représentation tabulaire bidimensionnelle de la table de vérité. Il facilite la visualisation des relations entre les différentes combinaisons d'entrée.</p>
                        <p>Pour \(n\) variables, on divise les variables en deux groupes (par exemple, \(p\) variables pour les colonnes et \(q\) variables pour les lignes, avec \(p+q=n\)). Les lignes et colonnes sont numérotées selon l'ordre binaire naturel des combinaisons des variables associées.</p>
                         <p>Chaque case du diagramme correspond à une ligne de la table de vérité (un minterme). On inscrit dans la case la valeur de la sortie (0 ou 1) pour cette combinaison d'entrée.</p>
                         <p>Diagramme de Veitch pour l'additionneur complet de l'Exemple 5.1 (variables A pour les lignes, BC pour les colonnes) :</p>
                         <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                            <div>
                                <strong>Sortie S (Somme)</strong>
                                <table style="margin-top: 5px;">
                                     <caption>a \ bc</caption>
                                     <thead><tr><th></th><th>00</th><th>01</th><th>10</th><th>11</th></tr></thead>
                                     <tbody>
                                        <tr><th>0 (\(\overline{A}\))</th><td>0</td><td>1</td><td>1</td><td>0</td></tr>
                                        <tr><th>1 (A)</th><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                     </tbody>
                                 </table>
                             </div>
                            <div>
                                <strong>Sortie R (Retenue)</strong>
                                <table style="margin-top: 5px;">
                                     <caption>a \ bc</caption>
                                     <thead><tr><th></th><th>00</th><th>01</th><th>10</th><th>11</th></tr></thead>
                                     <tbody>
                                        <tr><th>0 (\(\overline{A}\))</th><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                                        <tr><th>1 (A)</th><td>0</td><td>1</td><td>1</td><td>1</td></tr>
                                     </tbody>
                                 </table>
                            </div>
                        </div>
                         <p>On peut également numéroter les cases selon l'indice décimal du minterme correspondant (image décimale). L'ordre dépend du choix des variables pour les lignes/colonnes et de leur poids respectif (ex: A=MSB). Pour A (ligne) et BC (colonne), avec A le MSB :</p>
                         <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                            <div>
                                <strong>Sortie S (avec indices décimaux)</strong>
                                <table style="margin-top: 5px; position: relative;">
                                      <caption>a \ bc</caption>
                                      <thead><tr><th></th><th>00</th><th>01</th><th>10</th><th>11</th></tr></thead>
                                      <tbody>
                                         <tr><th>0</th>
                                             <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">0</sub></td>
                                             <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">1</sub></td>
                                             <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">2</sub></td>
                                             <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">3</sub></td>
                                         </tr>
                                         <tr><th>1</th>
                                             <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">4</sub></td>
                                             <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">5</sub></td>
                                             <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">6</sub></td>
                                             <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">7</sub></td>
                                         </tr>
                                      </tbody>
                                  </table>
                                  <p> \( S = \sum m(1, 2, 4, 7) \) </p>
                              </div>
                             <div>
                                <strong>Sortie R (avec indices décimaux)</strong>
                                <table style="margin-top: 5px; position: relative;">
                                       <caption>a \ bc</caption>
                                       <thead><tr><th></th><th>00</th><th>01</th><th>10</th><th>11</th></tr></thead>
                                       <tbody>
                                          <tr><th>0</th>
                                              <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">0</sub></td>
                                              <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">1</sub></td>
                                              <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">2</sub></td>
                                              <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">3</sub></td>
                                          </tr>
                                          <tr><th>1</th>
                                              <td style="position: relative;">0<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">4</sub></td>
                                              <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">5</sub></td>
                                              <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">6</sub></td>
                                              <td style="position: relative;">1<sub style="position: absolute; bottom: 1px; left: 1px; font-size: 0.7em; color: gray;">7</sub></td>
                                          </tr>
                                       </tbody>
                                   </table>
                                 <p> \( R = \sum m(3, 5, 6, 7) \) </p>
                             </div>
                        </div>
                         <p><em>(Note: Le diagramme de Veitch est moins utilisé aujourd'hui que le tableau de Karnaugh, qui utilise un code Gray pour l'ordre des axes, facilitant la simplification visuelle par regroupement de cases adjacentes.)</em> La référence à §V.1.2.b pointera probablement vers le tableau de Karnaugh ou une méthode de simplification associée.</p>
                    </section> <!-- End Veitch Diagram -->
                </section> <!-- End Tabular Representations -->
            </section> <!-- End Representation Methods -->

        </article> <!-- End Chapter V Part 1 -->
    </main>

    <footer>
        <!-- Footer content like page number or copyright can be added here -->
        <span style="float: left;">M. Siadat & C. Diou</span>
        <span style="float: right;">Page [Auto]</span>
        <div style="clear: both;"></div>
    </footer>

</body>
</html>
