<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours d'électronique numérique</title>
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; margin: 20px; }
        h1, h2, h3, h4 { color: #333; }
        h1 { text-align: center; margin-bottom: 0; }
        h2 { border-bottom: 1px solid #eee; padding-bottom: 5px;}
        h3 { margin-top: 1.5em; }
        .title-page { text-align: center; margin-top: 50px; margin-bottom: 50px; }
        .title-page h1 { font-size: 2.5em; margin-bottom: 20px; }
        .title-page p { font-size: 1.2em; margin-top: 10px; }
        .title-page .version { font-size: 0.9em; margin-top: 40px; color: #555; }
        .separator { border: 0; border-top: 2px double #555; margin: 10px auto; width: 80%;}
        .placeholder {
            border: 1px dashed #aaa;
            padding: 40px 20px;
            text-align: center;
            color: #777;
            margin: 20px 0;
            background-color: #fafafa;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        figcaption { text-align: center; font-style: italic; margin-top: 5px; color: #555; }
        table { border-collapse: collapse; margin: 15px 0; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: center; }
        th { background-color: #f9f9f9; }
        ul { list-style: none; padding-left: 0; }
        ul li::before { content: "☞"; padding-right: 8px; color: #555; }
        ul ul li::before { content: "↪"; padding-right: 8px; color: #777; }
        ul ul { padding-left: 20px; }
        .note { border-left: 3px solid #ccc; padding-left: 15px; margin: 15px 0; font-style: italic; }
        .warning { border-left: 3px solid #f0ad4e; padding: 10px 15px; margin: 15px 0; background-color: #fcf8e3; }
        .warning::before { content: "⚠"; margin-right: 10px; font-size: 1.2em; color: #f0ad4e;}
        .example::before { content: "▷ Exemple"; font-weight: bold; margin-right: 5px;}
        .remark::before { content: "► Remarque"; font-weight: bold; margin-right: 5px;}
        .page-footer { text-align: right; margin-top: 30px; font-size: 0.9em; color: #555; }
        .historical-note { display: flex; align-items: flex-start; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px;}
        .historical-note .text { flex-grow: 1; margin-right: 15px; }
        .historical-note .image-placeholder { width: 100px; height: auto; flex-shrink: 0;}
        .chapter-header { font-size: 1.5em; font-weight: bold; margin-bottom: 10px; }
        .special-chars { font-family: 'Times New Roman', Times, serif; } /* Attempt to display special chars */
        code { background-color: #f4f4f4; padding: 2px 5px; border-radius: 3px; }

    </style>
</head>
<body>

    <div class="title-page">
        <hr class="separator">
        <h1>Cours d'électronique numérique</h1>
        <p>Maryam Siadat & Camille Diou</p>
        <hr class="separator">
        <p class="version">Version du 2 novembre 2004</p>
    </div>

    <section id="notes-ouvrage">
        <h2>[ Notes sur cet ouvrage ]</h2>

        <p>Ce document est à la date d'aujourd'hui (2 novembre 2004) toujours en phase d'écriture. Il est donc nécessairement incomplet et peut même encore comporter des erreurs qui n'auraient pas été détectées.</p>

        <p>Ce document doit notamment s'enrichir à l'avenir des points suivants (dans le désordre) :</p>
        <ul>
            <li>la logique mixte</li>
            <li>compléter la simplification des fonctions logiques
                <ul>
                    <li>méthode de Quine/McCluskey</li>
                    <li>diagrammes de Venn, Johnston et Caroll</li>
                    <li>familles logiques et spécifications électriques</li>
                </ul>
            </li>
            <li>étude des systèmes programmables évolués (en complément du chapitre actuel)</li>
            <li>synthèse des systèmes séquentiels synchrones
                <ul>
                    <li>machines d'états (Moore, Huffman, Mealey)</li>
                </ul>
            </li>
            <li>synthèse des systèmes séquentiels asynchrones</li>
            <li>arithmétique binaire et opérateurs arithmétiques</li>
            <li>compléter les exercices et corrigés</li>
        </ul>
        <p style="text-align: right; margin-top: 20px;">3</p>
    </section>

    <section id="details-techniques">
        <h3>Chapitre : Notes sur cet ouvrage</h3>

        <p>Ce document a été réalisé à l'aide des logiciels TeX et LaTeX sous les environnements TeXLive et TeTeX. Les diagrammes sont réalisés à l'aide de Xy-pic. Une partie des schémas électronique est réalisée à l'aide du paquetage CIRC.</p>
         <div class="placeholder">[Placeholder: Logo or icon for CIRC package]</div>

        <p>La police utilisée pour le texte principale est Fourier.</p>
        <p>Les descriptions bibliographiques/historiques présentes dans les entêtes de chapitres sont composée en DayRoman.</p>
        <p>L'extrait du texte de <span class="special-chars">Blaiſe Paſcal</span> du chapitre II <span class="special-chars">eſt</span> également <span class="special-chars">compoſé danſ</span> la police DayRoman, <span class="special-chars">maiſ</span> dotée <span class="special-chars">notament</span> de la ligature ct et du S long (<span class="special-chars">ſ</span>).</p>

        <div class="page-footer">
            <p>4       © M. Siadat & C. Diou</p>
        </div>
    </section>

    <hr style="margin: 40px 0;">

    <section id="partie1">
        <div style="text-align: center; margin-bottom: 30px;">
            <div class="placeholder">[Placeholder: Background image collage related to numbers and numeral systems, as shown on PDF page 5]</div>
            <h1>Première partie</h1>
            <h2>Les nombres</h2>
        </div>
    </section>

    <hr style="margin: 40px 0;">

    <section id="chapitre1">
        <div class="chapter-header">Chapitre I</div>
        <h2>Les systèmes de numération</h2>

        <div class="historical-note">
            <div class="text">
                <p><strong>Gottfried Wilhelm von Leibniz</strong><br>
                * juil. 1646, Allemagne<br>
                † 1716</p>
                <p>Ce philosophe d'origine Allemande est l'inventeur d'une machine permettant de calculer directement les 4 opérations de base. Il est aussi celui qui a introduit la notion de binaire en Occident.</p>
            </div>
            <div class="image-placeholder placeholder">[Placeholder: Portrait of Gottfried Wilhelm von Leibniz]</div>
        </div>

        <h3>I.1 La représentation polynomiale</h3>

        <p>Si nous manipulons les nombres de manière intuitive, c'est la plupart du temps dans la base décimale, naturelle et universelle. Mais cela ne doit pas masquer la nature même de la numération qui peut prendre plusieurs formes, parmi lesquelles on trouve la théorie des ensembles et la représentation polynomiale.</p>

        <p>La représentation polynomiale d'un nombre est sa représentation sous la forme suivante :</p>
        <p>$$ a_{n-1}b^{n-1} + a_{n-2}b^{n-2} + a_{n-3}b^{n-3} + \dots + a_2b^2 + a_1b^1 + a_0b^0 + a_{-1}b^{-1} + a_{-2}b^{-2} + \dots + a_{-m}b^{-m} $$</p>
        <p>où $b$ est appelée la base.</p>

        <div class="note">
           ☞ Si la base 10 nous est familière, d'autres bases existent et les bases les plus utilisées en informatique sont les bases 10, 2, 8 et 16 appelées respectivement « décimale », « binaire », « octale » et « hexadécimale ».
        </div>

        <div class="warning">
            Si la base 10 nous est familière, d'autres bases existent et les bases les plus utilisées en informatique sont les bases 10, 2, 8 et 16 appelées respectivement « décimale », « binaire », « octale » et « hexadécimale ».
        </div>

        <p style="text-align: right; margin-top: 20px;">7</p>
    </section>

    <section id="systeme-binaire">
        <h3>I.2 Le système binaire</h3>

        <h4>I.2.1 Introduction</h4>

        <p>Le système décimal est malheureusement difficile à adapter aux mécanismes numériques, car il est difficile de concevoir du matériel électronique fonctionnant sur dix plages de tensions différentes.</p>

        <p>On lui préférera donc le système binaire :</p>
        <ul>
            <li>base $B=2$ ;</li>
            <li>2 symboles : $\{0, 1\}$ appelés « éléments binaires » ou « bits » (bit = Binary digIT) ;</li>
            <li>le système binaire est pondéré par 2 : les poids sont les puissances de 2 ;</li>
        </ul>

        <p class="example">1.1</p>
        <p>Considérons le nombre binaire $1011001,011_2$. Les poids des positions sont:</p>
        <p>$ \dots \quad 2^6 \quad 2^5 \quad 2^4 \quad 2^3 \quad 2^2 \quad 2^1 \quad 2^0 \quad , \quad 2^{-1} \quad 2^{-2} \quad 2^{-3} \quad \dots $</p>
        <p>$ \dots \quad 64 \quad 32 \quad 16 \quad 8 \quad 4 \quad 2 \quad 1 \quad , \quad 0.5 \quad 0.25 \quad 0.125 \quad \dots $</p>
        <p>Le nombre $1011001,011_2$ correspond à:</p>
        <p>$1 \cdot 2^6 + 0 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 + 0 \cdot 2^{-1} + 1 \cdot 2^{-2} + 1 \cdot 2^{-3}$</p>

        <p>Les différentes puissances de 2 (valeurs entières) sont :</p>
        <p>$2^0=1 \quad 2^1=2 \quad 2^2=4 \quad 2^3=8 \quad 2^4=16 \quad 2^5=32 \quad 2^6=64 \quad 2^7=128 \quad 2^8=256 \quad 2^9=512 \quad 2^{10}=1024$</p>
        <ul>
            <li>un ensemble de 8 bits est appelé « octet » (ou <em>byte</em>).</li>
        </ul>

        <h4>I.2.2 Comptage binaire</h4>

        <p>On présente les nombres binaires en général avec un nombre fixe de bits, nombre imposé par les circuits mémoires utilisés pour représenter ces nombres.</p>

        <p>Suite des nombres binaires à 4 bits :</p>
        <table>
            <thead>
                <tr><th>Poids :</th><th>$2^3$ (8)</th><th>$2^2$ (4)</th><th>$2^1$ (2)</th><th>$2^0$ (1)</th><th>Équivalent Base 10</th></tr>
            </thead>
            <tbody>
                <tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                <tr><td></td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
                <tr><td></td><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td></tr>
                <tr><td></td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td></tr>
                <tr><td></td><td>0</td><td>1</td><td>0</td><td>0</td><td>4</td></tr>
                <tr><td></td><td>0</td><td>1</td><td>0</td><td>1</td><td>5</td></tr>
                <tr><td></td><td>0</td><td>1</td><td>1</td><td>0</td><td>6</td></tr>
                <tr><td></td><td>0</td><td>1</td><td>1</td><td>1</td><td>7</td></tr>
                <tr><td></td><td>1</td><td>0</td><td>0</td><td>0</td><td>8</td></tr>
                <tr><td></td><td>1</td><td>0</td><td>0</td><td>1</td><td>9</td></tr>
                <tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>10</td></tr>
                <tr><td></td><td>1</td><td>0</td><td>1</td><td>1</td><td>11</td></tr>
                <tr><td></td><td>1</td><td>1</td><td>0</td><td>0</td><td>12</td></tr>
                 <tr><td></td><td>1</td><td>1</td><td>0</td><td>1</td><td>13</td></tr>
                <tr><td></td><td>1</td><td>1</td><td>1</td><td>0</td><td>14</td></tr>
                <tr><td></td><td>1</td><td>1</td><td>1</td><td>1</td><td>15</td></tr>
            </tbody>
        </table>
        
        <p>Le bit le plus significatif – le bit le plus à gauche – est appelé « bit de poids fort » ou MSB (<em>Most Significant Bit</em>).</p>
        <p>Le bit le moins significatif – le bit le plus à droite – est appelé « bit de poids faible » ou LSB (<em>Less Significant Bit</em>).</p>

        <p>Si on utilise N bits, on peut représenter $2^N$ valeurs différentes, allant de la valeur 0 à la valeur $2^N - 1$.</p>

        <p class="example">1.2</p>
        <p>Pour N=8 bits : On peut représenter $2^8 = 256$ valeurs.</p>
        <p>$00000000_2 \rightarrow 11111111_2 \quad \leftrightarrow \quad 0_{10} \rightarrow 255_{10}$</p>

        <p class="remark">1.1</p>
        <p>Comme l'on traite souvent en micro-informatique de nombres à 8 ou 16 éléments binaires (e.b.), on se sert des systèmes :</p>
        <ul>
            <li>octal : à base 8;</li>
            <li>hexadécimal : à base 16.</li>
        </ul>

        <div class="page-footer">
           <p>8       © M. Siadat & C. Diou</p>
        </div>
    </section>

    <section id="systeme-octal">
        <h3>I.3 Le système octal</h3>
        <ul>
            <li>base $B=8$ ;</li>
            <li>8 symboles : $\{0, 1, 2, 3, 4, 5, 6, 7\}$ ;</li>
        </ul>

        <p>L'intérêt de ce système est que la base 8 est une puissance de 2 ($8 = 2^3$), donc les poids sont aussi des puissances de 2. La conversion entre binaire et octal est très simple.</p>
        <p>Chaque symbole (chiffre) de la base 8 est exprimé sur exactement 3 éléments binaires (bits) : $(a_i)_8 \leftrightarrow (b_{i2} b_{i1} b_{i0})_2$. Pour convertir, on regroupe les bits par 3 en partant de la virgule.</p>

        <p class="example">1.3</p>
        <p>Conversion Octal vers Binaire:</p>
        <p>$(52,3)_8 \rightarrow (?)_2$</p>
        <p> $5_8 = 101_2$ </p>
        <p> $2_8 = 010_2$ </p>
        <p> $3_8 = 011_2$ </p>
        <p> Donc, $(52,3)_8 = (101 \, 010 , 011)_2$</p>
        <p>Conversion Binaire vers Octal:</p>
        <p> $(110101,11)_2 \rightarrow (?)_8$ </p>
        <p> Regrouper par 3: $(110 \, 101 , 110)_2$ (ajouter un zéro à droite si besoin)</p>
        <p> $110_2 = 6_8$ </p>
        <p> $101_2 = 5_8$ </p>
        <p> $110_2 = 6_8$ </p>
        <p> Donc, $(110101,11)_2 = (65,6)_8$ </p>

        <div class="page-footer">
           <p>© M. Siadat & C. Diou       9</p>
        </div>
    </section>

     <section id="systeme-hexadecimal">
        <h3>I.4 Le système hexadécimal</h3>
         <ul>
            <li>base $B=16$ ;</li>
            <li>16 symboles : $\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\}$ appelés « digits » (ou chiffres hexadécimaux). Les lettres A à F représentent les valeurs décimales 10 à 15.</li>
            <li>chaque symbole est exprimé en binaire sur exactement 4 bits, car $16 = 2^4$.</li>
        </ul>

        <p class="example">1.4</p>
        <p>Conversion Hexadécimal vers Binaire:</p>
        <p>$(F3D,2)_{16} \rightarrow (?)_2$</p>
        <p> $F_{16} = 15_{10} = 1111_2$ </p>
        <p> $3_{16} = 3_{10} = 0011_2$ </p>
        <p> $D_{16} = 13_{10} = 1101_2$ </p>
        <p> $2_{16} = 2_{10} = 0010_2$ </p>
        <p> Donc, $(F3D,2)_{16} = (1111 \, 0011 \, 1101 , 0010)_2$</p>
         <p>Conversion Binaire vers Hexadécimal:</p>
         <p> $(101101110,01101)_2 \rightarrow (?)_{16}$ </p>
         <p> Regrouper par 4: $(0001 \, 0110 \, 1110 , 0110 \, 1000)_2$ (ajouter zéros si besoin)</p>
         <p> $0001_2 = 1_{16}$ </p>
         <p> $0110_2 = 6_{16}$ </p>
         <p> $1110_2 = E_{16}$ </p>
         <p> $0110_2 = 6_{16}$ </p>
         <p> $1000_2 = 8_{16}$ </p>
         <p> Donc, $(101101110,01101)_2 = (16E,68)_{16}$ </p>

        <div class="page-footer" style="margin-top: 10px;">
           <!-- Footer content from next page might belong here contextually -->
        </div>
    </section>


    <section id="conversion">
        <h3>I.5 Conversion d'un système de numération à un autre</h3>

        <h4>I.5.1 Base B vers base 10</h4>
        <p>Pour convertir un nombre $(a_n a_{n-1} \dots a_1 a_0 , a_{-1} a_{-2} \dots a_{-m})_B$ d'une base B vers la base 10, on utilise la définition polynomiale :</p>
        <p>$(N)_B = a_n B^n + a_{n-1} B^{n-1} + \dots + a_1 B^1 + a_0 B^0 + a_{-1} B^{-1} + a_{-2} B^{-2} + \dots + a_{-m} B^{-m} = (N)_{10}$</p>
        <p>On calcule la somme des produits de chaque chiffre par le poids de sa position (puissance de la base B).</p>

        <p class="example">1.5</p>
        <p>$(1001,1)_2 \rightarrow (?)_ {10}$</p>
        <p>$1 \cdot 2^3 + 0 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 + 1 \cdot 2^{-1}$</p>
        <p>$= 1 \cdot 8 + 0 \cdot 4 + 0 \cdot 2 + 1 \cdot 1 + 1 \cdot 0.5$</p>
        <p>$= 8 + 0 + 0 + 1 + 0.5 = 9,5_{10}$</p>

        <p>$(A12)_{16} \rightarrow (?)_ {10}$ (Rappel: $A_{16} = 10_{10}$)</p>
        <p>$A \cdot 16^2 + 1 \cdot 16^1 + 2 \cdot 16^0$</p>
        <p>$= 10 \cdot 256 + 1 \cdot 16 + 2 \cdot 1$</p>
        <p>$= 2560 + 16 + 2 = 2578_{10}$</p>

        <h4>I.5.2 Base 10 vers base B</h4>

        <h5>I.5.2.a Première méthode (Soustraction des poids)</h5>
        <p>Cette méthode est pratique pour les conversions vers la base 2. Elle consiste à soustraire successivement la plus grande puissance de la base B possible du nombre décimal (ou de ce qu'il en reste).</p>
        <p>On commence par la plus grande puissance de B inférieure ou égale au nombre. Si on peut la soustraire, le chiffre correspondant dans la base B est 1 (ou le nombre maximum de fois qu'on peut la soustraire pour B > 2), sinon il est 0. On répète avec le reste et la puissance de B immédiatement inférieure.</p>

        <p class="example">1.6</p>
        <p>Convertir $(100)_{10}$ vers la base 2.</p>
        <p>Puissances de 2 : ..., 128, 64, 32, 16, 8, 4, 2, 1.</p>
        <ul>
            <li>Plus grande puissance $\le 100$ : $64 = 2^6$.</li>
            <li>$100 - 64 = 36$. (Bit $2^6$ = 1)</li>
            <li>Plus grande puissance $\le 36$ : $32 = 2^5$.</li>
            <li>$36 - 32 = 4$. (Bit $2^5$ = 1)</li>
            <li>Puissance suivante $16 = 2^4$. $4 < 16$. (Bit $2^4$ = 0)</li>
            <li>Puissance suivante $8 = 2^3$. $4 < 8$. (Bit $2^3$ = 0)</li>
            <li>Puissance suivante $4 = 2^2$. $4 - 4 = 0$. (Bit $2^2$ = 1)</li>
            <li>Puissance suivante $2 = 2^1$. $0 < 2$. (Bit $2^1$ = 0)</li>
            <li>Puissance suivante $1 = 2^0$. $0 < 1$. (Bit $2^0$ = 0)</li>
        </ul>
         <p>Résultat : En lisant les bits de $2^6$ à $2^0$, on obtient $(1100100)_2$.</p>
         <p> Le PDF montre: <br> $100 \xrightarrow{-1 \cdot 2^6} 36 \xrightarrow{-1 \cdot 2^5} 4 \xrightarrow{-1 \cdot 2^2} 0$. Ce qui correspond aux bits $2^6$, $2^5$, $2^2$ actifs. Il faut inclure les zéros pour les puissances intermédiaires non utilisées ($2^4, 2^3, 2^1, 2^0$). Donc $(100)_{10} = (1100100)_2$.</p>

        <h5>I.5.2.b Deuxième méthode (Divisions/Multiplications successives)</h5>
        <p>Cette méthode est plus générale.</p>
        <ul>
            <li><strong>Pour la partie entière :</strong> Elle consiste à diviser le nombre décimal entier par la base B autant de fois que cela est nécessaire pour obtenir un quotient nul. Les restes successifs des divisions, lus dans l'ordre inverse de leur obtention, donnent les chiffres du nombre dans la base B (du poids faible au poids fort).</li>
            <li><strong>Pour la partie fractionnaire :</strong> Elle consiste à multiplier la partie fractionnaire décimale par la base B. La partie entière du résultat est le premier chiffre après la virgule dans la base B. On répète le processus avec la nouvelle partie fractionnaire du résultat. On continue jusqu'à obtenir une partie fractionnaire nulle ou selon la précision demandée. Les parties entières successives, lues dans l'ordre de leur obtention, donnent les chiffres après la virgule (du poids fort au poids faible).</li>
        </ul>

        <p class="example">1.7</p>
        <p>Convertir $(20,4)_{10}$ vers la base 2.</p>
        <p><em>Partie entière (20) :</em></p>
        <ul>
            <li>$20 \div 2 = 10$ reste $\mathbf{0}$ (LSB)</li>
            <li>$10 \div 2 = 5$ reste $\mathbf{0}$</li>
            <li>$5 \div 2 = 2$ reste $\mathbf{1}$</li>
            <li>$2 \div 2 = 1$ reste $\mathbf{0}$</li>
            <li>$1 \div 2 = 0$ reste $\mathbf{1}$ (MSB)</li>
        </ul>
        <p>Partie entière en base 2 (lecture inverse des restes) : $(10100)_2$.</p>
        <p><em>Partie fractionnaire (0,4) :</em></p>
        <ul>
            <li>$0,4 \times 2 = \mathbf{0},8$ (1er bit après la virgule = 0)</li>
            <li>$0,8 \times 2 = \mathbf{1},6$ (2ème bit = 1)</li>
            <li>$0,6 \times 2 = \mathbf{1},2$ (3ème bit = 1)</li>
            <li>$0,2 \times 2 = \mathbf{0},4$ (4ème bit = 0)</li>
            <li>$0,4 \times 2 = \mathbf{0},8$ (5ème bit = 0) ... Répétition (0110...)</li>
        </ul>
        <p>Partie fractionnaire en base 2 (lecture des parties entières) : $(0,01100110...)_2 = (0, \overline{0110})_2$.</p>
        <p>Résultat final : $(20,4)_{10} = (10100,01100110...)_2$ ou $(10100, \overline{0110})_2$.</p>

        <div class="page-footer">
           <p>10       © M. Siadat & C. Diou</p>
        </div>
    </section>

    <script>
        // Trigger KaTeX rendering
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>

</body>
</html>
