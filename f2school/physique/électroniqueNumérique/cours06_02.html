<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electronique numérique - Étude, adaptation et conception</title>
    <!-- KaTeX includes -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #fdfdfd;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #003366; /* Dark blue */
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        h1 { text-align: center; border-bottom: 2px solid #003366; padding-bottom: 10px; }
        h2 { border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        table {
            border-collapse: collapse;
            margin: 1em 0;
            width: auto;
            border: 1px solid #ccc;
            font-size: 0.9em; /* Smaller font for tables */
        }
        th, td {
            border: 1px solid #ccc;
            padding: 6px; /* Adjusted padding */
            text-align: center;
            vertical-align: middle;
        }
        th {
            background-color: #eef; /* Light blue background for headers */
        }
        code, .katex {
            background-color: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
       dl { margin-left: 10px; }
       dt { font-weight: bold; color: #003366; }
       dd { margin-left: 20px; margin-bottom: 0.5em; }
        .placeholder {
            display: block;
            border: 1px dashed #aaa;
            padding: 20px;
            margin: 1em 0;
            text-align: center;
            color: #777;
            background-color: #fafafa;
            min-height: 50px; /* Minimum height for placeholders */
        }
        .contact-info {
            text-align: right;
            font-size: 0.9em;
            margin-bottom: 2em;
        }
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .address {
            font-size: 0.9em;
        }
        nav ul { list-style-type: none; padding-left: 0; }
        nav > ul > li { font-weight: bold; margin-top: 0.5em; }
        nav ul ul { margin-left: 20px; font-weight: normal; }
        .summary-box {
            border: 1px solid #003366;
            padding: 10px;
            margin: 1em 0;
            background-color: #f0f8ff; /* Alice blue */
            display: inline-block;
        }
        .kmap-table td { width: 40px; height: 40px; } /* Style for Karnaugh maps */
        hr { margin: 3em 0; border: 0; border-top: 1px solid #eee; }
        .footer-watermark { font-size: 0.8em; color: #aaa; text-align: right; margin-top: 1em; }
    </style>
</head>
<body>

    <!-- Page 1 Content -->
    <header class="page-header">
        <div class="address">
            <strong>Philippe LE BRUN</strong><br>
            Lycée Louis ARMAND<br>
            173 Bd de Strasbourg<br>
            94736 NOGENT sur Marne
        </div>
        <div class="contact-info">
            Florence.vadee@wanadoo.fr<br>
            ☎: 01 45 14 28 28<br>
            : 01 48 73 63 15
        </div>
    </header>

    <h1>Electronique numérique</h1>
    <h2>Étude, adaptation et conception<br>De circuits de commande en technologie numérique câblée</h2>

    <section>
        <h3>Objectif</h3>
        <p>Réaliser un circuit de commande en technologie numérique à partir d'un cahier de charges.</p>
    </section>

    <section>
        <h3>Pré-requis</h3>
        <ul>
            <li>Bases d'automatisme du référentiel F3 (Notions fondamentales des systèmes automatisés).</li>
        </ul>
    </section>

    <section>
        <h3>Savoirs associés</h3>
        <ul>
            <li>Bascules, compteurs, multiplexeurs, convertisseurs et mémoires (Composants logiques séquentiels et combinatoires).</li>
            <li>Technologies TTL (Transistor-Transistor Logic) et CMOS (Complementary Metal-Oxide-Semiconductor).</li>
        </ul>
        <p class="footer-watermark">ENSEIGNER L'ELECTROTECHNIQUE ET L'ELECTRONIQUE INDUSTRIELLE</p>
    </section>

    <hr>

    <!-- Page 2 Content -->
    <nav>
        <h2>Sommaire</h2>
        <ul>
            <li>I. Introduction
                <ul>
                    <li>1. Représentation analogique d'une grandeur</li>
                    <li>2. Représentation numérique d'une grandeur</li>
                </ul>
            </li>
            <li>II. Algèbre binaire (rappel)
                <ul>
                    <li>1. Fonctions binaires de base</li>
                    <li>2. Propriétés de l'algèbre binaire</li>
                    <li>3. Fonctions binaires composées</li>
                    <li>4. Symbolisation des fonctions logiques</li>
                    <li>5. Mise en équation et réalisation des fonctions logiques</li>
                </ul>
            </li>
            <li>III. Technologie des fonctions logiques
                <ul>
                    <li>1. Paramètres technologiques (Statiques: tensions, courants, sortance; Dynamiques: temps de propagation, setup, hold)</li>
                    <li>2. Circuit TTL / CMOS rapide (Familles logiques, Comparaison, Interfaçage)</li>
                </ul>
            </li>
            <li>IV. Fonctions logiques séquentielles
                <ul>
                    <li>1. Les bascules (Latches RS, D; Flip-flops D, JK, T)</li>
                    <li>2. Multiplexeur / Démultiplexeur</li>
                    <li>3. Les Compteurs (Asynchrones, Synchrones, Intégrés, Cascading)</li>
                    <li>4. Les Convertisseurs (Numérique/Analogique - DAC, Analogique/Numérique - ADC)</li>
                    <li>5. Les mémoires (RAM, ROM, PROM, EPROM, EEPROM, FPGA, PLD)</li>
                </ul>
            </li>
        </ul>
         <p style="margin-top: 2em;"><em>Sections additionnelles mentionnées :</em></p>
         <ul>
            <li>Travail personnel</li>
            <li>Autocorrection</li>
         </ul>
    </nav>

    <hr>

    <!-- Page 3 Content -->
    <main>
        <article>
            <h2>I. Introduction</h2>
            <p>
                Dans les sciences, dans les techniques, dans les affaires, et dans la plupart des domaines nous sommes amenés à utiliser des grandeurs. Ces grandeurs sont mesurées, surveillées, enregistrées, transformées mathématiquement, observées et exploitées de diverses façons dans des systèmes réels différents. Il est important lorsqu'on travaille avec diverses grandeurs d'être en mesure de représenter correctement et précisément leurs valeurs. Il y a fondamentalement deux manières de représenter la valeur d'une grandeur : la manière analogique et la manière numérique.
            </p>

            <section>
                <h3>1. Représentation analogique d'une grandeur</h3>
                <p>
                    Dans la représentation analogique, on fait correspondre à une grandeur physique (température, pression, vitesse...) une autre grandeur (souvent électrique) qui lui est directement proportionnelle. À titre d'illustration, considérons le tachymètre d'une automobile dans lequel la vitesse est figurée par la déviation d'une aiguille. La position angulaire de cette aiguille est proportionnelle à la vitesse de cette auto, et toute accélération ou tout ralentissement du véhicule se traduit par un déplacement correspondant de l'aiguille.
                </p>
                <p>
                    Les grandeurs analogiques varient <strong>continûment</strong> à l'intérieur d'une gamme de valeurs. La vitesse d'une automobile peut être comprise entre zéro et, mettons, 160 km/h et peut prendre toutes les valeurs comprises entre ces deux extrémités. De même, la sortie d'un microphone peut être n'importe quelle valeur entre zéro et 16 mV (par exemple, 1 mV, 2,3724 mV, 9,9999 mV). Une grandeur analogique peut prendre une infinité de valeurs dans un intervalle donné.
                </p>
            </section>

            <section>
                <h3>2. Représentation numérique d'une grandeur</h3>
                <p>
                    Une grandeur que l'on représente numériquement n'est pas strictement proportionnelle à une autre grandeur, mais est plutôt exprimée au moyen d'un nombre indiquant la valeur approximative de cette grandeur. Une horloge numérique qui donne l'heure du jour au moyen de chiffres représentant les heures, les minutes et les secondes ne peut pas distinguer 1h 30min 20s et 60 centièmes de seconde de 1h 30min 21s et 30 centièmes de seconde. La précision sur la valeur de la grandeur dépend donc du nombre de chiffres utilisés pour coder cette information (ici ± 0,5s pour l'horloge). L'heure du jour est une variable continue, alors que les chiffres d'un affichage numérique (digital) la représentant, eux, ne le sont pas. L'heure qui est affichée progresse par pas d'une minute ou d'une seconde. En d'autres mots, la représentation numérique de l'heure du jour évolue de façon <strong>discontinue</strong> (par pas de 1s), contrairement à sa représentation analogique qui est continue.
                </p>
                <p>
                    Les grandeurs numériques varient par paliers d'autant plus petits que l'on souhaite une précision élevée (on parle de <strong>résolution</strong>) sur une étendue définie au préalable et fixée. L'affichage de l'heure sur 4 digits (heures + minutes) permet une précision de l'ordre de la minute sur une étendue de 24 heures. Une grandeur numérique ne peut prendre qu'un nombre fini de valeurs discrètes dans un intervalle donné.
                </p>
            </section>

            <p>La principale différence entre grandeur analogique et grandeur numérique peut s'exprimer simplement comme suit :</p>
            <div class="summary-box">
                <code>analogique = continu</code><br>
                <code>numérique = discret (discontinu)</code>
            </div>

            <p>
                Pour coder l'information on utilise un système de représentation ayant deux états (binaire) vrai ou faux (représentés par les chiffres 1 ou 0). Ces informations élémentaires (bits) peuvent être associées pour former des mots binaires, qui représentent des nombres ou des instructions.
            </p>
        </article>

        <hr>

        <!-- Page 4 Content -->
        <article>
            <h2>II. Algèbre binaire (rappel)</h2>
            <p>L'algèbre binaire, ou algèbre de Boole, est la base mathématique de l'électronique numérique. Elle manipule des variables qui ne peuvent prendre que deux états (0 ou 1).</p>

            <section>
                <h3>1. Fonctions binaires de base</h3>
                <p>Les fonctions logiques élémentaires peuvent être décrites par leur table de vérité (qui liste toutes les sorties possibles pour chaque combinaison d'entrées) ou leur équation logique.</p>
                 <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                    <div>
                        <h4>La Somme logique (OU / OR)</h4>
                        <p>Equation: \( s = a + b \)</p>
                        <p>La sortie est 1 si au moins une des entrées est 1.</p>
                        <table><caption>Table OU</caption><thead><tr><th>a</th><th>b</th><th>s</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                    </div>
                    <div>
                        <h4>Le Produit logique (ET / AND)</h4>
                        <p>Equation: \( s = a \cdot b \)</p>
                        <p>La sortie est 1 seulement si toutes les entrées sont 1.</p>
                        <table><caption>Table ET</caption><thead><tr><th>a</th><th>b</th><th>s</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                    </div>
                    <div>
                        <h4>La complémentarité (NON / NOT)</h4>
                        <p>Equation: \( s = \overline{a} \)</p>
                        <p>La sortie est l'inverse de l'entrée.</p>
                         <table><caption>Table NON</caption><thead><tr><th>a</th><th>s</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr></tbody></table>
                   </div>
                </div>
            </section>

            <section>
                <h3>2. Propriétés de l'algèbre binaire</h3>
                <p>Voici l'ensemble des propriétés relatives à l'algèbre binaire, utiles pour la simplification des expressions logiques.</p>
                <table style="width: 100%;">
                    <caption>Propriétés de l'Algèbre Binaire</caption>
                    <thead><tr><th>Propriété</th><th>Formulation avec OU (+)</th><th>Formulation avec ET (·)</th></tr></thead>
                    <tbody>
                        <tr><td>Commutativité</td><td>\( a+b = b+a \)</td><td>\( a \cdot b = b \cdot a \)</td></tr>
                        <tr><td>Associativité</td><td>\( (a+b)+c = a+(b+c) \)</td><td>\( (a \cdot b) \cdot c = a \cdot (b \cdot c) \)</td></tr>
                        <tr><td>Distributivité</td><td>\( a + (b \cdot c) = (a+b) \cdot (a+c) \)</td><td>\( a \cdot (b+c) = (a \cdot b) + (a \cdot c) \)</td></tr>
                        <tr><td>Absorption</td><td>\( a + (a \cdot b) = a \)</td><td>\( a \cdot (a+b) = a \)</td></tr>
                        <tr><td>Élément neutre</td><td>\( a + 0 = a \)</td><td>\( a \cdot 1 = a \)</td></tr>
                        <tr><td>Élément absorbant</td><td>\( a + 1 = 1 \)</td><td>\( a \cdot 0 = 0 \)</td></tr>
                        <tr><td>Idempotence</td><td>\( a + a = a \)</td><td>\( a \cdot a = a \)</td></tr>
                        <tr><td>Complémentation</td><td>\( a + \overline{a} = 1 \)</td><td>\( a \cdot \overline{a} = 0 \)</td></tr>
                        <tr><td>Involution</td><td colspan="2">\( \overline{\overline{a}} = a \)</td></tr>
                         <tr><td>Théorèmes de De Morgan</td><td>\( \overline{a+b} = \overline{a} \cdot \overline{b} \)</td><td>\( \overline{a \cdot b} = \overline{a} + \overline{b} \)</td></tr>
                    </tbody>
                </table>
            </section>

            <section>
                <h3>3. Fonctions binaires composées</h3>
                <p>Les fonctions de base peuvent se composer afin de créer des structures plus complexes.</p>
                 <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                    <div>
                        <h4>NAND (NON-ET)</h4>
                        <p>Equation: \( s = \overline{a \cdot b} \)</p>
                        <table><caption>Table NAND</caption><thead><tr><th>a</th><th>b</th><th>s</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                    </div>
                    <div>
                        <h4>NOR (NON-OU)</h4>
                        <p>Equation: \( s = \overline{a+b} \)</p>
                         <table><caption>Table NOR</caption><thead><tr><th>a</th><th>b</th><th>s</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                    </div>
                    <div>
                        <h4>XOR (OU Exclusif)</h4>
                        <p>Equation: \( s = a \oplus b \)</p>
                        <p>Sortie=1 si entrées différentes.</p>
                         <table><caption>Table XOR</caption><thead><tr><th>a</th><th>b</th><th>s</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                   </div>
                </div>
            </section>

            <section>
                 <h3>4. Symbolisation des fonctions logiques</h3>
                 <p>Représentation graphique des portes logiques selon les normes US (ANSI/IEEE) et Européenne (IEC/CEE).</p>
                 <table style="width: 100%;">
                    <caption>Symboles Logiques</caption>
                    <thead><tr><th>Fonction</th><th>Norme US (Américaine)</th><th>Norme CEE (Européenne / IEC)</th></tr></thead>
                    <tbody>
                        <tr><td>OU (OR)</td><td><div class="placeholder">[Placeholder: Symbole US OR]</div></td><td><div class="placeholder">[Placeholder: Symbole CEE OR (>=1)]</div></td></tr>
                        <tr><td>ET (AND)</td><td><div class="placeholder">[Placeholder: Symbole US AND]</div></td><td><div class="placeholder">[Placeholder: Symbole CEE AND (&)]</div></td></tr>
                        <tr><td>NON (NOT)</td><td><div class="placeholder">[Placeholder: Symbole US NOT]</div></td><td><div class="placeholder">[Placeholder: Symbole CEE NOT]</div></td></tr>
                        <tr><td>NOR</td><td><div class="placeholder">[Placeholder: Symbole US NOR]</div></td><td><div class="placeholder">[Placeholder: Symbole CEE NOR]</div></td></tr>
                        <tr><td>NAND</td><td><div class="placeholder">[Placeholder: Symbole US NAND]</div></td><td><div class="placeholder">[Placeholder: Symbole CEE NAND]</div></td></tr>
                        <tr><td>XOR</td><td><div class="placeholder">[Placeholder: Symbole US XOR]</div></td><td><div class="placeholder">[Placeholder: Symbole CEE XOR (=1)]</div></td></tr>
                    </tbody>
                 </table>
             </section>

             <section>
                <h3>5. Mise en équation et réalisation des fonctions logiques</h3>
                <p>Processus de conception : cahier des charges -> table de vérité -> équation -> simplification -> schéma.</p>

                <h4>A. Définition du cahier des charges</h4>
                <p>Automatisme combinatoire à 3 entrées (a, b, c) et 1 sortie (f). Sortie f=1 si :</p>
                <ul>
                    <li>a=0, b=0, c=0</li>
                    <li>(a=0 OU a=1) ET b=0 ET c=1</li>
                    <li>a=0, b=1, c=0</li>
                </ul>

                <h4>B. Représentation par table de vérité</h4>
                <p>Avec 3 entrées, \( 2^3 = 8 \) combinaisons.</p>
                <table>
                     <caption>Table de Vérité pour f(a,b,c)</caption>
                   <thead><tr><th>a</th><th>b</th><th>c</th><th>f</th><th>Justification</th></tr></thead>
                   <tbody>
                        <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>Cond 1</td></tr>
                        <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>Cond 2 (a=0)</td></tr>
                        <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>Cond 3</td></tr>
                        <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>-</td></tr>
                        <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>-</td></tr>
                        <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>Cond 2 (a=1)</td></tr>
                        <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>-</td></tr>
                        <tr><td>1</td><td>1</td><td>1</td><td>0</td><td>-</td></tr>
                   </tbody>
                </table>
                <p>Équation (forme canonique disjonctive) : \( f = \overline{a}\overline{b}\overline{c} + \overline{a}\overline{b}c + \overline{a}b\overline{c} + a\overline{b}c \)</p>
             </section>
        </article>

        <hr>

        <!-- Page 6 Content -->
        <article>
            <p>Équation logique initiale (non simplifiée) : \( f = \overline{a}\overline{b}\overline{c} + \overline{a}\overline{b}c + \overline{a}b\overline{c} + a\overline{b}c \)</p>

            <section>
                <h4>C. Réalisation à l'aide de portes logiques (directe)</h4>
                 <div class="placeholder">[Image Placeholder: Schéma logique complexe initial pour f]</div>
                 <p>Réalisation utilisant des portes NON, ET à 3 entrées, et OU à 4 entrées.</p>
            </section>

            <section>
                <h4>D. Simplification mathématique de l'équation</h4>
                <p> \( f = \overline{a}\overline{c}(\overline{b}+b) + \overline{b}c(\overline{a}+a) = \overline{a}\overline{c} + \overline{b}c \) </p>
                 <div class="placeholder">[Image Placeholder: Schéma logique simplifié pour f]</div>
                 <p>Réalisation simplifiée utilisant des portes NON, ET à 2 entrées, et OU à 2 entrées.</p>
             </section>

            <section>
                <h4>E. Simplification par tableau de KARNAUGH</h4>
                <p>Méthode graphique pour simplifier les équations logiques.</p>
                <table class="kmap-table">
                    <caption>Tableau de Karnaugh pour f(a,b,c)</caption>
                     <thead><tr><th rowspan="2" colspan="2">f</th><th colspan="4">bc</th></tr><tr><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead>
                    <tbody><tr><th rowspan="2">a</th><th>0</th><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><th>1</th><td>0</td><td>1</td><td>0</td><td>0</td></tr></tbody>
                </table>
                 <p>Regroupements: \( \overline{a}\overline{c} \) (cases a=0,bc=00 et a=0,bc=10) et \( \overline{b}c \) (cases a=0,bc=01 et a=1,bc=01).</p>
                 <p>Équation simplifiée : \( f = \overline{a}\overline{c} + \overline{b}c \) </p>
             </section>
         </article>

        <hr>

        <!-- Page 7 Content -->
        <article>
            <p>L'équation simplifiée est identique par les deux méthodes.</p>
        </article>

        <hr>

        <!-- Page 8 Content -->
        <article>
            <h4>Autres exemples de simplification par Karnaugh</h4>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
                <div>
                    <p>Exemple 1 (f1)</p>
                    <table class="kmap-table"><caption>K-Map f1</caption><thead><tr><th rowspan="2" colspan="2">f1</th><th colspan="4">cd</th></tr><tr><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><th rowspan="2">ab</th><th>00</th><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><th>01</th><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><th>11</th><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><th>10</th><td>1</td><td>0</td><td>0</td><td>0</td></tr></tbody></table>
                    <p>Équation PDF: \( f_1 = a\overline{b}c\overline{d}+a\overline{b}\overline{d}+ac \). (Correction: d'après K-map, \( f_1 = \overline{a}b + ac + a\overline{c}\overline{d} \) semble plus optimal).</p>
                </div>
                <div>
                    <p>Exemple 2 (f2)</p>
                     <table class="kmap-table"><caption>K-Map f2</caption><thead><tr><th rowspan="2" colspan="2">f2</th><th colspan="4">cd</th></tr><tr><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><th rowspan="2">ab</th><th>00</th><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><th>01</th><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><th>11</th><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><th>10</th><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table>
                     <p>Équation PDF: \( f_2 = a + \overline{b}\overline{d} \). (Correction: \( f_2 = a + \overline{b}\overline{d} \) semble correct).</p>
                </div>
            </div>

            <section>
                <h4>F. Aléas de propagation (Hazards)</h4>
                <p>Erreurs transitoires dues aux délais de propagation différents. Peuvent survenir lors d'une transition d'entrée qui devrait laisser la sortie stable.</p>
                 <div class="placeholder">[Image Placeholder: Circuit logique et chronogramme illustrant un aléa]</div>
                <p>Se produisent typiquement quand deux groupes Karnaugh adjacents ne sont pas couverts par un groupe redondant sur leur frontière.</p>
                <p>Exemple K-map avec aléa potentiel et groupe redondant :</p>
                 <table class="kmap-table"><caption>K-Map Aléa</caption><thead><tr><th rowspan="2" colspan="2">f</th><th colspan="4">bc</th></tr><tr><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead><tbody><tr><th rowspan="2">a</th><th>0</th><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><th>1</th><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table>
                <p>Groupes minimaux: \( \overline{a}c \) et \( ab \). Transition b: 0->1 (si a=1, c=1) état 101 -> 111. Aléa possible. Groupe redondant: \( ac \). Équation sans aléa: \( f = \overline{a}c + ab + ac \).</p>
            </section>

            <section>
                 <h4>G. Ecriture d'une équation pour réalisation avec un seul type de porte (NAND/NOR)</h4>
                 <p>Utilisation des portes universelles (NAND, NOR) via le théorème de De Morgan.</p>
                 <p><strong>Exemple NAND pour \( f = \overline{a}\overline{c} + \overline{b}c \) :</strong></p>
                 <p> \( f = \overline{\overline{(\overline{a}\overline{c} + \overline{b}c)}} = \overline{ (\overline{\overline{a}\overline{c}}) \cdot (\overline{\overline{b}c}) } \) </p>
                 <p>Forme directement réalisable avec des portes NAND.</p>
             </section>
        </article>

        <hr>

        <!-- Page 9 Content -->
        <article>
            <h4>Schéma de Réalisation avec Portes NAND</h4>
            <div class="placeholder">[Image Placeholder: Schéma logique de f avec portes NAND]</div>

            <hr>

            <h4>Réalisation avec Portes NOR</h4>
            <p><strong>Exemple NOR pour \( f = \overline{a}\overline{c} + \overline{b}c \) :</strong></p>
            <p>Transformation en utilisant De Morgan pour obtenir une forme NOR. \( f = \overline{ (\overline{\overline{a}\overline{c}}) \cdot (\overline{\overline{b}c}) } \) n'est pas une forme NOR directe. On part de \( f = \overline{a}\overline{c} + \overline{b}c \).</p>
            <p>Forme doublement inversée: \( f = \overline{\overline{\overline{a}\overline{c} + \overline{b}c}} \). De Morgan: \( \overline{a}\overline{c} = \overline{a+c} \), \( \overline{b}c = \overline{b+\overline{c}} \).<br> \( f = \overline{\overline{ \overline{a+c} + \overline{b+\overline{c}} }} \). Cette forme (OU de sorties NOR, inversée) peut être réalisée avec des NOR.</p>
            <div class="placeholder">[Image Placeholder: Schéma logique de f avec portes NOR]</div>
        </article>

         <hr>

        <!-- Page 10 Content -->
        <article>
            <h2>III. Technologie des fonctions logiques</h2>
            <p>Caractéristiques électriques des familles logiques (TTL, CMOS...).</p>

            <section>
                <h3>1. Paramètres technologiques (Statiques)</h3>
                <h4>Tension</h4>
                <dl>
                    <dt>Vcc, Vdd</dt><dd>Tension d'alimentation positive (TTL, CMOS)</dd>
                    <dt>GND, Vss</dt><dd>Masse (Référence 0V)</dd>
                    <dt>Vil (max)</dt><dd>Niveau BAS max en entrée</dd>
                    <dt>Vih (min)</dt><dd>Niveau HAUT min en entrée</dd>
                    <dt>Vol (max)</dt><dd>Niveau BAS max en sortie</dd>
                    <dt>Voh (min)</dt><dd>Niveau HAUT min en sortie</dd>
                    <dt>Vth, Vh</dt><dd>Seuil de basculement, Hystérésis</dd>
                </dl>
                <div class="placeholder">[Image Placeholder: Niveaux de tension Voh, Vol, Vih, Vil]</div>

                <h4>Courant</h4>
                 <dl>
                    <dt>Icc</dt><dd>Courant d'alimentation</dd>
                    <dt>Iil, Iih</dt><dd>Courant d'entrée (état BAS, HAUT)</dd>
                    <dt>Iol, Ioh</dt><dd>Courant de sortie (sink/BAS, source/HAUT)</dd>
                    <dt>Ios, Iozl, Iozh</dt><dd>Courant de court-circuit, Courant de fuite (haute impédance)</dd>
                 </dl>
                 <div class="placeholder">[Image Placeholder: Courants Ioh, Iol, Iih, Iil]</div>

                <h4>Divers</h4>
                <dl>
                    <dt>Ta</dt><dd>Température ambiante</dd>
                    <dt>Z</dt><dd>État haute impédance</dd>
                    <dt>Ptot</dt><dd>Puissance dissipée</dd>
                    <dt>C.O./O.D.</dt><dd>Collecteur Ouvert / Drain Ouvert</dd>
                    <dt>N.C.</dt><dd>Non Connecté</dd>
                </dl>

                <h4>Sortance (Fan-out)</h4>
                <p>Nombre max d'entrées qu'une sortie peut piloter. \( \text{Sortance} = \min(S_L, S_H) \)</p>
                <p>\( S_L = \lfloor |I_{OL_{min}}| / |I_{IL_{max}}| \rfloor \), \( S_H = \lfloor |I_{OH_{min}}| / |I_{IH_{max}}| \rfloor \)</p>
            </section>
        </article>

        <hr>

        <!-- Page 11 Content -->
        <article>
             <section>
                <h3>Marge de bruit (Noise Margin)</h3>
                <p>Capacité d'un circuit à tolérer des perturbations (bruit) sur les lignes de signal sans erreur logique. Elle est définie par les écarts entre les niveaux de tension garantis en sortie et les niveaux requis en entrée.</p>
                <div class="placeholder">[Image Placeholder: Diagramme illustrant les marges de bruit Mh et Ml]</div>
                <ul>
                    <li>Marge de bruit HAUT (Mh): \( M_h = V_{OH_{min}} - V_{IH_{min}} \)</li>
                    <li>Marge de bruit BAS (Ml): \( M_l = V_{IL_{max}} - V_{OL_{max}} \)</li>
                </ul>
                <p>Une marge de bruit plus grande indique une meilleure immunité au bruit.</p>

                <h3>Paramètres dynamiques (Timing)</h3>
                <p>Ces paramètres décrivent le comportement temporel des circuits logiques.</p>
                <dl>
                    <dt>f_max</dt><dd>Fréquence d'horloge maximale de fonctionnement.</dd>
                    <dt>tr, tf</dt><dd>Temps de montée (rise time) et temps de descente (fall time) d'un signal (souvent mesurés entre 10% et 90% de l'amplitude).</dd>
                    <dt>tPLH</dt><dd>Temps de propagation pour une transition de sortie de BAS vers HAUT (Propagation Low-to-High).</dd>
                    <dt>tPHL</dt><dd>Temps de propagation pour une transition de sortie de HAUT vers BAS (Propagation High-to-Low).</dd>
                    <dt>tTLH</dt><dd>Temps de transition de sortie de BAS vers HAUT.</dd>
                    <dt>tTHL</dt><dd>Temps de transition de sortie de HAUT vers BAS.</dd>
                    <dt>tSU</dt><dd>Temps de prépositionnement (Setup time) : Intervalle de temps minimum pendant lequel une donnée d'entrée doit être stable AVANT le front actif de l'horloge pour être correctement prise en compte.</dd>
                    <dt>tH</dt><dd>Temps de maintien (Hold time) : Intervalle de temps minimum pendant lequel une donnée d'entrée doit rester stable APRÈS le front actif de l'horloge pour être correctement prise en compte.</dd>
                    <dt>tPZH, tPZL</dt><dd>Temps d'activation de la sortie depuis l'état haute impédance (Z) vers l'état HAUT (H) ou BAS (L).</dd>
                    <dt>tPHZ, tPLZ</dt><dd>Temps de désactivation de la sortie depuis l'état HAUT (H) ou BAS (L) vers l'état haute impédance (Z).</dd>
                    <dt>tr</dt><dd>Temps de recouvrement (Recovery time) : Temps minimum entre la désactivation d'un signal asynchrone (comme Preset ou Clear) et le prochain front actif de l'horloge.</dd>
                 </dl>
                 <div class="placeholder">[Image Placeholder: Chronogramme illustrant tr, tf, tplh, tphl, tsu, th]</div>
                 <p>Ces temps sont cruciaux pour le fonctionnement correct des systèmes séquentiels à haute fréquence.</p>
             </section>
        </article>

        <hr>

        <!-- Page 12 Content -->
        <article>
            <section>
                 <h3>2. Circuit TTL / CMOS rapide</h3>
                 <p>Il existe de nombreuses familles de circuits logiques, chacune optimisée pour certains critères (vitesse, consommation, tension...).</p>
                 <h4>Familles Logiques Principales</h4>
                 <p><strong>À base de transistors bipolaires (principalement TTL) :</strong></p>
                 <ul>
                    <li>74** : TTL standard (Standard) - Obsolète</li>
                    <li>74L** : TTL Faible consommation (Low-power) - Obsolète</li>
                    <li>74S** : TTL Schottky (rapide)</li>
                    <li>74F** : TTL Rapide (Fast)</li>
                    <li>74LS** : TTL Schottky Faible consommation (Low-power Schottky) - Très répandu</li>
                    <li>74AS** : TTL Schottky Avancé (Advanced Schottky)</li>
                    <li>74ALS** : TTL Schottky Avancé Faible consommation (Advanced Low-power Schottky)</li>
                 </ul>
                 <p><strong>À base de transistors MOS (principalement CMOS) :</strong></p>
                  <ul>
                    <li>4000 series : CMOS Classique (lent, très faible conso, large plage Vdd) - Moins utilisé maintenant</li>
                    <li>74C** : CMOS compatible broche à broche avec TTL</li>
                    <li>74HC** : CMOS Haute vitesse (High-speed CMOS), niveaux de tension CMOS</li>
                    <li>74HCT** : CMOS Haute vitesse compatible niveaux d'entrée TTL (High-speed CMOS, TTL-compatible inputs)</li>
                    <li>74AC/ACT, AHC/AHCT, LV, LVC, AUC... : Autres familles CMOS plus récentes (plus rapides, tensions plus basses).</li>
                 </ul>
                 <p>
                    En général, le choix d'une technologie dépend du compromis vitesse/puissance dissipée. Les circuits CMOS (comme HC/HCT) combinent faible consommation statique, bonne immunité au bruit et large gamme de température, les rendant très populaires. L'immunité au bruit des CMOS (ex: HCT) est significativement meilleure que celle des TTL (ex: LS).
                 </p>

                 <h4>Caractéristiques d'Entrées/Sorties Comparées</h4>
                 <p>Tableau comparatif de quelques familles courantes :</p>
                 <table>
                    <caption>Comparaison des Caractéristiques (valeurs typiques/garanties)</caption>
                    <thead><tr><th>Paramètre</th><th>74 (Std)</th><th>L00</th><th>S00</th><th>LS00</th><th>AS00</th><th>ALS00</th><th>F00</th><th>HC00</th><th>HCT00</th><th>Unité</th></tr></thead>
                    <tbody>
                        <tr><td>Iol min</td><td>16</td><td>3.6</td><td>20</td><td>8</td><td>20</td><td>8</td><td>20</td><td>4 (à 4.5V)</td><td>4 (à 4.5V)</td><td>mA</td></tr>
                        <tr><td>Ioh max</td><td>-400</td><td>-200</td><td>-1000</td><td>-400</td><td>-2000</td><td>-400</td><td>-1000</td><td>-4 (à 4.5V)</td><td>-4 (à 4.5V)</td><td>µA</td></tr>
                        <tr><td>Iil max</td><td>-1.6</td><td>-0.18</td><td>-2</td><td>-0.36/-0.4</td><td>-0.5</td><td>-0.1/-0.2</td><td>-0.6</td><td>±1 (à Vcc)</td><td>±1 (à Vcc)</td><td>mA/µA*</td></tr>
                        <tr><td>Iih max</td><td>40</td><td>10</td><td>50</td><td>20</td><td>20</td><td>20</td><td>20</td><td>±1 (à Vcc)</td><td>±1 (à Vcc)</td><td>µA</td></tr>
                        <tr><td>Vol max</td><td>0.4</td><td>0.4</td><td>0.5</td><td>0.5 (Iol=8mA)</td><td>0.5</td><td>0.4/0.5</td><td>0.5</td><td>0.1 (Iol=20µA) / 0.33 (Iol=4mA)</td><td>0.1/0.33</td><td>V</td></tr>
                        <tr><td>Voh min</td><td>2.4</td><td>2.4</td><td>2.7</td><td>2.7 (Ioh=-400µA)</td><td>Vcc-2</td><td>Vcc-2</td><td>2.5/2.7</td><td>4.4 (Ioh=-4mA) / Vcc-0.1 (Ioh=-20µA)</td><td>4.4/Vcc-0.1</td><td>V</td></tr>
                        <tr><td>Vil max</td><td>0.8</td><td>0.7</td><td>0.8</td><td>0.8</td><td>0.8</td><td>0.8</td><td>0.8</td><td>1 (Vcc=5V)</td><td>0.8</td><td>V</td></tr>
                        <tr><td>Vih min</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>3.5 (Vcc=5V)</td><td>2</td><td>V</td></tr>
                    </tbody>
                 </table>
                 <p><small>*Unités : Iil/Iih CMOS sont très faibles (µA), celles des TTL sont plus élevées (mA pour Iil bipolaire). Attention aux conditions de test spécifiques dans les datasheets.</small></p>

                <h4>Sorties à Collecteur Ouvert (Open Collector / Open Drain)</h4>
                <p>Il existe des séries de portes (notamment TTL et CMOS) dites à collecteur ouvert (ou drain ouvert pour CMOS). Leur sortie est constituée uniquement du transistor qui tire vers le niveau BAS (GND). Il n'y a pas de transistor pour tirer activement vers le niveau HAUT (Vcc).</p>
                <div class="placeholder">[Image Placeholder: Schéma d'une sortie à collecteur ouvert (transistor NPN avec collecteur en sortie)]</div>
                <p>Pour obtenir un niveau HAUT logique, une <strong>résistance de rappel (pull-up)</strong> externe doit être connectée entre la sortie et Vcc. L'avantage principal est que plusieurs sorties à collecteur ouvert peuvent être connectées ensemble sur un même fil (bus câblé en "ET logique câblé" ou "wired-AND"). Si une seule sortie est à l'état BAS, elle impose le niveau BAS sur tout le bus. Le bus n'est HAUT que si toutes les sorties sont inactives (état haute impédance virtuel).</p>
             </section>
        </article>

        <hr>

        <!-- Page 13 Content -->
        <article>
            <section>
                <h4>Tableau Comparatif Global (Performances)</h4>
                 <table>
                    <caption>Comparaison TTL / CMOS (Ordres de grandeur)</caption>
                    <thead><tr><th>Paramètre</th><th>TTL (Std)</th><th>TTL LS</th><th>CMOS 4000 (5V)</th><th>CMOS HC (5V)</th><th>CMOS HC (15V)</th></tr></thead>
                    <tbody>
                        <tr><td>Temps de propagation (ns, Cl=15pF/50pF)</td><td>10</td><td>7-10</td><td>~100-200</td><td>~10-20</td><td>~10-20</td></tr>
                        <tr><td>Fréquence d'horloge max (Bascule) (MHz)</td><td>35</td><td>45</td><td>~5</td><td>~30-50</td><td>~30-50</td></tr>
                        <tr><td>Consommation au repos (par porte)</td><td>~1-2 mW</td><td>~0.4 mW</td><td>~quelques nW</td><td>~quelques nW</td><td>~quelques nW</td></tr>
                        <tr><td>Consommation dynamique (par porte @ 1MHz)</td><td>~idem repos</td><td>~idem repos</td><td>~0.1 mW</td><td>~0.1 mW</td><td>~0.7 mW</td></tr>
                        <tr><td>Immunité au bruit (V)</td><td>~0.4 V</td><td>~0.4 V</td><td>~1.5 V</td><td>~1.5 V</td><td>~4.5 V</td></tr>
                        <tr><td>Sortance (vers même famille)</td><td>10</td><td>20 (vers LS)</td><td>>50</td><td>>50 (vers HC) / 10 (vers LS)</td><td>>50</td></tr>
                    </tbody>
                 </table>
                 <p>
                    On préférera une technologie TTL pour les applications nécessitant principalement la <strong>haute vitesse</strong> (ex: informatique).
                    On préférera une technologie CMOS pour les applications privilégiant la <strong>faible consommation</strong> (ex: équipements sur batterie, systèmes embarqués). Les familles CMOS modernes (HC, AHC...) offrent aussi d'excellentes vitesses.
                 </p>

                 <h4>Association TTL vers CMOS</h4>
                 <p>
                    Lorsque les potentiels d'alimentation Vcc (TTL, typ. 5V) et Vdd (CMOS, ex: 5V, 10V, 15V) sont différents, un raccordement direct n'est pas possible ou fiable. Le niveau HAUT garanti en sortie TTL (Voh min ≈ 2.4V - 2.7V) peut être insuffisant pour être reconnu comme un HAUT par une entrée CMOS standard (Vih min ≈ 0.7 * Vdd, soit 3.5V pour Vdd=5V).
                 </p>
                 <p>Solutions :</p>
                 <ul>
                    <li><strong>Résistance de rappel (Pull-up) :</strong> Une résistance connectée entre la sortie TTL et Vdd (l'alimentation CMOS) permet de "tirer" le niveau HAUT TTL vers Vdd lorsque la sortie TTL est inactive (état HAUT). C'est la solution la plus simple si Vdd n'est pas trop élevé.</li>
                    <li><strong>Circuit d'adaptation dédié :</strong> Utiliser un circuit spécifiquement conçu pour l'adaptation de niveaux, comme une porte TTL à collecteur ouvert avec une résistance de rappel vers Vdd, ou un buffer/translateur de niveaux.</li>
                 </ul>
                  <div class="placeholder">[Image Placeholder: Schéma association TTL -> CMOS avec résistance pull-up vers Vdd]</div>
                  <div class="placeholder">[Image Placeholder: Schéma association TTL -> CMOS avec porte TTL Collecteur Ouvert et pull-up vers Vdd]</div>

                 <h4>Association CMOS vers TTL</h4>
                 <p>
                    La connexion se fait généralement directement sans problème majeur si les alimentations sont compatibles (ex: Vdd=Vcc=5V). Les niveaux de sortie CMOS (Voh min proche de Vdd, Vol max proche de GND) sont compatibles avec les niveaux d'entrée TTL (Vih min=2V, Vil max=0.8V).
                 </p>
                 <p>
                    Le principal point d'attention est la capacité en courant : une sortie CMOS standard (série 4000 ou HC) peut ne pas être capable de fournir/absorber assez de courant pour piloter une entrée TTL standard (surtout l'état BAS qui requiert Iil significatif). Une sortie CMOS peut généralement piloter une ou deux entrées TTL LS (Low-power Schottky), mais pas une entrée TTL standard.
                 </p>
                 <p>Solutions :</p>
                 <ul>
                    <li><strong>Utiliser des buffers CMOS :</strong> Intercaler un buffer CMOS (ex: 4049/4050 pour la série 4000, 74HC244/245 pour HC) capable de fournir plus de courant.</li>
                    <li><strong>Choisir la bonne famille :</strong> Utiliser une famille CMOS (comme HCT) spécifiquement conçue pour être compatible en niveaux et en courant avec TTL LS.</li>
                 </ul>
                 <p>
                    Pour des problèmes éventuels d'échauffement ou pour une protection accrue, un circuit d'écrêtage externe (diode Zener + résistance) peut être ajouté à l'entrée TTL, bien que les entrées TTL aient généralement des protections internes.
                 </p>
                  <div class="placeholder">[Image Placeholder: Schéma association CMOS -> TTL (direct ou via buffer)]</div>
                   <div class="placeholder">[Image Placeholder: Schéma circuit d'écrêtage Zener optionnel]</div>
                   <p><small>Note : Les circuits 4049 (inverseur) et 4050 (buffer) sont des exceptions dans la série 4000 car ils peuvent accepter une tension d'entrée supérieure à leur Vdd (jusqu'à 15V), facilitant l'interfaçage depuis des niveaux plus élevés.</small></p>
            </section>
        </article>

        <hr>

        <!-- Page 14 Content -->
        <article>
             <h2>IV. Fonctions logiques séquentielles</h2>
             <p>
                Dans les automatismes séquentiels, la variable de sortie dépend non seulement de l'état actuel des variables d'entrées mais aussi de l'<strong>état précédent</strong> du système (mémorisation). L'évolution se fait souvent de manière synchronisée par un signal d'horloge. Les éléments de base de la logique séquentielle sont les <strong>bascules</strong> (latches et flip-flops).
             </p>

             <section>
                <h3>1. Les bascules (Latches & Flip-Flops)</h3>
                <p>Les bascules sont des circuits capables de mémoriser un bit d'information (0 ou 1). Elles sont utilisées pour construire des registres, des mémoires, des compteurs, etc.</p>

                <h4>Bascule RS asynchrone (RS Latch)</h4>
                <p>
                   C'est la bascule la plus élémentaire. Elle possède deux entrées, S (Set) et R (Reset), et généralement deux sorties complémentaires, Q et \( \overline{Q} \).
                   <ul>
                       <li>Activer S (S=1, R=0) force la sortie Q à 1 (Set).</li>
                       <li>Activer R (S=0, R=1) force la sortie Q à 0 (Reset).</li>
                       <li>Si S=0 et R=0, la bascule conserve son état précédent (mémorisation).</li>
                       <li>La combinaison S=1 et R=1 est généralement <strong>interdite</strong> car elle conduit à un état instable ou indéfini (les deux sorties Q et \( \overline{Q} \) pourraient être égales).</li>
                   </ul>
                   Le comportement exact pour S=R=1 dépend de l'implémentation (priorité).
                </p>

                <p><strong>Implémentation avec portes NOR (Priorité au Reset implicite) :</strong></p>
                <div class="placeholder">[Image Placeholder: Schéma bascule RS avec 2 portes NOR croisées]</div>
                 <table>
                     <caption>Table de Vérité RS Latch (NOR)</caption>
                     <thead><tr><th>S</th><th>R</th><th>Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>État</th></tr></thead>
                    <tbody>
                         <tr><td>0</td><td>0</td><td>Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémoire</td></tr>
                         <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>Reset</td></tr>
                         <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>Set</td></tr>
                         <tr><td>1</td><td>1</td><td>0</td><td>0</td><td>Interdit (instable)</td></tr>
                    </tbody>
                </table>
                <p><em>Note: L'état S=1, R=1 force les deux sorties à 0. Si on revient à S=0, R=0, l'état final est imprévisible.</em></p>


                 <p><strong>Implémentation avec portes NAND (Entrées actives BAS : \( \overline{S}, \overline{R} \)) :</strong></p>
                 <p>Souvent réalisée avec des portes NAND, où les entrées actives sont à l'état BAS.</p>
                 <div class="placeholder">[Image Placeholder: Schéma bascule RS (SR Latch) avec 2 portes NAND croisées]</div>
                 <table>
                    <caption>Table de Vérité \( \overline{S}\overline{R} \) Latch (NAND)</caption>
                     <thead><tr><th>\( \overline{S} \)</th><th>\( \overline{R} \)</th><th>Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>État</th></tr></thead>
                    <tbody>
                         <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>Interdit (instable)</td></tr>
                         <tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Set</td></tr>
                         <tr><td>1</td><td>0</td><td>0</td><td>1</td><td>Reset</td></tr>
                         <tr><td>1</td><td>1</td><td>Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémoire</td></tr>
                    </tbody>
                 </table>
                 <p><em>Note: L'état \( \overline{S}=0, \overline{R}=0 \) force les deux sorties à 1. Si on revient à \( \overline{S}=1, \overline{R}=1 \), l'état final est imprévisible. C'est l'état \( \overline{S}=1, \overline{R}=1 \) qui correspond à la mémorisation.</em></p>

                <h4>Bascules RS synchrones (Gated RS Latch)</h4>
                <p>
                    Pour contrôler le moment où la bascule peut changer d'état, on ajoute une entrée d'horloge (H, CLK, E ou G - Enable/Gate). Le changement d'état ne peut se produire que lorsque cette entrée de contrôle est active.
                </p>
                 <p>Il existe deux modes principaux de fonctionnement synchrone :</p>
                 <ul>
                    <li><strong>Déclenchement sur niveau (Level-triggered) :</strong> Le changement d'état peut se faire pendant toute la durée où l'horloge est à son niveau actif (ex: H=1). On parle alors de <strong>Latch</strong>. La sortie suit les entrées tant que H=1.</li>
                    <li><strong>Déclenchement sur front (Edge-triggered) :</strong> Le changement d'état ne se produit qu'à l'instant précis où l'horloge effectue une transition active (front montant : 0 -> 1, ou front descendant : 1 -> 0). On parle alors de <strong>Flip-Flop</strong>. La sortie ne change qu'au moment du front et conserve son état ensuite, indépendamment des changements sur les entrées jusqu'au prochain front actif.</li>
                 </ul>
            </section>
        </article>

        <hr>

        <!-- Page 15 Content -->
        <article>
            <section>
                 <h4>Déclenchement sur niveau (Latch)</h4>
                 <p>Exemple de bascule RS synchrone sur niveau HAUT (Gated RS Latch) :</p>
                 <div class="placeholder">[Image Placeholder: Schéma Gated RS Latch (portes AND en entrée + RS Latch NOR)]</div>
                 <p>Tant que H=1, la sortie Q suit la logique RS (Q=1 si S=1, Q=0 si R=1, mémoire si S=R=0). Quand H=0, la bascule mémorise l'état précédent, quelles que soient les valeurs de S et R.</p>

                 <h4>Déclenchement sur front (Flip-Flop)</h4>
                 <p>Les Flip-Flops sont préférables dans les systèmes synchrones complexes car ils évitent les problèmes de propagation liés aux latches. Le changement d'état est précisément synchronisé sur un front d'horloge.</p>

                 <p><strong>Génération d'une impulsion sur front :</strong></p>
                 <p>On peut transformer un signal d'horloge en une courte impulsion sur le front montant (ou descendant) en utilisant le temps de propagation d'une porte NON.</p>
                  <div class="placeholder">[Image Placeholder: Schéma détecteur de front montant (porte NON + ET/NAND)]</div>

                 <p><strong>Bascule D (Data Flip-Flop) :</strong></p>
                 <p>La bascule D est la plus simple des flip-flops synchrones. Elle a une seule entrée de donnée D et une entrée d'horloge. Au front actif de l'horloge, la sortie Q recopie la valeur présente sur l'entrée D. Elle sert à mémoriser la valeur de D au moment du front d'horloge.</p>
                 <div class="placeholder">[Image Placeholder: Schéma Bascule D (ex: à partir d'une RS avec D -> S et non(D) -> R)]</div>
                  <table>
                     <caption>Table de Vérité Bascule D (Front Montant ↑)</caption>
                      <thead><tr><th>CLK</th><th>D</th><th>Q<sub>n+1</sub></th><th>État</th></tr></thead>
                     <tbody>
                          <tr><td>↑</td><td>0</td><td>0</td><td>Reset/Mémorise 0</td></tr>
                          <tr><td>↑</td><td>1</td><td>1</td><td>Set/Mémorise 1</td></tr>
                          <tr><td>Non ↑</td><td>X</td><td>Q<sub>n</sub></td><td>Mémoire</td></tr>
                     </tbody>
                 </table>
                 <p>(X = Indifférent)</p>


                 <p><strong>Bascule JK (JK Flip-Flop) :</strong></p>
                 <p>
                    La bascule JK est plus polyvalente. Elle a deux entrées J et K, similaires à S et R, mais la condition J=1, K=1 n'est pas interdite : elle provoque le <strong>basculement</strong> (toggle) de la sortie Q (Q passe de 0 à 1 ou de 1 à 0) au front d'horloge.
                 </p>
                 <div class="placeholder">[Image Placeholder: Schéma Bascule JK]</div>
                 <table>
                    <caption>Table de Vérité Bascule JK (Front Montant ↑)</caption>
                     <thead><tr><th>CLK</th><th>J</th><th>K</th><th>Q<sub>n+1</sub></th><th>État</th></tr></thead>
                    <tbody>
                         <tr><td>↑</td><td>0</td><td>0</td><td>Q<sub>n</sub></td><td>Mémoire</td></tr>
                         <tr><td>↑</td><td>0</td><td>1</td><td>0</td><td>Reset</td></tr>
                         <tr><td>↑</td><td>1</td><td>0</td><td>1</td><td>Set</td></tr>
                         <tr><td>↑</td><td>1</td><td>1</td><td>\( \overline{Q}_n \)</td><td>Basculement (Toggle)</td></tr>
                         <tr><td>Non ↑</td><td>X</td><td>X</td><td>Q<sub>n</sub></td><td>Mémoire</td></tr>
                    </tbody>
                </table>

                 <p><strong>Bascule T (Toggle Flip-Flop) :</strong></p>
                 <p>
                    La bascule T a une seule entrée T. Si T=0, elle mémorise son état au front d'horloge. Si T=1, elle bascule (toggle) sa sortie Q au front d'horloge. Elle est souvent réalisée à partir d'une bascule JK en reliant J et K ensemble (= T).
                 </p>
                 <div class="placeholder">[Image Placeholder: Schéma Bascule T (JK avec J=K=T)]</div>
                  <table>
                    <caption>Table de Vérité Bascule T (Front Montant ↑)</caption>
                     <thead><tr><th>CLK</th><th>T</th><th>Q<sub>n+1</sub></th><th>État</th></tr></thead>
                    <tbody>
                         <tr><td>↑</td><td>0</td><td>Q<sub>n</sub></td><td>Mémoire</td></tr>
                         <tr><td>↑</td><td>1</td><td>\( \overline{Q}_n \)</td><td>Basculement (Toggle)</td></tr>
                         <tr><td>Non ↑</td><td>X</td><td>Q<sub>n</sub></td><td>Mémoire</td></tr>
                    </tbody>
                 </table>
                 <p>La bascule T est très utile pour construire des compteurs (division de fréquence par 2).</p>
            </section>
        </article>

        <hr>

        <!-- Page 16 Content -->
        <article>
            <section>
                 <h3>2. Multiplexeur / Démultiplexeur</h3>
                 <p><strong>Multiplexeur (MUX) :</strong></p>
                 <p>
                    Un multiplexeur est un commutateur électronique qui sélectionne une de ses \( 2^n \) entrées de données (I0, I1, ..., I\(_{2^n-1}\)) pour la connecter à une unique sortie Q. La sélection est effectuée par \( n \) entrées de commande (S0, S1, ..., S\(_{n-1}\)).
                 </p>
                  <div class="placeholder">[Image Placeholder: Schéma Multiplexeur 4 vers 1 (entrées I0-I3, sélection S1,S0, sortie Q)]</div>
                 <p>Exemple (MUX 4 vers 1) : Q = I0 si S1=0, S0=0; Q = I1 si S1=0, S0=1; Q = I2 si S1=1, S0=0; Q = I3 si S1=1, S0=1.</p>
                 <p>Il existe des multiplexeurs logiques (pour signaux binaires) et analogiques (pour signaux continus).</p>

                 <p><strong>Démultiplexeur (DEMUX) :</strong></p>
                 <p>
                    Un démultiplexeur réalise la fonction inverse : il connecte une unique entrée de donnée E à l'une de ses \( 2^n \) sorties (O0, O1, ..., O\(_{2^n-1}\)). La sélection de la sortie se fait par \( n \) entrées de commande (S0, S1, ..., S\(_{n-1}\)).
                 </p>
                 <div class="placeholder">[Image Placeholder: Schéma Démultiplexeur 1 vers 4]</div>
                 <p>Il est souvent utilisé pour distribuer un signal vers plusieurs destinations ou comme décodeur.</p>
            </section>

            <section>
                <h3>3. Les Compteurs</h3>
                <p>
                   Les compteurs sont des systèmes séquentiels conçus pour compter des événements (impulsions d'horloge). Ils sont constitués d'un assemblage de bascules. La <strong>dynamique</strong> (ou capacité) du compteur (nombre maximum d'états) est déterminée par le nombre de bascules \( n \) (dynamique = \( 2^n \)).
                </p>

                <h4>Compteurs asynchrones (Ripple Counters)</h4>
                <p>
                   Dans un compteur asynchrone, la sortie de la bascule \( i-1 \) sert d'horloge à la bascule \( i \). Seule la première bascule reçoit l'horloge externe. Le changement d'état se propage ("ripple") d'une bascule à l'autre.
                </p>
                <div class="placeholder">[Image Placeholder: Schéma Compteur Asynchrone 3 bits (bascules T ou JK connectées en cascade)]</div>
                 <div class="placeholder">[Image Placeholder: Chronogramme Compteur Asynchrone montrant le décalage (skew)]</div>
                 <p>
                   Avantage : Simplicité de conception.
                   Inconvénient : Temps de propagation cumulatif. Le temps total pour que toutes les bascules atteignent leur état final après un coup d'horloge peut être long, limitant la fréquence maximale de comptage. De plus, des états transitoires erronés (aléas de décodage) peuvent apparaître pendant la propagation du changement. Cette solution est réservée aux comptages lents ou à la division de fréquence simple.
                 </p>

                <h4>Compteurs synchrones</h4>
                <p>
                   Dans un compteur synchrone, toutes les bascules reçoivent le même signal d'horloge externe simultanément. Des portes logiques combinatoires sont ajoutées pour déterminer, avant le front d'horloge, quelles bascules doivent basculer.
                </p>
                 <div class="placeholder">[Image Placeholder: Schéma Compteur Synchrone 3 bits (bascules JK/T avec logique combinatoire sur les entrées J/K/T)]</div>
                <p>
                   Avantage : Toutes les sorties changent d'état (presque) en même temps, synchronisées sur l'horloge. Cela élimine les aléas de décodage et permet des fréquences de fonctionnement beaucoup plus élevées.
                   Inconvénient : Conception plus complexe (logique combinatoire additionnelle).
                </p>

                <h4>Compteurs intégrés</h4>
                <p>Il existe une grande variété de compteurs disponibles en circuits intégrés (CI), offrant diverses fonctionnalités :</p>
                <ul>
                   <li>Technologie TTL ou CMOS.</li>
                   <li>Synchrone ou asynchrone.</li>
                   <li>Compteur simple ou réversible (compteur/décompteur, up/down counter).</li>
                   <li>Prépositionnable (Loadable) : On peut charger une valeur initiale dans le compteur.</li>
                   <li>Diviseur de fréquence.</li>
                   <li>Binaire naturel ou BCD (Binary Coded Decimal - compte de 0 à 9 par décade).</li>
                   <li>Sorties de retenue (Carry Out / Ripple Carry Out - RCO) pour faciliter la mise en cascade.</li>
                </ul>
           </section>
        </article>

        <hr>

        <!-- Page 17 Content -->
        <article>
            <section>
                <h4>Codage BCD et Binaire Naturel</h4>
                <p>Comparaison du codage BCD (Décimal Codé Binaire) et Binaire naturel pour les nombres décimaux.</p>
                <table>
                    <caption>Codage BCD vs Binaire</caption>
                     <thead>
                         <tr><th rowspan="2">Décimal</th><th colspan="4">BCD (8421)</th><th colspan="5">Binaire Naturel</th></tr>
                         <tr><th>D1 (x10) U3</th><th>U2</th><th>U1</th><th>U0 (x1)</th><th>B4</th><th>B3</th><th>B2</th><th>B1</th><th>B0</th></tr>
                     </thead>
                     <tbody>
                        <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                        <tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr>
                        <tr><td>9</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                        <tr><td>10</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                        <tr><td>11</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
                        <tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr>
                        <tr><td>15</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                        <tr><td>16</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                        <tr><td>17</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
                        <tr><td>18</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
                     </tbody>
                 </table>
                 <p>Le BCD utilise 4 bits pour coder chaque chiffre décimal (0-9). Les combinaisons de 1010 à 1111 sont invalides dans un quartet BCD.</p>

                <h4>Présentation du Compteur Intégré 74xx191</h4>
                <p>Le 74xx191 est un exemple de compteur/décompteur synchrone 4 bits, binaire naturel, prépositionnable de manière asynchrone.</p>
                 <div class="placeholder">[Image Placeholder: Brochage (Pinout) du CI 74xx191]</div>
                 <p><strong>Fonction des broches principales :</strong></p>
                 <dl>
                    <dt>A, B, C, D (entrées)</dt><dd>Entrées pour le prépositionnement parallèle (chargement de données).</dd>
                    <dt>QA, QB, QC, QD (sorties)</dt><dd>Sorties 4 bits du compteur.</dd>
                    <dt>CLK (entrée)</dt><dd>Horloge (Clock), active sur front montant (↑).</dd>
                    <dt>\(\overline{LOAD}\) (entrée)</dt><dd>Entrée de chargement (Load), active à l'état BAS. Asynchrone : quand \(\overline{LOAD}\)=0, les sorties QA-QD recopient immédiatement les entrées A-D.</dd>
                    <dt>\(\overline{G}\) ou \(\overline{CE}\) (entrée)</dt><dd>Validation du comptage (Chip Enable ou Gate), active à l'état BAS. Si \(\overline{G}\)=1, le comptage est inhibé.</dd>
                    <dt>D/\(\overline{U}\) ou U/\(\overline{D}\) (entrée)</dt><dd>Sélection du sens de comptage : HAUT (Up, ex: niveau BAS) ou BAS (Down, ex: niveau HAUT). (Vérifier la datasheet pour la polarité exacte).</dd>
                    <dt>RCO ou \(\overline{RCO}\) (sortie)</dt><dd>Sortie de retenue (Ripple Carry Out). Active (ex: BAS) quand le compteur atteint sa valeur maximale (1111) en comptage, ou sa valeur minimale (0000) en décomptage. Utilisée pour la mise en cascade.</dd>
                    <dt>MAX/MIN (sortie)</dt><dd>Indique si le compteur est à sa valeur maximale (1111) ou minimale (0000). Souvent utilisée pour les cascades rapides.</dd>
                 </dl>
                 <p>Pour compter, il faut que \(\overline{LOAD}=1\) et \(\overline{G}=0\). Le comptage s'effectue sur chaque front montant de CLK.</p>

                <h4>Mise en cascade de compteurs</h4>
                <p>
                   Pour réaliser un compteur avec une capacité supérieure à celle d'un seul CI (ex: 8 bits, 12 bits, 16 bits...), on met en cascade plusieurs compteurs. Le compteur des bits de poids faible génère une retenue (via RCO) qui sert à valider ou à déclencher le comptage du compteur des bits de poids fort.
                </p>
            </section>
        </article>

        <hr>

        <!-- Page 18 Content -->
        <article>
            <section>
                 <h4>Association Asynchrone (Ripple Cascade)</h4>
                 <p>
                    Dans la mise en cascade asynchrone, la sortie de retenue (RCO) du compteur de poids faible est utilisée comme signal d'horloge (ou de validation d'horloge) pour le compteur de poids fort.
                 </p>
                  <div class="placeholder">[Image Placeholder: Schéma Cascade Asynchrone de 2 compteurs 74191 (RCO du 1er -> CLK ou G du 2nd)]</div>
                  <p>
                    Inconvénient : Comme pour les compteurs asynchrones, un délai de propagation s'accumule à travers la chaîne de compteurs. L'état global du compteur n'est stable qu'après la propagation de la retenue à travers tous les étages.
                  </p>

                 <h4>Association Synchrone</h4>
                 <p>
                    Dans la mise en cascade synchrone, toutes les horloges (CLK) des compteurs sont connectées ensemble au signal d'horloge principal. La sortie de retenue (RCO) du compteur de poids faible est utilisée pour valider (\(\overline{G}\)) le comptage du compteur de poids fort uniquement lorsque le compteur de poids faible est sur le point de passer de sa valeur max à 0 (en comptage) ou de min à max (en décomptage).
                 </p>
                 <div class="placeholder">[Image Placeholder: Schéma Cascade Synchrone de 2 compteurs 74191 (CLK commun, RCO du 1er -> G du 2nd)]</div>
                 <p>
                    Avantage : Toutes les sorties du compteur global changent de manière synchrone avec l'horloge, permettant un fonctionnement plus rapide et sans aléas de décodage liés à la cascade. C'est la méthode préférée pour les compteurs rapides. La sortie MAX/MIN peut être utilisée à la place de RCO pour des cascades encore plus rapides en anticipant la retenue.
                 </p>
            </section>

            <section>
                <h3>4. Les Convertisseurs</h3>
                <p>Les convertisseurs permettent de faire le lien entre le monde analogique (continu) et le monde numérique (discret).</p>

                <h4>Convertisseurs Numérique-Analogique (CNA / DAC)</h4>
                <p>
                    Ils convertissent un mot numérique (code binaire) de \( n \) bits en une grandeur analogique (tension ou courant) proportionnelle à la valeur numérique du mot.
                </p>
                 <p>La tension de sortie \( U_s \) est généralement comprise entre 0V et une tension de pleine échelle \( U_{pe} \) (Full Scale Voltage), ou parfois bipolaire (-Upe à +Upe).</p>
                 <p>La relation idéale est : \[ U_s = \frac{\text{Mot}}{\text{Mot}_{\text{pleine échelle}}} \times U_{pe} \]</p>
                 <p>Où \(\text{Mot}\) est la valeur décimale du mot numérique d'entrée (entre 0 et \( 2^n - 1 \)), et \(\text{Mot}_{\text{pleine échelle}}\) est la valeur maximale possible (\( 2^n - 1 \) ou parfois \( 2^n \) selon la définition).</p>
                 <p>La sortie évolue par paliers. Le plus petit changement possible en sortie correspond au changement du bit de poids le moins significatif (LSB - Least Significant Bit) en entrée.</p>
                 <p>La valeur (poids) du LSB en tension est : \[ \text{LSB (tension)} = \frac{U_{pe}}{\text{Mot}_{\text{pleine échelle}}} \approx \frac{U_{pe}}{2^n - 1} \text{ ou } \frac{U_{pe}}{2^n} \]</p>

                <p><strong>Paramètres technologiques des DAC :</strong></p>
                <dl>
                   <dt>Résolution</dt><dd>Caractérise la finesse de la conversion, exprimée en nombre de bits (n). Plus n est grand, plus les paliers de sortie sont petits.</dd>
                   <dt>Précision</dt><dd>Écart maximal (souvent en % de Upe ou en fraction de LSB) entre la valeur de sortie réelle et la valeur théorique idéale. Elle est limitée par la linéarité, le gain, l'offset...</dd>
                   <dt>Temps d'établissement (Settling Time)</dt><dd>Temps nécessaire pour que la sortie atteigne et se stabilise à sa valeur finale (à ± 1/2 LSB près, par exemple) après un changement du mot numérique d'entrée.</dd>
                   <dt>Linéarité (Intégrale et Différentielle)</dt><dd>Mesure de la rectitude de la caractéristique de transfert (INL) et de la régularité des pas de sortie (DNL).</dd>
                </dl>
            </section>
        </article>

        <hr>

        <!-- Page 19 Content -->
        <article>
             <section>
                <h4>Convertisseurs Analogique-Numérique (CAN / ADC)</h4>
                 <p>
                    Ils convertissent une grandeur analogique (tension ou courant) \( U_e \) en un mot numérique de \( n \) bits qui représente la valeur la plus proche de cette tension d'entrée.
                 </p>
                 <p>La tension d'entrée \( U_e \) doit être comprise entre 0V et une tension de pleine échelle \( U_{pe} \) (ou une plage définie).</p>
                 <p>Le mot numérique de sortie \( \text{Mot} \) est idéalement : \[ \text{Mot} = \text{Partie entière de} \left( \frac{U_e}{U_{pe}} \times (2^n - 1) \right) \text{ ou } \left( \frac{U_e}{U_{pe}} \times 2^n \right) \]</p>
                 <p>La conversion introduit une erreur de quantification inhérente (l'arrondi à la valeur numérique la plus proche).</p>

                 <p><strong>Paramètres technologiques des ADC :</strong></p>
                <dl>
                   <dt>Résolution</dt><dd>Nombre de bits (n) du mot numérique de sortie.</dd>
                   <dt>Valeur du LSB</dt><dd>Poids du bit le moins significatif, représente la plus petite variation de tension d'entrée qui peut être détectée. \( \text{LSB} \approx U_{pe} / 2^n \).</dd>
                   <dt>Précision</dt><dd>Écart maximal entre la valeur numérique réelle et la valeur théorique (souvent en % ou en LSB). Inclut les erreurs de gain, d'offset, de linéarité.</dd>
                   <dt>Temps de conversion (Conversion Time)</dt><dd>Temps nécessaire pour que le convertisseur fournisse la valeur numérique correspondant au signal d'entrée. Pendant cette phase, la tension d'entrée doit idéalement être maintenue constante (utilisation fréquente d'un échantillonneur-bloqueur - Sample and Hold - en amont).</dd>
                    <dt>Erreur de quantification</dt><dd>Erreur inhérente due à la discrétisation, typiquement ± 1/2 LSB.</dd>
                   <dt>Linéarité (INL, DNL)</dt><dd>Similaire au DAC, mesure la régularité de la conversion.</dd>
                </dl>

                <p><strong>Technologies d'ADC (classées par rapidité croissante et complexité/coût croissant) :</strong></p>
                 <ul>
                    <li><strong>Convertisseur à rampe (simple ou double) :</strong> Simple mais lent. Compare la tension d'entrée à une rampe de tension générée localement et mesure le temps écoulé. La double rampe offre une meilleure immunité au bruit. (Utilisé pour voltmètres numériques lents).</li>
                    <li><strong>Convertisseur à approximations successives (SAR - Successive Approximation Register) :</strong> Très répandu, bon compromis vitesse/résolution/coût. Détermine les bits du plus significatif au moins significatif par dichotomie en utilisant un DAC interne et un comparateur.</li>
                    <li><strong>Convertisseur Semi-Flash (Subranging / Pipeline) :</strong> Plus rapide que SAR. Utilise plusieurs étages de convertisseurs de résolution plus faible.</li>
                    <li><strong>Convertisseur Flash (Parallel) :</strong> Le plus rapide. Utilise \( 2^n - 1 \) comparateurs en parallèle pour comparer l'entrée à toutes les tensions de référence possibles simultanément. Coûteux et gourmand en énergie, surtout pour les hautes résolutions.</li>
                 </ul>
            </section>
        </article>

        <hr>

        <!-- Page 20 Content -->
        <article>
            <section>
                <h3>5. Les mémoires</h3>
                 <p>
                    Les systèmes numériques se distinguent par leur capacité à mémoriser, traiter et restituer des informations. Les mémoires sont des composants essentiels pour stocker ces informations (données, programmes).
                 </p>
                 <p>Il existe deux grandes familles :</p>
                 <ul>
                    <li><strong>Mémoires vives (RAM - Random Access Memory) :</strong> Peuvent être lues ET écrites pendant le fonctionnement normal. Elles perdent leur contenu lors de la coupure d'alimentation (volatiles). Ex: SRAM (statique, rapide, chère), DRAM (dynamique, moins chère, plus dense, nécessite rafraîchissement).</li>
                    <li><strong>Mémoires mortes (ROM - Read Only Memory) :</strong> Ne peuvent être que lues en fonctionnement normal. Elles conservent leur contenu hors tension (non-volatiles). Utilisées pour stocker des programmes ou des données fixes (firmware, BIOS...).</li>
                 </ul>

                <h4>Organisation d'une mémoire</h4>
                <p>
                   Une mémoire est organisée comme une association de plusieurs <strong>registres</strong> (ou cases mémoire), chacun capable de stocker un mot de Y bits (ex: 1 bit, 8 bits=octet, 16 bits...). Il y a X registres au total. La capacité totale est X x Y bits.
                </p>
                 <p>Pour accéder à un registre spécifique :</p>
                 <ul>
                    <li><strong>Bus d'adresse (Address Bus) :</strong> Ensemble de N fils (A0, A1, ..., A\(_{N-1}\)) qui sélectionnent l'adresse du registre à lire ou écrire. Avec N fils, on peut adresser \( 2^N \) registres (X = \( 2^N \)).</li>
                    <li><strong>Bus de données (Data Bus) :</strong> Ensemble de Y fils (D0, D1, ..., D\(_{Y-1}\)) par lesquels transitent les données lues depuis ou écrites vers le registre sélectionné.</li>
                    <li><strong>Signaux de contrôle :</strong>
                        <ul>
                           <li><strong>CS (Chip Select) ou CE (Chip Enable) :</strong> Sélectionne/active le circuit mémoire. Souvent actif à l'état BAS (\(\overline{CS}\)).</li>
                           <li><strong>L/\(\overline{E}\) (Lecture/Écriture) ou R/\(\overline{W}\) (Read/Write) :</strong> Indique si l'opération demandée est une lecture (ex: niveau HAUT) ou une écriture (ex: niveau BAS). Pour les ROM, cette broche peut être absente ou remplacée par OE (Output Enable).</li>
                           <li><strong>OE (Output Enable) :</strong> Active les sorties du bus de données lors d'une lecture. Souvent actif à l'état BAS (\(\overline{OE}\)).</li>
                        </ul>
                    </li>
                 </ul>
                  <div class="placeholder">[Image Placeholder: Schéma Blocs d'une Mémoire (Décodeur d'adresse, Matrice mémoire, Buffers de données, Contrôle)]</div>

                <h4>Types de Mémoires Mortes (ROM) et Programmables</h4>
                <ul>
                   <li><strong>ROM (Mask ROM) :</strong> Programmée en usine lors de la fabrication. Pour très grandes séries, non modifiable.</li>
                   <li><strong>PROM (Programmable ROM) :</strong> Programmable une seule fois par l'utilisateur (avec un programmateur spécial qui "grille" des fusibles internes).</li>
                   <li><strong>EPROM (Erasable PROM) :</strong> Programmable par l'utilisateur et effaçable par exposition à des rayons ultraviolets (via une fenêtre sur le boîtier). Réutilisable.</li>
                   <li><strong>EEPROM (Electrically Erasable PROM) ou E²PROM :</strong> Programmable et effaçable électriquement, directement dans le système. Peut être réécrite un grand nombre de fois (mais limité). Plus lente en écriture que la RAM.</li>
                   <li><strong>Mémoire Flash :</strong> Variante d'EEPROM, effaçable par blocs (et non octet par octet), plus dense et moins chère. Très utilisée (clés USB, SSD, cartes mémoire, microcontrôleurs).</li>
                </ul>

                <h4>Logique Programmable</h4>
                <p>
                   Des structures plus complexes permettent de réaliser des fonctions logiques (combinatoires et séquentielles) définies par l'utilisateur :
                </p>
                <ul>
                   <li><strong>PLD (Programmable Logic Device) :</strong> Terme générique. Inclut PAL (Programmable Array Logic), GAL (Generic Array Logic)... Structures à base de matrices ET/OU programmables.</li>
                   <li><strong>CPLD (Complex PLD) :</strong> Assemblage de plusieurs blocs logiques type PLD sur une même puce.</li>
                   <li><strong>FPGA (Field-Programmable Gate Array) :</strong> Architecture très flexible basée sur des blocs logiques configurables (LUT - Look-Up Tables, bascules) et un réseau d'interconnexions programmable. Permet de réaliser des systèmes numériques très complexes et rapides.</li>
                 </ul>
            </section>
        </article>

    </main>

    <footer>
        <hr>
        <p style="text-align: center; font-size: 0.8em;">Fin du document HTML généré (Pages 1-20).</p>
    </footer>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '\\[', right: '\\]', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false}
                ]
            });
        });
    </script>
</body>
</html>
