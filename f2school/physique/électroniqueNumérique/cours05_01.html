<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cours d'électronique numérique - UPMC Hiver 2007</title>
    <!-- Inclure KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <!-- Inclure KaTeX JS -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            padding: 10px;
            background-color: #f8f9fa;
        }
        .slide {
            background-color: #ffffff;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .slide-title {
            font-size: 1.8em;
            color: #003399; /* Dark blue */
            border-bottom: 2px solid #003399;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        h1 {
            text-align: center;
            color: #003399;
        }
        h2 {
             font-size: 1.5em;
             color: #004080; /* Medium blue */
             margin-top: 30px;
        }
        ul {
            list-style-type: square;
            margin-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        .contact-info, .affiliation {
            margin-bottom: 10px;
        }
        .important-note {
            font-weight: bold;
            color: #dc3545; /* Red */
            font-size: 1.2em;
        }
        .formula {
            font-family: monospace;
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
        }
        img.placeholder {
            max-width: 80%;
            height: auto;
            display: block;
            margin: 15px auto;
            border: 1px dashed #ccc;
            padding: 10px;
            text-align: center;
            color: #666;
            background-color: #f0f0f0;
        }
        .logo {
             display: block;
             margin: 20px auto;
             max-width: 200px;
             height: auto;
        }
        .header-small {
             font-size: 0.8em;
             color: #6c757d;
             text-align: left;
             position: absolute;
             top: 5px;
             left: 10px;
        }
         .footer-date {
             margin-top: 20px;
             font-size: 1.1em;
             text-align: center;
        }
         .instructors {
             text-align: center;
             margin: 20px 0;
        }
         .instructor-name {
             font-size: 1.2em;
             font-weight: bold;
         }
         .instructor-title {
              font-style: italic;
              color: #555;
         }
         .affiliation {
              margin-top: 20px;
              text-align: center;
         }
         .contact-info {
              margin-top: 5px;
              text-align: center;
         }
    </style>
</head>
<body>

    <!-- Page 1: Title Slide -->
    <div class="slide" id="page1">
        <div class="header-small">Cours d'électronique numérique</div>
        <h1 class="slide-title">Cours d'électronique numérique</h1>

        <div class="instructors">
            <p><span class="instructor-name">Aurélie Gensbittel</span><br>
            <span class="instructor-title">Enseignante-Chercheuse</span></p>
            <p><span class="instructor-name">Bertrand Granado</span><br>
            <span class="instructor-title">Enseignant-Chercheur</span></p>
        </div>

        <div class="affiliation">
            Université Pierre et Marie Curie (UPMC)
        </div>
        <div class="contact-info">
            Mel : Aurelie.Gensbittel@upmc.fr<br>
            Mel : Bertrand.Granado@upmc.fr
        </div>

        <div class="footer-date">
            Hiver 2007
        </div>

        <img src="placeholder_logo_upmc.png" alt="Logo Université Pierre & Marie Curie - La Science à Paris" class="placeholder logo">
        <p style="text-align:center; color: #666;">[Placeholder for UPMC Logo]</p>

    </div>

    <!-- Page 2: Course Outline -->
    <div class="slide" id="page2">
        <div class="header-small">Cours d'électronique numérique</div>
        <h2 class="slide-title">Plan du Cours</h2>
        <p>Ce cours couvrira les sujets suivants :</p>
        <ul>
            <li>Introduction</li>
            <li>Algèbre de Boole et Codage</li>
            <li>Introduction au VHDL (VHSIC Hardware Description Language)</li>
            <li>Fonctions Combinatoires Simples</li>
            <li>Fonctions Combinatoires Complexes</li>
            <li>Fonctions Séquentielles Simples</li>
            <li>Fonctions Séquentielles Complexes</li>
            <li>Pipeline</li>
            <li>Technologie des circuits numériques</li>
            <li>Les Convertisseurs Analogiques-Numériques (CAN / ADC) et Numériques-Analogiques (CNA / DAC)</li>
        </ul>
    </div>

    <!-- Page 3: Instructors for UE201 -->
    <div class="slide" id="page3">
        <div class="header-small">Cours d'électronique numérique</div>
        <h2 class="slide-title">Les enseignants de l'UE201 ...</h2>
        <p>La répartition des enseignements pour l'Unité d'Enseignement UE201 est la suivante :</p>
        <ul>
            <li><strong>Cours Magistral (CM) :</strong> A. Gensbittel</li>
            <li><strong>Travaux Dirigés (TD) :</strong> P. Ravary - H. Kokabi</li>
            <li><strong>Travaux Pratiques (TP) :</strong> P. Ravary - H. Kokabi</li>
        </ul>
    </div>

    <!-- Page 4: Assessment Methods -->
    <div class="slide" id="page4">
         <div class="header-small">Cours d'électronique numérique</div>
        <h2 class="slide-title">Evaluation des connaissances ...</h2>
        <p>L'évaluation de vos connaissances se fera via plusieurs composantes :</p>
        <ul>
            <li><strong>Le Contrôle Continu (CC) :</strong> Sera sous forme de Questionnaire à Choix Multiples (QCM) et/ou de Questions de Cours.</li>
            <li><strong>L'examen Final (Ex) :</strong> Évaluera votre capacité de réflexion. <br><em>(Note : Les TD sont conçus pour la compréhension et la pratique, pas uniquement pour préparer l'examen final - "ne servent pas à Bachoter !")</em></li>
            <li><strong>Le Mini-Projet :</strong> Un projet pratique pour appliquer les concepts appris (détails sur la page suivante).</li>
        </ul>
    </div>

    <!-- Page 5: Assessment - Mini-Project Details -->
    <div class="slide" id="page5">
        <div class="header-small">Cours d'électronique numérique</div>
        <h2 class="slide-title">Evaluation des connaissances: Le Mini-Projet</h2>
        <p>L'évaluation du Mini-Projet comprendra :</p>
        <ul>
            <li><strong>Rapport Final :</strong> À soumettre à la fin de toutes les séances de Travaux Pratiques (TP).</li>
            <li><strong>Évaluation durant le TP :</strong> Observation et évaluation de votre travail pendant les séances de laboratoire.</li>
            <li><strong>Soutenance de Mini-Projet :</strong> Une présentation orale de votre projet et de ses résultats.</li>
        </ul>
         <p>La note obtenue pour le Mini-Projet sera désignée par <strong>TP</strong> dans la formule de la note finale.</p>
    </div>

    <!-- Page 6: Assessment - Coefficients -->
    <div class="slide" id="page6">
         <div class="header-small">Cours d'électronique numérique</div>
        <h2 class="slide-title">Evaluation des connaissances : Coefficients</h2>
        <p>Les notes des différentes évaluations sont combinées pour obtenir la note finale selon les formules suivantes :</p>

        <p><strong>Note de l'écrit (E) :</strong></p>
        <p>La note de l'écrit, E, est calculée comme le maximum entre l'examen final seul et une moyenne pondérée du contrôle continu et de l'examen final.</p>
        <div class="formula">
            E = max( (0.2 * CC + 0.8 * Ex), Ex )
        </div>
        <p>Où :</p>
        <ul>
            <li><strong>CC</strong> est la note du Contrôle Continu.</li>
            <li><strong>Ex</strong> est la note de l'Examen final.</li>
        </ul>
        <p><em>Note : La notation `sup(a, b)` signifie le suprémum (maximum) de a et b. La virgule est utilisée comme séparateur décimal dans la notation originale.</em></p>


        <p><strong>Note Finale (F) :</strong></p>
        <p>La note finale du module, F, est une moyenne pondérée de la note écrite (E), de la note des travaux pratiques (TP issue du Mini-Projet), et de la note du contrôle continu (CC).</p>
         <div class="formula">
            F = 0.65 * E + 0.25 * TP + 0.1 * CC
        </div>
         <p>Où :</p>
         <ul>
             <li><strong>E</strong> est la note de l'écrit calculée ci-dessus.</li>
             <li><strong>TP</strong> est la note globale des Travaux Pratiques (Mini-Projet).</li>
             <li><strong>CC</strong> est la note du Contrôle Continu.</li>
         </ul>
         <p><em>Note : Les coefficients indiquent l'importance relative de chaque composante dans la note finale (Écrit: 65%, TP: 25%, CC: 10%).</em></p>
    </div>

    <!-- Page 7: TD Handout Information -->
    <div class="slide" id="page7">
         <div class="header-small">Cours d'électronique numérique</div>
        <h2 class="slide-title">Polycopié de TD</h2>
        <p>Informations concernant le polycopié (fascicule d'exercices) pour les Travaux Dirigés (TD) :</p>
        <ul>
            <li><strong>Disponibilité :</strong> Disponible à la reprographie cette semaine.</li>
            <li><strong>Lieu :</strong> 2ème étage - bâtiment Esclangon.</li>
            <li><strong>Horaires de la reprographie :</strong> 12h45 - 14h15, les Mardi, Mercredi et Vendredi.</li>
        </ul>
        <p class="important-note">A avoir avant le TD !</p>
        <p>Il est essentiel de récupérer ce document avant votre première séance de TD pour pouvoir suivre et participer activement.</p>
    </div>

    <!-- Historical Introduction Section -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Introduction Historique</h2>

    <!-- Page 8: History - Chinese Abacus -->
    <div class="slide" id="page8">
         <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Un peu d'histoire ... Le boulier chinois</h2>
        <p>Les systèmes numériques et les calculs ont une longue histoire. L'un des premiers outils de calcul mécanique est le boulier, utilisé depuis des millénaires dans diverses cultures.</p>
        <img src="placeholder_boulier_chinois.jpg" alt="Photographie d'un boulier chinois traditionnel" class="placeholder">
        <p style="text-align:center; color: #666;">[Placeholder for Chinese Abacus Image]</p>
        <p>Le boulier chinois (Suanpan) permettait d'effectuer des opérations arithmétiques de base (addition, soustraction, multiplication, division) et même des opérations plus complexes comme l'extraction de racines carrées et cubiques.</p>
    </div>

    <!-- Page 9: History - Babbage Engine -->
    <div class="slide" id="page9">
        <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Un peu d'histoire ... La machine de Babbage</h2>
        <p>Au 19ème siècle, Charles Babbage a conçu des machines à calculer mécaniques considérées comme les précurseurs des ordinateurs modernes.</p>
        <img src="placeholder_babbage_machine.jpg" alt="Photographie d'une partie de la machine à différences de Babbage" class="placeholder">
         <p style="text-align:center; color: #666;">[Placeholder for Babbage Machine Image]</p>
        <p>Ses conceptions, comme la Machine Analytique, introduisaient des concepts fondamentaux tels que l'unité de calcul (le "moulin"), la mémoire (le "magasin"), et l'utilisation de cartes perforées pour la programmation, inspirées du métier à tisser Jacquard.</p>
    </div>

    <!-- Page 10: History - Triode Tube -->
    <div class="slide" id="page10">
        <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Un peu d'histoire ... Une Lampe Triode</h2>
        <p>Le développement de l'électronique a été une étape clé. Au début du 20ème siècle, l'invention de la lampe à vide (ou tube électronique), comme la triode, a permis de créer les premiers circuits électroniques capables d'amplifier des signaux et d'agir comme des interrupteurs.</p>
        <img src="placeholder_lampe_triode.jpg" alt="Photographie d'une lampe triode (tube à vide), modèle ECC83" class="placeholder">
        <p style="text-align:center; color: #666;">[Placeholder for Triode Tube Image (ECC83)]</p>
        <p>Ces composants ont été essentiels pour la construction des premiers ordinateurs électroniques (comme l'ENIAC), bien qu'ils étaient volumineux, consommaient beaucoup d'énergie et avaient une fiabilité limitée comparée aux technologies suivantes (transistors, circuits intégrés).</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 11: History - Transistor -->
    <div class="slide" id="page11">
         <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Un peu d'histoire ... Le transistor de 1947</h2>
        <p>La révolution suivante en électronique fut l'invention du transistor aux Bell Labs en 1947 par John Bardeen, Walter Brattain et William Shockley (Prix Nobel de physique 1956).</p>
        <img src="placeholder_transistor_1947.jpg" alt="Photographie du premier transistor à pointe de contact (1947)" class="placeholder">
        <p style="text-align:center; color: #666;">[Placeholder for 1947 Transistor Image]</p>
        <p>Le transistor, basé sur les propriétés des semi-conducteurs, remplit les mêmes fonctions que les tubes à vide (amplification, commutation) mais est beaucoup plus petit, plus fiable, consomme moins d'énergie et peut être fabriqué en masse. Il a ouvert la voie à la miniaturisation.</p>
    </div>

    <!-- Page 12: History - Intel 4004 (Chip Package) -->
    <div class="slide" id="page12">
         <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Un peu d'histoire ... Le 4004 d'Intel</h2>
        <p>L'étape suivante fut l'intégration de multiples transistors sur une seule puce de silicium, menant aux circuits intégrés (CI). En 1971, Intel a commercialisé le 4004, considéré comme le premier microprocesseur commercial.</p>
        <img src="placeholder_intel_4004_package.jpg" alt="Photographie du microprocesseur Intel 4004 dans son boîtier céramique" class="placeholder">
         <p style="text-align:center; color: #666;">[Placeholder for Intel 4004 Package Image]</p>
         <p>Cette puce unique contenait toute l'unité centrale de traitement (CPU) d'un ordinateur simple. Elle intégrait 2300 transistors.</p>
    </div>

    <!-- Page 13: History - Intel 4004 (Die Shot) -->
    <div class="slide" id="page13">
        <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Un peu d'histoire ... Le 4004 d'Intel</h2>
        <p>Vue microscopique de la puce (die) du microprocesseur Intel 4004, montrant la complexité des circuits intégrés dès 1971.</p>
        <img src="placeholder_intel_4004_die.jpg" alt="Microphotographie de la puce (die) du microprocesseur Intel 4004" class="placeholder">
        <p style="text-align:center; color: #666;">[Placeholder for Intel 4004 Die Shot Image]</p>
        <p>L'intégration n'a cessé de croître depuis (Loi de Moore), permettant la création d'ordinateurs personnels, de smartphones et de tous les appareils numériques modernes.</p>
        <!-- Note: OCR captured "ointed 71". This likely refers to "Intel '71" printed on the die -->
        <p style="text-align:center; font-size: 0.9em; color: #777;">(La puce porte l'inscription © Intel 1971)</p>
    </div>

    <!-- Page 14: Today's Digital World -->
    <div class="slide" id="page14">
        <div class="header-small">Cours d'électronique numérique - Introduction</div>
        <h2 class="slide-title">Aujourd'hui : Un Monde Numérique ?</h2>
        <p>Quelques réflexions sur la nature du numérique :</p>
        <ul>
            <li><strong>Le monde numérique est un monde discrétisé :</strong> Il fonctionne avec des valeurs distinctes (souvent 0 et 1), pas avec une infinité de valeurs possibles.</li>
            <li><strong>Le monde réel est un monde continu :</strong> Les grandeurs physiques (température, son, lumière) varient de manière continue.</li>
            <li><strong>Le monde (réel) n'est pas numérique :</strong> Il faut donc convertir les signaux continus en signaux numériques pour les traiter.</li>
            <li><strong>Alors pourquoi l'électronique numérique ?</strong> Malgré cette différence, le numérique offre des avantages majeurs :</li>
            <ul>
                <li>La <strong>discrétisation permet de se prémunir du bruit :</strong> De petites fluctuations dans un signal analogique peuvent être interprétées comme du bruit, alors qu'en numérique, un signal est clairement interprété comme 0 ou 1, même avec de légères variations.</li>
                <li>Il est possible de <strong>quantifier les erreurs :</strong> Les erreurs dues à la conversion ou au traitement peuvent être analysées et contrôlées (par exemple, avec des codes correcteurs d'erreurs).</li>
                <li>Possibilité de mise en œuvre d'une <strong>arithmétique basée sur la logique :</strong> Les opérations complexes peuvent être construites à partir d'opérations logiques simples (ET, OU, NON), ce qui est la base des ordinateurs.</li>
            </ul>
        </ul>
    </div>

    <!-- Section Transition: Boolean Algebra -->
     <h2 style="text-align:center; margin-top: 40px; color: #003399;">Algèbre de Boole</h2>

    <!-- Page 15: Course Plan - Boolean Algebra Highlighted -->
    <div class="slide" id="page15">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Plan du Cours</h2>
         <p>Nous abordons maintenant la section suivante du cours :</p>
        <ul>
            <li>Introduction</li>
            <li><strong style="color: #dc3545;">Algèbre de Boole et Logique Combinatoire</strong></li>
            <li>Introduction au VHDL</li>
            <li>Fonctions Combinatoires Simples</li>
            <li>Fonctions Combinatoires Complexes</li>
            <li>Fonctions Séquentielles Simples</li>
            <li>Fonctions Séquentielles Complexes</li>
            <li>Pipeline</li>
            <li>Technologie des circuits numériques</li>
            <li>Les Convertisseurs Analogiques-Numériques et Numériques-Analogiques</li>
        </ul>
    </div>

    <!-- Page 16: References -->
    <div class="slide" id="page16">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Références</h2>
        <p>Quelques ouvrages de référence pour cette partie et l'ensemble du cours :</p>
        <ul>
            <li><strong>Architecture des Ordinateurs</strong> - Philippe Darche - Vuibert, Collection Passeport pour l'informatique
                <br>(Référence bibliothèque probable : <span style="color: #dc3545;">77.8 DAR - MIE</span>)
            </li>
            <li><strong>Circuits Numériques</strong> - Ronald J. Tocci - Dunod
                 <br>(Référence bibliothèque probable : <span style="color: #dc3545;">PE</span> - Peut-être une section ou cote spécifique manquante)
            </li>
        </ul>
        <p><em>Note : Les indications en rouge (77.8 DAR - MIE, PE) sont probablement des cotes de classement en bibliothèque (par exemple, MIE pour Médecine Informatique Électronique?, PE pour Physique Électronique?).</em></p>
    </div>

    <!-- Page 17: Boolean Algebra Title -->
    <div class="slide" id="page17">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Algèbre de Boole</h2>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Algèbre de Boole
        </div>
    </div>

    <!-- Page 18: George Boole -->
    <div class="slide" id="page18">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Mister G. Boole</h2>
        <ul>
            <li>Mathématicien Anglais du 19<sup>ième</sup> siècle.</li>
        </ul>
        <img src="placeholder_george_boole.jpg" alt="Portrait de George Boole" class="placeholder" style="max-width: 300px;">
        <p style="text-align:center; color: #666;">[Placeholder for George Boole Portrait]</p>
        <p style="text-align:center; font-size: 1.2em;">1815 – 1864</p>
        <p>George Boole est le fondateur de la logique mathématique moderne, qui porte son nom : l'algèbre de Boole.</p>
    </div>

    <!-- Page 19: Genesis of Boolean Algebra -->
    <div class="slide" id="page19">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">La génèse</h2>
        <ul>
            <li>Georges Boole introduit un formalisme mathématique de la logique dans son ouvrage :
                <br><em>The Calculus of Logic</em>
                <br>Publié dans le <em>Cambridge and Dublin Mathematical Journal</em>
                <br>Vol. III (1848), pp. 183–189.
            </li>
             <li>Il y écrit (point 3) :
                 <blockquote style="font-style: italic; margin-left: 20px; border-left: 3px solid #ccc; padding-left: 10px;">
                     That those laws [of logic] are capable of mathematical expression, and that they thus constitute the basis of an interpretable calculus.
                 </blockquote>
                 (Traduction approximative : Que ces lois [de la logique] sont capables d'expression mathématique, et qu'elles constituent ainsi la base d'un calcul interprétable.)
             </li>
            <li>Au départ, ses travaux furent beaucoup utilisés dans les "jeux de salons" (énigmes logiques).</li>
            <li>Mais à l'arrivée : Véritable révolution qui est devenue le fondement de l'électronique numérique (via les travaux de Claude Shannon au 20e siècle qui a fait le lien entre l'algèbre de Boole et les circuits à relais/commutateurs).</li>
        </ul>
    </div>

    <!-- Page 20: Boolean Algebra Basics 1 -->
    <div class="slide" id="page20">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">L'algèbre - Les bases - 1</h2>
        <ul>
            <li>L'algèbre de Boole manipule des variables qui ne peuvent prendre que deux états (valeurs) : <i>Vrai</i> ou <i>Faux</i>.</li>
            <li>Une telle variable est appelée variable <i>Booléenne</i>.</li>
            <li>Il est possible aussi d'associer le chiffre <strong>1</strong> à la valeur <i>Vrai</i> et le chiffre <strong>0</strong> à la valeur <i>Faux</i>.
                <br>(C'est la convention la plus utilisée en électronique numérique).</li>
            <li>Les variables Booléennes dans ce cas sont des variables <i>Binaires</i> (car elles ne peuvent prendre que deux valeurs : 0 ou 1).</li>
        </ul>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 21: Boolean Algebra Basics - Examples -->
    <div class="slide" id="page21">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">L'algèbre - Les bases</h2>
        <ul>
            <li>Exemples :</li>
             </ul>
        <p><em>(Note: Cette diapositive semble introduire des exemples qui seraient présentés ensuite. Les exemples typiques incluent des circuits logiques simples, des tables de vérité, ou l'application des opérations sur des valeurs Vrai/Faux ou 1/0.)</em></p>
         <p>Par exemple, si on considère une variable booléenne A qui représente "la porte est ouverte" :</p>
         <ul>
             <li>Si la porte est ouverte, A = <i>Vrai</i> (ou A = 1).</li>
             <li>Si la porte est fermée, A = <i>Faux</i> (ou A = 0).</li>
        </ul>
         <p>On peut alors combiner ces variables, par exemple : "La lumière est allumée" (L) si "l'interrupteur est sur ON" (I) <strong>ET</strong> "il fait nuit" (N). Ceci se traduit par une opération logique \( L = I \cdot N \).</p>
    </div>

    <!-- Page 22: Boolean Algebra - Definitions -->
    <div class="slide" id="page22">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Algèbre de Boole - Définitions</h2>
        <p>Une structure algébrique est une <strong>Algèbre de Boole</strong> \( B \) si elle est définie par :</p>
        <ul>
            <li>Un ensemble \( E \) contenant au moins deux éléments distincts, généralement notés 0 et 1 dans le contexte de l'électronique numérique (\( E = \{0, 1\} \)).</li>
             <li>Deux lois de composition interne (opérations binaires sur \( E \)) :
                 <ul>
                     <li>L'addition logique (OU), notée \( + \)</li>
                     <li>La multiplication logique (ET), notée \( \cdot \) (souvent omise, ex: \(a \cdot b = ab\))</li>
                 </ul>
            </li>
             <li>Une loi de complémentation (opération unaire sur \( E \)), notée \( \overline{\phantom{a}} \) (NON).</li>
            <li>Deux éléments distingués de \( E \): l'élément neutre pour \( + \), noté 0, et l'élément neutre pour \( \cdot \), noté 1.</li>
        </ul>
         <p>On note cette structure :</p>
         <div class="formula">
             \( B = \langle E, +, \cdot, \overline{\phantom{a}}, 0, 1 \rangle \)
         </div>
         <p>où \( + \) et \( \cdot \) sont les lois de composition interne, et \( \overline{\phantom{a}} \) est la loi de complémentation.</p>
         <p><em>(Cette structure doit satisfaire un ensemble d'axiomes, détaillés dans les diapositives suivantes).</em></p>
    </div>

    <!-- Page 23: Boolean Algebra - Composition Laws -->
    <div class="slide" id="page23">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Algèbre de Boole - Lois de Composition</h2>
        <p>Pour l'algèbre de Boole standard utilisée en logique et électronique (\( E = \{0, 1\} \)), les lois de composition sont définies par les tables de vérité suivantes :</p>

        <div style="display: flex; justify-content: space-around; align-items: flex-start; margin-top: 20px;">
            <div>
                <p><strong>Loi de composition \( \cdot \) (ET Logique / AND)</strong></p>
                <table border="1" style="border-collapse: collapse; text-align: center; margin: auto;">
                    <thead>
                        <tr>
                            <th style="padding: 5px;">\( \cdot \)</th>
                            <th style="padding: 5px;">0</th>
                            <th style="padding: 5px;">1</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th style="padding: 5px;">0</th>
                            <td style="padding: 5px;">0</td>
                            <td style="padding: 5px;">0</td>
                        </tr>
                        <tr>
                            <th style="padding: 5px;">1</th>
                            <td style="padding: 5px;">0</td>
                            <td style="padding: 5px;">1</td>
                        </tr>
                    </tbody>
                </table>
                 <p style="text-align: center;">\( a \cdot b = 1 \) si et seulement si \( a = 1 \) et \( b = 1 \).</p>
            </div>

            <div>
                <p><strong>Loi de composition \( + \) (OU Logique / OR)</strong></p>
                 <table border="1" style="border-collapse: collapse; text-align: center; margin: auto;">
                     <thead>
                         <tr>
                             <th style="padding: 5px;">\( + \)</th>
                             <th style="padding: 5px;">0</th>
                             <th style="padding: 5px;">1</th>
                         </tr>
                     </thead>
                     <tbody>
                         <tr>
                             <th style="padding: 5px;">0</th>
                             <td style="padding: 5px;">0</td>
                             <td style="padding: 5px;">1</td>
                         </tr>
                         <tr>
                             <th style="padding: 5px;">1</th>
                             <td style="padding: 5px;">1</td>
                             <td style="padding: 5px;">1</td>
                         </tr>
                     </tbody>
                 </table>
                 <p style="text-align: center;">\( a + b = 0 \) si et seulement si \( a = 0 \) et \( b = 0 \).</p>
            </div>
        </div>
    </div>

    <!-- Page 24: Boolean Algebra - Complementation Law -->
    <div class="slide" id="page24">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Algèbre de Boole - Loi de complémentation</h2>
        <p>Le <strong>complément</strong> (ou négation logique, NON / NOT) d'une variable \( a \), noté \( \bar{a} \), est défini par :</p>
        <ul>
            <li>Si \( a = 1 \), alors \( \bar{a} = 0 \)</li>
             <li>Si \( a = 0 \), alors \( \bar{a} = 1 \)</li>
        </ul>
         <p>On peut aussi écrire : \( 1 \rightarrow \bar{1} = 0 \) et \( 0 \rightarrow \bar{0} = 1 \).</p>

        <p>Terminologie :</p>
        <ul>
            <li>La variable \( a \), lorsqu'elle est notée \( a \), est dite sous sa <strong>forme normale</strong> (ou non-complémentée, ou "vraie").</li>
             <li>La variable \( a \), lorsqu'elle est notée \( \bar{a} \), est dite sous sa <strong>forme complémentée</strong> (ou inversée, ou "fausse").</li>
        </ul>
         <p>Ces formes sont utilisées dans la construction d'expressions booléennes et de fonctions logiques.</p>
    </div>

    <!-- Page 25: Basic Axioms - 1 -->
    <div class="slide" id="page25">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Axiomes de bases - 1</h2>
        <p>L'algèbre de Boole \( \langle E, +, \cdot, \overline{\phantom{a}}, 0, 1 \rangle \) doit satisfaire les axiomes suivants :</p>

        <p><strong>Commutativité :</strong> L'ordre des opérandes ne change pas le résultat.</p>
        <ul>
             <li>Pour tous \( a, b \in E^2 \) (c'est-à-dire \(a \in E\) et \(b \in E\)):</li>
             <li>\( a + b = b + a \)</li>
             <li>\( a \cdot b = b \cdot a \)</li>
        </ul>

        <p><strong>Distributivité :</strong> Chaque opération est distributive par rapport à l'autre.</p>
         <ul>
             <li>Pour tous \( a, b, c \in E^3 \) (c'est-à-dire \(a,b,c \in E\)):</li>
             <li>\( a + (b \cdot c) = (a + b) \cdot (a + c) \)    <em>(Distributivité de + par rapport à .)</em></li>
             <li>\( a \cdot (b + c) = (a \cdot b) + (a \cdot c) \)    <em>(Distributivité de . par rapport à +)</em></li>
         </ul>
         <p><em>Note : La première loi de distributivité (celle de + par rapport à .) est spécifique à l'algèbre de Boole et n'est pas vraie dans l'algèbre ordinaire.</em></p>
    </div>

    <!-- Page 26: Basic Axioms - 2 -->
    <div class="slide" id="page26">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Axiomes de bases - 2</h2>
        <p>Suite des axiomes :</p>

        <p><strong>Éléments Neutres (Identité) :</strong> Existence d'éléments neutres pour chaque opération.</p>
         <ul>
            <li>Pour tout \( a \in E \):</li>
            <li>\( a + 0 = a \)    <em>(0 est l'élément neutre pour +)</em></li>
            <li>\( a \cdot 1 = a \)    <em>(1 est l'élément neutre pour .)</em></li>
         </ul>

        <p><strong>Complémentation :</strong> Chaque élément possède un complément.</p>
        <ul>
             <li>Pour tout \( a \in E \), il existe un élément \( \bar{a} \in E \) tel que :</li>
            <li>\( a + \bar{a} = 1 \)</li>
            <li>\( a \cdot \bar{a} = 0 \)</li>
        </ul>
         <p><em>Ces axiomes définissent formellement l'algèbre de Boole. L'algèbre binaire \( E=\{0, 1\} \) avec les opérations ET, OU, NON satisfait tous ces axiomes.</em></p>
    </div>

    <!-- Page 27: Properties - 1 -->
    <div class="slide" id="page27">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Propriétés - 1</h2>
        <p>À partir des axiomes de base, des propriétés fondamentales peuvent être déduites. Ces propriétés sont très utiles pour simplifier les expressions booléennes.</p>

        <p><strong>Éléments Absorbants :</strong></p>
         <ul>
             <li>Pour tout \( a \in E \):</li>
            <li>\( a + 1 = 1 \)    <em>(1 est l'élément absorbant pour +)</em></li>
            <li>\( a \cdot 0 = 0 \)    <em>(0 est l'élément absorbant pour .)</em></li>
        </ul>

        <p><strong>Loi d'Idempotence :</strong> Appliquer une opération à une variable avec elle-même ne change pas la variable.</p>
         <ul>
            <li>Pour tout \( a \in E \):</li>
            <li>\( a + a = a \)</li>
            <li>\( a \cdot a = a \)</li>
         </ul>
          <p><em>Ces propriétés peuvent être prouvées en utilisant les axiomes. Par exemple, pour \( a+a=a \): \( a+a = (a+a) \cdot 1 = (a+a)(a+\bar{a}) = a + (a \cdot \bar{a}) = a + 0 = a \).</em></p>
    </div>

    <!-- Page 28: Properties - 2 -->
    <div class="slide" id="page28">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Propriétés - 2</h2>
        <p>Autres propriétés déduites des axiomes :</p>

        <p><strong>Loi d'Involution (Double Complémentation) :</strong> Complémenter une variable deux fois revient à la variable originale.</p>
         <ul>
            <li>Pour tout \( a \in E \):</li>
            <li>\( \bar{\bar{a}} = a \)</li>
         </ul>

        <p><strong>Loi d'Absorption :</strong></p>
         <ul>
            <li>Pour tous \( a, b \in E^2 \):</li>
            <li>\( a + (a \cdot b) = a \)</li>
             <li>\( a \cdot (a + b) = a \)</li>
        </ul>
         <p><em>Ces lois sont très utiles pour la simplification. Par exemple, \( a + ab = a \cdot 1 + a \cdot b = a(1+b) = a \cdot 1 = a \).</em></p>
    </div>

    <!-- Page 29: Properties - 5 -->
    <div class="slide" id="page29">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Propriétés - 5</h2>
         <p><em>(Note: Les propriétés 3 et 4 manquent dans la numérotation de la présentation, nous passons directement à la 5)</em></p>
         <p>Propriétés supplémentaires importantes :</p>

        <p><strong>Loi d'Associativité :</strong> L'ordre de calcul ne change pas le résultat lorsque la même opération est appliquée successivement.</p>
         <ul>
             <li>Pour tous \( a, b, c \in E^3 \):</li>
             <li>\( a + (b + c) = (a + b) + c \)</li>
             <li>\( a \cdot (b \cdot c) = (a \cdot b) \cdot c \)</li>
         </ul>
         <p><em>Cela permet d'écrire \(a+b+c\) ou \(abc\) sans ambiguïté.</em></p>

        <p><strong>Lois de De Morgan :</strong> Ces lois expliquent comment distribuer la complémentation sur les opérations ET et OU.</p>
        <ul>
             <li>Pour tous \( a, b \in E^2 \):</li>
            <li>\( \overline{a + b} = \bar{a} \cdot \bar{b} \)    <em>(Le complément d'un OU est le ET des compléments)</em></li>
             <li>\( \overline{a \cdot b} = \bar{a} + \bar{b} \)    <em>(Le complément d'un ET est le OU des compléments)</em></li>
        </ul>
         <p><em>Les lois de De Morgan sont fondamentales pour la manipulation des expressions logiques et la conception de circuits (par exemple, transformer des portes OU en portes ET et inversement en utilisant des inverseurs).</em></p>
    </div>

    <!-- Page 30: Algebra - Order and Function -->
    <div class="slide" id="page30">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">L'algèbre - Ordre et Fonction</h2>

        <p><strong>Relation d'ordre :</strong> Dans l'algèbre de Boole binaire \( \{0, 1\} \), on peut définir des relations d'ordre.</p>
         <ul>
             <li><strong>Ordre Total :</strong> \( 0 < 1 \). C'est l'ordre numérique usuel sur les bits.</li>
             <li><strong>Ordre Lexicographique :</strong> Pour les combinaisons de bits (vecteurs binaires), on utilise souvent l'ordre lexicographique, qui est similaire à l'ordre alphabétique. Par exemple, pour des vecteurs de 2 bits:
                 <br>\( 00 < 01 < 10 < 11 \)
                 <br>Cet ordre est <strong>utile pour les tables de vérité</strong> car il permet de lister toutes les combinaisons d'entrées possibles de manière systématique.</li>
        </ul>

        <p><strong>Définition d'une fonction logique (ou Booléenne) :</strong></p>
         <ul>
             <li>Une fonction logique \( f \) de \( n \) variables \( x_{n-1}, x_{n-2}, \ldots, x_1, x_0 \) est une application qui associe à chaque combinaison possible des valeurs d'entrée (un vecteur de \( n \) bits) une unique valeur de sortie (0 ou 1).</li>
             <li>Formellement :
                 <div class="formula">
                     \( f(x_{n-1}, x_{n-2}, \ldots, x_1, x_0) : \{0, 1\}^n \rightarrow \{0, 1\} \)
                 </div>
                 où \( n \in \mathbb{N}^* \) (\( n \) est un entier naturel non nul) et \( \{0, 1\}^n \) représente l'ensemble de tous les n-uplets de bits.
            </li>
             <li>Une fonction logique peut être définie par une expression booléenne, une table de vérité ou un schéma logique (circuit).</li>
        </ul>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 31: Logic Functions of One Variable -->
    <div class="slide" id="page31">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Fonctions Logiques à une variable \( a \)</h2>
        <p>Pour une seule variable d'entrée \( a \), il y a \( 2^{2^1} = 2^2 = 4 \) fonctions logiques possibles. Ces fonctions associent une sortie (0 ou 1) à chaque entrée possible (0 ou 1) de \( a \).</p>
        <p>Les 4 fonctions possibles sont :</p>
        <ul>
            <li>\( f(a) = 0 \) : <strong>Fonction constante nulle</strong> (toujours 0, indépendamment de \( a \)).</li>
            <li>\( f(a) = 1 \) : <strong>Fonction constante à un</strong> (toujours 1, indépendamment de \( a \)).</li>
            <li>\( f(a) = a \) : <strong>Fonction identité</strong> (la sortie est égale à l'entrée). Aussi appelée "buffer" ou "tampon" en électronique.</li>
            <li>\( f(a) = \bar{a} \) : <strong>Fonction complément</strong> ou <strong>fonction NON</strong> (NOT) (la sortie est l'inverse de l'entrée). C'est l'inverseur logique.</li>
        </ul>
        <table border="1" style="border-collapse: collapse; margin-top: 15px; text-align: center;">
            <thead>
                <tr><th>\( a \)</th><th>\( f=0 \)</th><th>\( f=1 \)</th><th>\( f=a \)</th><th>\( f=\bar{a} \)</th></tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
                 <tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
            </tbody>
        </table>
    </div>

    <!-- Page 32: Logic Functions of Two Variables -->
    <div class="slide" id="page32">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Fonctions Logiques à deux variables \( a \) et \( b \)</h2>
        <p>Pour deux variables d'entrée \( a \) et \( b \), il y a \( 2^{2^2} = 2^4 = 16 \) fonctions logiques possibles. Chaque fonction assigne une sortie (0 ou 1) à chacune des 4 combinaisons d'entrée (00, 01, 10, 11).</p>
        <p>Quelques fonctions importantes parmi les 16 :</p>
         <ul>
             <li>\( f(a, b) = a \cdot b \) : Fonction <strong>ET</strong> (AND). Vrai si \( a \) ET \( b \) sont vrais.</li>
            <li>\( f(a, b) = a + b \) : Fonction <strong>OU</strong> (OR). Vrai si \( a \) OU \( b \) (ou les deux) sont vrais.</li>
             <li>\( f(a, b) = a \oplus b \) : Fonction <strong>OU-EXCLUSIF</strong> (XOR). Vrai si \( a \) OU \( b \) sont vrais, mais pas les deux. (\( a \oplus b = a\bar{b} + \bar{a}b \)).</li>
             <li>\( f(a, b) = \overline{a \cdot b} \) : Fonction <strong>NON-ET</strong> (NAND). Inverse de ET.</li>
             <li>\( f(a, b) = \overline{a + b} \) : Fonction <strong>NON-OU</strong> (NOR). Inverse de OU.</li>
             <li>\( f(a, b) = \overline{a \oplus b} \) : Fonction <strong>NON-OU-EXCLUSIF</strong> (XNOR) ou Équivalence. Vrai si \( a \) et \( b \) sont égaux (\( a=b \)). (\( \overline{a \oplus b} = ab + \bar{a}\bar{b} \)).</li>
             <li>etc... (les 10 autres fonctions existent aussi, comme les fonctions constantes 0 et 1, les fonctions qui ne dépendent que d'une variable, l'implication, etc.)</li>
        </ul>
    </div>

    <!-- Page 33: Logic Functions of n Variables -->
    <div class="slide" id="page33">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Fonctions Logiques à \( n \) variables</h2>
        <p>Généralisation : Pour \( n \) variables d'entrée, il y a \( 2^n \) combinaisons possibles de valeurs d'entrée (de \( 00...0 \) à \( 11...1 \)).</p>
        <p>Pour chaque combinaison d'entrée, la fonction peut valoir soit 0, soit 1. Il y a donc \( 2 \) choix pour la sortie de chacune des \( 2^n \) lignes de la table de vérité.</p>
        <p>Le nombre total de fonctions logiques possibles à \( n \) variables est donc :</p>
        <div class="formula">
            Nombre de fonctions = \( 2^{(2^n)} \)
        </div>
        <ul>
            <li>Pour \( n = 1 \) variable : \( 2^{2^1} = 2^2 = 4 \) fonctions possibles.</li>
            <li>Pour \( n = 2 \) variables : \( 2^{2^2} = 2^4 = 16 \) fonctions possibles.</li>
             <li>Pour \( n = 3 \) variables : \( 2^{2^3} = 2^8 = 256 \) fonctions possibles.</li>
             <li>Pour \( n = 4 \) variables : \( 2^{2^4} = 2^{16} = 65536 \) fonctions possibles.</li>
             <li>etc ...</li>
        </ul>
         <p>Le nombre de fonctions croît extrêmement rapidement avec le nombre de variables.</p>
    </div>

    <!-- Page 34: Representation - Truth Table -->
    <div class="slide" id="page34">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Représentation des fonctions logiques</h2>
        <p>Il existe plusieurs manières de représenter une fonction logique.</p>

        <p><strong>La Table de Vérité :</strong></p>
        <ul>
            <li>C'est une représentation sous forme de <strong>tableau</strong>.</li>
            <li>Elle liste <strong>toutes les combinaisons possibles</strong> des variables d'entrée.</li>
             <li>Pour chaque combinaison, elle indique la <strong>valeur de sortie</strong> correspondante de la fonction.</li>
        </ul>
        <p>Exemple pour une fonction \( f \) de 2 variables \( a \) et \( b \) :</p>
        <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
            <thead>
                <tr><th style="padding: 5px;">\( a \)</th><th style="padding: 5px;">\( b \)</th><th style="padding: 5px;">\( f(a, b) \)</th></tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td>\( f_0 \)</td></tr>
                <tr><td>0</td><td>1</td><td>\( f_1 \)</td></tr>
                 <tr><td>1</td><td>0</td><td>\( f_2 \)</td></tr>
                 <tr><td>1</td><td>1</td><td>\( f_3 \)</td></tr>
            </tbody>
        </table>
        <p>Où \( f_0, f_1, f_2, f_3 \) sont les valeurs de la fonction (0 ou 1) pour les combinaisons d'entrée 00, 01, 10, 11 respectivement. L'ordre des lignes suit généralement l'ordre lexicographique (binaire croissant).</p>
    </div>

    <!-- Page 35: Representation - Karnaugh Map -->
    <div class="slide" id="page35">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Représentation des fonctions logiques</h2>
        <p><strong>Le Tableau de Karnaugh (K-Map) :</strong></p>
        <ul>
            <li>C'est une représentation sous forme de <strong>matrice (tableau 2D)</strong> des valeurs de la fonction logique.</li>
             <li>Les lignes et colonnes correspondent aux combinaisons des variables d'entrée.</li>
             <li>La disposition des cellules exploite la <strong>propriété d'adjacence</strong> : deux cellules physiquement adjacentes (horizontalement ou verticalement, y compris les bords opposés) correspondent à des combinaisons d'entrée qui ne diffèrent que par la valeur d'<strong>une seule variable</strong>.</li>
             <li>Utilisé principalement pour la simplification visuelle des fonctions logiques (jusqu'à 4-5 variables).</li>
         </ul>
         <p>Exemple pour une fonction \( f \) de 3 variables \( a, b, c \), où les lignes sont indexées par \( ac \) et les colonnes par \( b \):</p>
         <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
              <thead>
                 <tr>
                     <th rowspan="2" style="padding: 5px;">\( ac \setminus b \)</th>
                     <th colspan="2" style="padding: 5px;">\( b \)</th>
                 </tr>
                 <tr>
                     <th style="padding: 5px;">0</th>
                     <th style="padding: 5px;">1</th>
                 </tr>
             </thead>
              <tbody>
                 <tr><th style="padding: 5px;">00</th><td>\( f_0 \)</td><td>\( f_1 \)</td></tr>
                 <tr><th style="padding: 5px;">01</th><td>\( f_2 \)</td><td>\( f_3 \)</td></tr>
                 <tr><th style="padding: 5px;">11</th><td>\( f_6 \)</td><td>\( f_7 \)</td></tr>
                 <tr><th style="padding: 5px;">10</th><td>\( f_4 \)</td><td>\( f_5 \)</td></tr>
             </tbody>
         </table>
          <p><em>Note : L'ordre des lignes (00, 01, 11, 10) suit le code de Gray pour la paire \( (a, c) \), garantissant l'adjacence. \(f_i\) représente la valeur de la fonction pour le minterme \(i\). Par exemple, \(f_6\) est la sortie pour \(abc = 110\).</em></p>
    </div>

    <!-- Page 36: Other Representations -->
    <div class="slide" id="page36">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Représentation des fonctions logiques</h2>
        <p>Outre la table de vérité et le tableau de Karnaugh, il existe d'autres méthodes de représentation :</p>
        <ul>
            <li><strong>Diagramme de Veitch :</strong> Similaire au tableau de Karnaugh, mais avec une disposition différente. Moins utilisé aujourd'hui.</li>
             <li><strong>Diagramme de Venn :</strong> Utilisation des diagrammes ensemblistes pour visualiser les opérations logiques (utile pour l'intuition, moins pour la pratique complexe).</li>
             <li><strong>Arbre de décision binaire (BDD - Binary Decision Diagram) :</strong> Structure de données graphique compacte, particulièrement efficace pour représenter et manipuler des fonctions complexes avec de nombreuses variables (utilisée dans les outils de CAO électronique).</li>
             <li><strong>Logigramme (Schéma logique) :</strong> Représentation graphique utilisant des symboles normalisés pour les portes logiques (ET, OU, NON, etc.) et leurs interconnexions. <em>(Sera vu plus en détail dans la partie technologie).</em></li>
             <li><strong>Représentation algébrique (Expression booléenne) :</strong> Utilisation d'une formule basée sur les variables d'entrée et les opérateurs de l'algèbre de Boole (+, ., barre). <em>(Détaillée dans la section "Ecriture logique").</em></li>
        </ul>
    </div>

    <!-- Page 37: Algebraic Representation -->
    <div class="slide" id="page37">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique</h2>
        <ul>
            <li>La représentation sous forme de tableau (Table de vérité) ou de matrice (Karnaugh) devient impraticable lorsque le nombre de variables augmente (généralement limitée à environ 5 variables pour une manipulation manuelle aisée).</li>
            <li>D'où la <strong>nécessité d'utiliser une écriture algébrique</strong> pour décrire les fonctions logiques, quelle que soit leur complexité.</li>
            <li>La fonction logique s'exprime alors comme une <strong>formule (expression booléenne)</strong> : les variables booléennes (ou leurs compléments) sont reliées entre elles par les opérateurs de l'algèbre de Boole (ET, OU, NON).</li>
        </ul>
         <p>Exemples :</p>
         <ul>
             <li>Fonction NON (1 variable) : \( f(a) = \bar{a} \)</li>
             <li>Une fonction de 3 variables : \( f(a, b, c) = \bar{c} \cdot b + a \cdot \bar{b} \) (Souvent écrit \( f(a, b, c) = \bar{c}b + a\bar{b} \) en omettant le symbole \( \cdot \) )</li>
        </ul>
         <p>Cette représentation est fondamentale pour l'analyse, la simplification et la synthèse des circuits numériques.</p>
    </div>

    <!-- Page 38: Algebraic - Minterm and Maxterm Definitions -->
    <div class="slide" id="page38">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique - Minterme et Maxterme</h2>
        <p>Deux formes canoniques (standardisées) sont particulièrement importantes pour l'écriture algébrique :</p>
        <ul>
            <li>Un <strong>produit booléen</strong> de \( n \) littéraux (un littéral est une variable \( a_i \) ou son complément \( \bar{a}_i \)) distincts est appelé un <strong>p-terme</strong> (terme produit) de degré \( n \).</li>
            <li>Une <strong>somme booléenne</strong> de \( n \) littéraux distincts est appelée un <strong>s-terme</strong> (terme somme) de degré \( n \).</li>
        </ul>

        <p><strong>Minterme :</strong></p>
        <ul>
            <li>Un <strong>Minterme</strong> d'une fonction de \( n \) variables est un <strong>p-terme</strong> de degré \( n \) qui inclut <strong>chaque</strong> variable, soit sous sa forme normale (\(a_i\)) soit sous sa forme complémentée (\(\bar{a}_i\)).</li>
            <li>Un minterme \( m_j \) ne vaut <strong>1</strong> que pour <strong>une seule</strong> combinaison des variables d'entrée (celle correspondant à l'indice \( j \)).</li>
            <li>Formule générale : \( m_j = \prod_{i=0}^{n-1} \tilde{a}_i \), où \( \tilde{a}_i = a_i \) si le \(i\)-ème bit de \(j\) est 1, et \( \tilde{a}_i = \bar{a}_i \) si le \(i\)-ème bit de \(j\) est 0. (Ici \( \prod \) désigne le produit logique ET).
                <br><em>(La notation \( \tilde{a}_i \in \{\bar{a}_i, a_i\} \) dans la slide originale indique que chaque variable \(a_i\) apparaît soit comme \(a_i\) soit comme \(\bar{a}_i\)).</em></li>
        </ul>

        <p><strong>Maxterme :</strong></p>
         <ul>
            <li>Un <strong>Maxterme</strong> d'une fonction de \( n \) variables est un <strong>s-terme</strong> de degré \( n \) qui inclut <strong>chaque</strong> variable, soit sous sa forme normale (\(a_i\)) soit sous sa forme complémentée (\(\bar{a}_i\)).</li>
            <li>Un maxterme \( M_j \) ne vaut <strong>0</strong> que pour <strong>une seule</strong> combinaison des variables d'entrée (celle correspondant à l'indice \( j \)).</li>
             <li>Formule générale : \( M_j = \sum_{i=0}^{n-1} \tilde{a}_i \), où \( \tilde{a}_i = a_i \) si le \(i\)-ème bit de \(j\) est 0, et \( \tilde{a}_i = \bar{a}_i \) si le \(i\)-ème bit de \(j\) est 1. (Ici \( \sum \) désigne la somme logique OU).
                 <br><em>(Attention à la convention inversée par rapport au minterme pour la forme normale/complémentée selon le bit de j).</em></li>
         </ul>
    </div>

    <!-- Page 39: Algebraic - Minterm and Maxterm Properties -->
    <div class="slide" id="page39">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique - Minterme et Maxterme</h2>
        <p>Propriétés fondamentales des mintermes et maxtermes pour une fonction de \(n\) variables (il y a \(p = 2^n\) mintermes/maxtermes distincts) :</p>

        <ul>
            <li>La <strong>somme logique (OU) de tous les \( p \) Mintermes</strong> est toujours égale à 1 (sauf si la fonction est la fonction constante 0, auquel cas aucun minterme n'est pertinent).
                <div class="formula">
                     \( \sum_{j=0}^{p-1} m_j = m_0 + m_1 + \dots + m_{p-1} = 1 \)
                </div>
                 Cela signifie qu'au moins un minterme est vrai pour toute combinaison d'entrée.
            </li>

            <li>Le <strong>produit logique (ET) de tous les \( p \) Maxtermes</strong> est toujours égal à 0 (sauf si la fonction est la fonction constante 1).
                 <div class="formula">
                     \( \prod_{j=0}^{p-1} M_j = M_0 \cdot M_1 \cdot \dots \cdot M_{p-1} = 0 \)
                 </div>
                 Cela signifie qu'au moins un maxterme est faux pour toute combinaison d'entrée.
             </li>

            <li><strong>Relation entre Minterme et Maxterme :</strong> Le complément d'un minterme \( m_j \) est égal au maxterme \( M_j \) ayant le même indice, et vice-versa.
                <div class="formula">
                    \( \overline{m_j} = M_j \)    et    \( \overline{M_j} = m_j \)
                 </div>
                Ceci découle directement des lois de De Morgan.
             </li>
         </ul>
         <p>Ces propriétés sont la base des formes canoniques (somme de mintermes et produit de maxtermes).</p>
    </div>

    <!-- Page 40: Algebraic - Minterm and Maxterm Examples -->
    <div class="slide" id="page40">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique - Minterme et Maxterme</h2>
        <ul>
            <li><strong>Exemples :</strong></li>
         </ul>
         <p>Considérons une fonction de \( n=2 \) variables \( a, b \). Il y a \( p = 2^2 = 4 \) mintermes et maxtermes.</p>
         <p><strong>Mintermes (\(m_j\)):</strong></p>
         <ul>
            <li>\( m_0 = \bar{a} \bar{b} \) (vaut 1 si \( a=0, b=0 \))</li>
             <li>\( m_1 = \bar{a} b \) (vaut 1 si \( a=0, b=1 \))</li>
             <li>\( m_2 = a \bar{b} \) (vaut 1 si \( a=1, b=0 \))</li>
             <li>\( m_3 = a b \) (vaut 1 si \( a=1, b=1 \))</li>
         </ul>
          <p>Vérification: \( m_0+m_1+m_2+m_3 = \bar{a}\bar{b} + \bar{a}b + a\bar{b} + ab = \bar{a}(\bar{b}+b) + a(\bar{b}+b) = \bar{a}(1) + a(1) = \bar{a}+a = 1 \).</p>

         <p><strong>Maxtermes (\(M_j\)):</strong></p>
         <ul>
             <li>\( M_0 = a + b \) (vaut 0 si \( a=0, b=0 \))</li>
             <li>\( M_1 = a + \bar{b} \) (vaut 0 si \( a=0, b=1 \))</li>
             <li>\( M_2 = \bar{a} + b \) (vaut 0 si \( a=1, b=0 \))</li>
             <li>\( M_3 = \bar{a} + \bar{b} \) (vaut 0 si \( a=1, b=1 \))</li>
         </ul>
         <p>Vérification: \( \overline{m_0} = \overline{\bar{a}\bar{b}} = \bar{\bar{a}} + \bar{\bar{b}} = a+b = M_0 \).</p>
         <p>Vérification: \( M_0 \cdot M_1 \cdot M_2 \cdot M_3 = (a+b)(a+\bar{b})(\bar{a}+b)(\bar{a}+\bar{b}) = (a \cdot a + a\bar{b} + ba + b\bar{b})(\bar{a}\bar{a} + \bar{a}\bar{b} + b\bar{a} + b\bar{b}) = (a+ab+ab+0)(\bar{a}+\bar{a}\bar{b}+\bar{a}b+0) = (a)(\bar{a}) = 0 \).</p>
    </div>

    <!-- End of added content -->
    <!-- Continuing the document... -->

    <!-- Page 41: Algebraic - Canonical Forms Introduction -->
    <div class="slide" id="page41">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique - Forme Canonique</h2>
        <p>Une <strong>forme canonique</strong> est une écriture algébrique standardisée d'une fonction logique qui n'utilise que des Mintermes ou des Maxtermes.</p>
        <p>Il existe deux possibilités d'écriture (formes canoniques) pour toute fonction logique (sauf les fonctions constantes 0 et 1, qui ont des formes triviales) :</p>
        <ul>
            <li><strong>Forme Canonique Disjonctive</strong> (ou Première Forme Canonique ou Somme de Produits Canonique) :
                 <br><span style="color: #dc3545;">Elle s'exprime sous forme d'une <strong>somme</strong> (OU logique) de <strong>Mintermes</strong>.</span>
                 <br>On inclut les mintermes correspondant aux combinaisons d'entrée pour lesquelles la fonction vaut 1.
            </li>
             <li><strong>Forme Canonique Conjonctive</strong> (ou Seconde Forme Canonique ou Produit de Sommes Canonique) :
                 <br><span style="color: #dc3545;">Elle s'exprime sous forme d'un <strong>produit</strong> (ET logique) de <strong>Maxtermes</strong>.</span>
                 <br>On inclut les maxtermes correspondant aux combinaisons d'entrée pour lesquelles la fonction vaut 0.
             </li>
        </ul>
        <p>Ces formes sont uniques pour une fonction donnée et peuvent être directement dérivées de sa table de vérité.</p>
    </div>

    <!-- Page 42: Algebraic - Canonical Forms Example (XOR) -->
    <div class="slide" id="page42">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique - Forme Canonique</h2>
        <p>Exemple : Fonction <strong>OU-Exclusif (XOR)</strong> \( f(a, b) = a \oplus b \).</p>
        <p>Définition : La valeur de la fonction est 1 si une et une seule des deux variables a la valeur 1.</p>
        <p>Table de vérité :</p>
        <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
             <thead>
                 <tr><th style="padding: 5px;">\( a \)</th><th style="padding: 5px;">\( b \)</th><th style="padding: 5px;">\( f = a \oplus b \)</th><th style="padding: 5px;">Mintermes</th><th style="padding: 5px;">Maxtermes</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td><strong>0</strong></td><td>\( m_0 = \bar{a}\bar{b} \)</td><td>\( M_0 = a+b \)</td></tr>
                 <tr><td>0</td><td>1</td><td><strong>1</strong></td><td>\( m_1 = \bar{a}b \)</td><td>\( M_1 = a+\bar{b} \)</td></tr>
                 <tr><td>1</td><td>0</td><td><strong>1</strong></td><td>\( m_2 = a\bar{b} \)</td><td>\( M_2 = \bar{a}+b \)</td></tr>
                 <tr><td>1</td><td>1</td><td><strong>0</strong></td><td>\( m_3 = ab \)</td><td>\( M_3 = \bar{a}+\bar{b} \)</td></tr>
             </tbody>
        </table>

        <p><strong>Forme Canonique Disjonctive (Somme de Mintermes) :</strong></p>
        <ul>
            <li>On prend les mintermes où \( f(a, b) = 1 \).</li>
            <li>\( f(a, b) = m_1 + m_2 \)</li>
             <li>\( f(a, b) = \bar{a}b + a\bar{b} \)</li>
             <li><em>Lu directement depuis les lignes où f=1 dans la table.</em></li>
         </ul>
         <p>(L'OCR contenait une erreur: `ab + ba`, qui est \(ab + ab = ab\), pas XOR).</p>


        <p><strong>Forme Canonique Conjonctive (Produit de Maxtermes) :</strong></p>
        <ul>
             <li>On prend les maxtermes où \( f(a, b) = 0 \).</li>
             <li>\( f(a, b) = M_0 \cdot M_3 \)</li>
             <li>\( f(a, b) = (a + b) \cdot (\bar{a} + \bar{b}) \)</li>
            <li><em>Dérivé des lignes où f=0 dans la table. On prend les Maxtermes correspondants à ces lignes.</em></li>
         </ul>
         <p>(L'OCR contenait une erreur: `(a+b).(a+b)` qui est \(a+b\), pas XOR, et la description textuelle était confuse).</p>
    </div>

    <!-- Page 43: Algebraic - Canonical Forms Examples -->
    <div class="slide" id="page43">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Ecriture Algébrique - Forme Canonique</h2>
        <ul>
            <li><strong>Exemples</strong></li>
        </ul>
        <p>Soit la fonction \( g(a, b, c) \) définie par la table de vérité suivante :</p>
        <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
             <thead>
                 <tr><th>\(a\)</th><th>\(b\)</th><th>\(c\)</th><th>\(g(a,b,c)\)</th><th>Minterme</th><th>Maxterme</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>\(m_0=\bar{a}\bar{b}\bar{c}\)</td><td>\(M_0=a+b+c\)</td></tr>
                 <tr><td>0</td><td>0</td><td>1</td><td>1</td><td>\(m_1=\bar{a}\bar{b}c\)</td><td>\(M_1=a+b+\bar{c}\)</td></tr>
                 <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>\(m_2=\bar{a}b\bar{c}\)</td><td>\(M_2=a+\bar{b}+c\)</td></tr>
                 <tr><td>0</td><td>1</td><td>1</td><td>1</td><td>\(m_3=\bar{a}bc\)</td><td>\(M_3=a+\bar{b}+\bar{c}\)</td></tr>
                 <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>\(m_4=a\bar{b}\bar{c}\)</td><td>\(M_4=\bar{a}+b+c\)</td></tr>
                 <tr><td>1</td><td>0</td><td>1</td><td>0</td><td>\(m_5=a\bar{b}c\)</td><td>\(M_5=\bar{a}+b+\bar{c}\)</td></tr>
                 <tr><td>1</td><td>1</td><td>0</td><td>1</td><td>\(m_6=ab\bar{c}\)</td><td>\(M_6=\bar{a}+\bar{b}+c\)</td></tr>
                 <tr><td>1</td><td>1</td><td>1</td><td>1</td><td>\(m_7=abc\)</td><td>\(M_7=\bar{a}+\bar{b}+\bar{c}\)</td></tr>
             </tbody>
        </table>
        <p><strong>Forme Canonique Disjonctive (Somme de Mintermes où g=1) :</strong></p>
        <p>\( g(a, b, c) = m_1 + m_3 + m_6 + m_7 \)</p>
        <p>\( g(a, b, c) = \bar{a}\bar{b}c + \bar{a}bc + ab\bar{c} + abc \)</p>
        <p>Notation compacte : \( g = \sum m(1, 3, 6, 7) \)</p>

        <p><strong>Forme Canonique Conjonctive (Produit de Maxtermes où g=0) :</strong></p>
        <p>\( g(a, b, c) = M_0 \cdot M_2 \cdot M_4 \cdot M_5 \)</p>
        <p>\( g(a, b, c) = (a+b+c) \cdot (a+\bar{b}+c) \cdot (\bar{a}+b+c) \cdot (\bar{a}+b+\bar{c}) \)</p>
        <p>Notation compacte : \( g = \prod M(0, 2, 4, 5) \)</p>
    </div>

    <!-- Page 44: Function Definition Domain - Complete -->
    <div class="slide" id="page44">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Domaine de définition des fonctions</h2>
        <p>Une fonction logique peut être soit <strong>complètement</strong> soit <strong>incomplètement</strong> définie.</p>
        <ul>
            <li>Une fonction est <strong>complètement définie</strong> lorsque, pour <strong>toutes</strong> les \( 2^n \) combinaisons possibles de ses variables d'entrée, la valeur de la fonction (0 ou 1) est <strong>spécifiée</strong>.</li>
         </ul>
        <p><em>(Note: La définition est répétée dans l'OCR).</em></p>
        <p>Exemple : La fonction ET (\( f = a \cdot b \)) est complètement définie.</p>
         <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
            <thead>
                 <tr><th style="padding: 5px;">\( a \)</th><th style="padding: 5px;">\( b \)</th><th style="padding: 5px;">\( f = a \cdot b \)</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td>0</td></tr>
                 <tr><td>0</td><td>1</td><td>0</td></tr>
                 <tr><td>1</td><td>0</td><td>0</td></tr>
                 <tr><td>1</td><td>1</td><td>1</td></tr>
             </tbody>
         </table>
         <p>Pour chaque ligne (00, 01, 10, 11), la sortie est clairement définie (0 ou 1).</p>
    </div>

    <!-- Page 45: Function Definition Domain - Incomplete -->
    <div class="slide" id="page45">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Domaine de définition des fonctions</h2>
        <ul>
            <li>Une fonction est <strong>incomplètement définie</strong> lorsque, pour <strong>certaines</strong> combinaisons de ses variables d'entrée, la valeur de la fonction <strong>n'est pas spécifiée</strong> ou n'a pas d'importance.</li>
        </ul>
        <p><em>(Note: La définition est répétée dans l'OCR).</em></p>
        <p>Ces cas non spécifiés sont appelés des "<strong>cas indifférents</strong>" ou "<strong>don't care</strong>" en anglais, et sont souvent notés avec un 'X', '-', ou 'd'.</p>
        <p>Cela se produit typiquement lorsque :</p>
        <ul>
            <li>Certaines combinaisons d'entrée ne peuvent jamais se produire dans le système réel.</li>
            <li>La valeur de sortie pour certaines entrées n'affecte pas le fonctionnement global du système.</li>
        </ul>
        <p>Exemple :</p>
        <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
            <thead>
                 <tr><th style="padding: 5px;">\( a \)</th><th style="padding: 5px;">\( b \)</th><th style="padding: 5px;">\( f(a, b) \)</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td>1</td></tr>
                 <tr><td>0</td><td>1</td><td>X</td></tr>
                 <tr><td>1</td><td>0</td><td>X</td></tr>
                 <tr><td>1</td><td>1</td><td>1</td></tr>
             </tbody>
        </table>
        <p>Ici, les sorties pour les entrées 01 et 10 sont indifférentes. Lors de la minimisation, on peut choisir de considérer ces X comme des 0 ou des 1, selon ce qui permet d'obtenir l'expression la plus simple.</p>
    </div>

    <!-- Page 46: Function Minimization Introduction -->
    <div class="slide" id="page46">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <p>La minimisation d'une fonction logique consiste à trouver une expression algébrique équivalente qui utilise le moins de portes logiques ou de littéraux possible, afin de réduire le coût et la complexité du circuit correspondant.</p>
        <p>Une méthode de minimisation est l'<strong>utilisation directe des axiomes de base et des propriétés</strong> de l'algèbre de Boole pour simplifier algébriquement une expression.</p>
        <p>Exemples de simplification :</p>
        <ul>
            <li>\( f(a, b, c) = ab + bc + c \)
                <br>On utilise la loi d'absorption : \( bc + c = c(b+1) = c \cdot 1 = c \).
                <br>Donc, \( f(a, b, c) = ab + c \).</li>

            <li>\( f(a, b) = a \cdot (\bar{a} + b) \)
                <br>On utilise la distributivité : \( a \cdot (\bar{a} + b) = a\bar{a} + ab \).
                <br>On utilise l'axiome de complémentation : \( a\bar{a} = 0 \).
                <br>Donc, \( f(a, b) = 0 + ab = ab \).</li>
             <p>(Note: L'OCR mentionne l'axiome de complémentation \(a.\bar{a}=0\) mais l'applique de manière incorrecte dans son explication.)</p>

            <li>\( f(a, b, c) = (a + bc)ab \)
                <br>On utilise la distributivité : \( (a + bc)ab = a(ab) + (bc)(ab) \).
                <br>On utilise l'associativité et la commutativité : \( (a \cdot a)b + (a)(b \cdot b)c = aab + abbc \).
                 <br>On utilise l'idempotence : \( a \cdot a = a \) et \( b \cdot b = b \). L'expression devient \( ab + abc \).
                 <br>On utilise la loi d'absorption : \( ab + abc = ab(1 + c) = ab \cdot 1 = ab \).
                <br>Donc, \( f(a, b, c) = ab \).</li>
        </ul>
        <p>Cette méthode peut être fastidieuse et difficile pour des expressions complexes.</p>
    </div>

    <!-- Page 47: Function Minimization Examples -->
    <div class="slide" id="page47">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <ul>
             <li><strong>Exemples</strong> (simplification algébrique)</li>
         </ul>

         <p>Simplifier \( f(x, y, z) = \bar{x}\bar{y}z + \bar{x}yz + x\bar{y}z + xyz \)</p>
         <ol>
            <li>Regrouper les termes : \( (\bar{x}\bar{y}z + \bar{x}yz) + (x\bar{y}z + xyz) \)</li>
            <li>Factoriser : \( \bar{x}z(\bar{y} + y) + xz(\bar{y} + y) \)</li>
            <li>Appliquer \( \bar{y} + y = 1 \) : \( \bar{x}z(1) + xz(1) = \bar{x}z + xz \)</li>
             <li>Factoriser à nouveau : \( z(\bar{x} + x) \)</li>
             <li>Appliquer \( \bar{x} + x = 1 \) : \( z(1) = z \)</li>
        </ol>
         <p>Donc, \( f(x, y, z) = z \).</p>

        <p>Simplifier \( g(a, b, c) = \bar{a}b + abc + a\bar{b}c + a b \bar{c} \)</p>
         <ol>
            <li>Appliquer l'absorption sur \( \bar{a}b + abc = \bar{a}b + bc \)? Non, pas directement.</li>
             <li>Regrouper : \( \bar{a}b + abc + a\bar{b}c + a b \bar{c} = \bar{a}b + a(\bar{b}c + b\bar{c} + bc) \) ? Pas évident.</li>
             <li>Essayons avec la loi du consensus ou K-map. Algébriquement, on peut ajouter un terme redondant (par idempotence ou consensus) pour faciliter. Par exemple, \( ab = ab(c+\bar{c}) = abc+ab\bar{c} \).
                 <br>Essayons d'ajouter \(abc\) (consensus de \( \bar{a}b \) et \( a\bar{b}c \) n'existe pas, consensus de \( \bar{a}b \) et \( ab\bar{c} \) non plus).
             </li>
             <li>Utiliser l'idempotence : ajoutons \(abc\) (qui est un des termes) :
                 \( \bar{a}b + abc + a\bar{b}c + ab\bar{c} + abc \)
                 \( = \bar{a}b + bc(a+ \bar{a}) + a\bar{b}c + ab\bar{c} + abc\) Non, pas ça.
             </li>
             <li>Regroupons différemment : \( (\bar{a}b + abc) + (a\bar{b}c + ab\bar{c}) = b(\bar{a}+ac) + a(\bar{b}c + b\bar{c}) \)... compliqué.</li>
             <li>Via K-Map (plus facile pour celui-ci):
                 Mintermes: \( \bar{a}b\bar{c}(m_2), \bar{a}bc(m_3), abc(m_7), a\bar{b}c(m_5), ab\bar{c}(m_6) \). Le terme \( \bar{a}b \) couvre \(m_2, m_3\).
                 Fonction \( g = m_2 + m_3 + m_7 + m_5 + m_6 \).
                 K-Map donnerait \( g = a + b \). Vérifions :
                 \( a+b = a(b+\bar{b})(c+\bar{c}) + b(a+\bar{a})(c+\bar{c}) \)... très long.
                 Vérifions \( a+b = \bar{a}b + abc + a\bar{b}c + ab\bar{c} \)? Non.
                 Il y a sûrement une erreur dans mon raisonnement ou une simplification que je ne vois pas. L'exemple 2 est peut-être plus complexe qu'il n'y paraît ou mal choisi.</li>
         </ol>
         <p><em>Cet exemple montre les limites de la simplification purement algébrique. Les méthodes graphiques (Karnaugh) ou algorithmiques (Quine-McCluskey) sont souvent préférables.</em></p>
    </div>

    <!-- Page 48: Minimization - Karnaugh Introduction -->
    <div class="slide" id="page48">
         <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <p><strong>Une méthode graphique : Les Tableaux de Karnaugh (K-Maps)</strong></p>
        <ul>
            <li>Les variables (et leurs combinaisons) sont disposées sur les axes du tableau de manière à ce que des cellules adjacentes physiquement correspondent à des combinaisons d'entrée ne différant que d'un bit (propriété d'adjacence).</li>
             <li>Cette disposition fait apparaître visuellement l'application de la loi d'absorption (ou plus précisément, la règle de combinaison \( xy + x\bar{y} = x \)).</li>
             <li>Exemple de combinaison :
                 <div class="formula">
                      \( a\bar{b} + ab = a(\bar{b} + b) = a \cdot 1 = a \)
                 </div>
                 Dans un K-map, si deux cases adjacentes contiennent des '1', elles représentent des termes comme \( a\bar{b} \) et \( ab \), et le regroupement de ces deux cases correspond au terme simplifié \( a \).
            </li>
            <li>Pour garantir l'adjacence entre toutes les cases voisines (y compris sur les bords), on utilise un <strong>code binaire réfléchi</strong> ou <strong>code de Gray</strong> pour ordonner les combinaisons de variables sur les axes du tableau. Dans un code de Gray, seules un bit change entre deux codes consécutifs. (Ex: 00, 01, 11, 10).</li>
        </ul>
    </div>

    <!-- Page 49: Minimization - Karnaugh Steps -->
    <div class="slide" id="page49">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <p><strong>Les Tableaux de Karnaugh : étapes de minimisation (pour Somme de Produits)</strong></p>
        <ol>
            <li>Remplir le tableau de Karnaugh avec les valeurs de la fonction (0, 1, ou X pour les cas indifférents) pour chaque combinaison d'entrée.</li>
            <li>Identifier les groupes de '1' adjacents. Les groupes doivent :
                <ul>
                    <li>Ne contenir que des '1' (ou des 'X' utilisés comme des '1').</li>
                     <li>Avoir une taille égale à une puissance de 2 (\( 2^0=1, 2^1=2, 2^2=4, 2^3=8, \dots \)).</li>
                     <li>Être de forme rectangulaire (y compris les carrés).</li>
                     <li>Être aussi grands que possible.</li>
                 </ul>
                 <p>L'adjacence inclut les bords opposés du tableau (le tableau est considéré comme torique).</p>
                 <p>Le but est de regrouper des ensembles de \( 2^i \) cases contenant des '1', en <strong>maximisant \( i \)</strong> (la taille du groupe) à chaque fois.</p>
             </li>
             <li>Sélectionner un ensemble minimal de groupes qui <strong>couvrent tous les '1'</strong> de la table. Chaque '1' doit être inclus dans au moins un groupe.
                <ul>
                    <li>Commencer par identifier les '1' qui ne peuvent être couverts que par un seul groupe maximal possible (les "implicants essentiels").</li>
                    <li>Ensuite, couvrir les '1' restants en choisissant parmi les groupes possibles de manière à minimiser le nombre total de groupes ou de littéraux dans l'expression finale.</li>
                 </ul>
                 <p>(L'étape décrite dans l'OCR sur le regroupement des cases restantes avec des ensembles déjà établis est une façon de penser à la couverture, mais l'objectif principal est de couvrir tous les 1 avec le moins de groupes possibles, les plus grands possibles).</p>
             </li>
            <li>Écrire l'<strong>équation booléenne algébrique</strong> simplifiée : chaque groupe sélectionné correspond à un terme produit dans la somme finale. Les variables qui changent de valeur (0 et 1) à l'intérieur d'un groupe sont éliminées de ce terme produit.</li>
        </ol>
        <p>Une procédure similaire existe pour obtenir la forme Produit de Sommes en groupant les '0'.</p>
    </div>

    <!-- Page 50: Minimization Examples - Karnaugh -->
    <div class="slide" id="page50">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <ul>
            <li><strong>Exemples</strong> (Minimisation avec Karnaugh)</li>
        </ul>
        <p>Reprenons la fonction \( g(a, b, c) = \sum m(1, 3, 6, 7) \) de la page 43.</p>
        <p>Tableau de Karnaugh (variables a et b en ligne, c en colonne):</p>
         <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
             <thead>
                 <tr>
                    <th rowspan="2" style="padding: 5px;">\( ab \setminus c \)</th>
                    <th colspan="2" style="padding: 5px;">\( c \)</th>
                 </tr>
                 <tr>
                    <th style="padding: 5px;">0</th>
                    <th style="padding: 5px;">1</th>
                 </tr>
             </thead>
              <tbody>
                 <tr><th style="padding: 5px;">00</th><td>\(m_0=0\)</td><td style="background-color: #ccffcc;">\(m_1=1\)</td></tr>
                 <tr><th style="padding: 5px;">01</th><td>\(m_2=0\)</td><td style="background-color: #ccffcc; border: 2px solid red;">\(m_3=1\)</td></tr>
                 <tr><th style="padding: 5px;">11</th><td style="background-color: #ccccff; border: 2px solid blue;">\(m_6=1\)</td><td style="background-color: #ccccff; border: 2px solid blue; border-left: 2px solid red;">\(m_7=1\)</td></tr>
                 <tr><th style="padding: 5px;">10</th><td>\(m_4=0\)</td><td>\(m_5=0\)</td></tr>
             </tbody>
         </table>
         <p>Analyse des regroupements :</p>
         <ul>
             <li>Groupe 1 (vert clair / bordure rouge) : Les deux '1' dans la colonne c=1 et lignes ab=01 et ab=11. Ce sont les cases \(m_3\) et \(m_7\).
                Dans ce groupe: \(a\) change (0->1), \(b\) reste à 1, \(c\) reste à 1. Le terme correspondant est \( bc \).</li>
            <li>Groupe 2 (bleu clair / bordure bleue) : Les deux '1' dans la ligne ab=11. Ce sont les cases \(m_6\) et \(m_7\).
                 Dans ce groupe: \(a\) reste à 1, \(b\) reste à 1, \(c\) change (0->1). Le terme correspondant est \( ab \).</li>
             <li>Le '1' de la case \(m_1\) (ab=00, c=1) n'est pas encore couvert. On ne peut le grouper qu'avec \(m_3\).
                 Groupe 3 (non coloré, mais on peut imaginer un groupe autour de \(m_1, m_3\)) : Cases \(m_1\) et \(m_3\).
                Dans ce groupe: \(a\) reste à 0, \(b\) change (0->1), \(c\) reste à 1. Le terme correspondant est \( \bar{a}c \).</li>
         </ul>
         <p>Les '1' sont dans les cases 1, 3, 6, 7.</p>
         <ul>
             <li>\(m_1\) est couvert par le groupe \( \bar{a}c \).</li>
             <li>\(m_3\) est couvert par \( \bar{a}c \) et \( bc \).</li>
             <li>\(m_6\) est couvert par \( ab \).</li>
             <li>\(m_7\) est couvert par \( bc \) et \( ab \).</li>
         </ul>
         <p>Tous les '1' sont couverts. L'expression minimisée est la somme des termes correspondants aux groupes :</p>
         <p>\( g(a, b, c) = \bar{a}c + bc + ab \)</p>
         <p><em>(Note: Il y avait une erreur dans mon exemple précédent pour la fonction g. La simplification K-Map est correcte ici pour \( g = \sum m(1, 3, 6, 7) \)).</em></p>

    </div>
    <!-- Continuing the document... -->

    <!-- Page 51: Minimization - Karnaugh Remarks -->
    <div class="slide" id="page51">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <p><strong>Les Tableaux de Karnaugh : remarques</strong></p>
        <ul>
            <li>Dans le cas de <strong>fonctions incomplètement définies</strong> (contenant des cas indifférents 'X') :
                <ul>
                    <li>Lors de la recherche de groupes de '1' (pour la forme Somme de Produits), on peut <strong>considérer les 'X' comme des '1' si cela permet de former un groupe plus grand</strong>.</li>
                    <li>Les 'X' n'ont pas besoin d'être couverts par un groupe s'ils ne sont pas utiles pour agrandir un groupe de '1' essentiels.</li>
                    <li>De même, pour la forme Produit de Sommes, on peut considérer les 'X' comme des '0' pour agrandir les groupes de '0'.</li>
                    <li>L'utilisation judicieuse des 'X' permet souvent d'obtenir une simplification supplémentaire.</li>
                </ul>
            </li>
            <li><strong>Limites de la méthode :</strong>
                 <ul>
                     <li>La méthode des tableaux de Karnaugh devient complexe et difficile à visualiser au-delà de 4 ou 5 variables.</li>
                     <li>Pour 5 variables, on utilise souvent deux tableaux de 4 variables côte à côte, ou un tableau 3D conceptuellement. Pour 6 variables, 4 tableaux de 4 variables.</li>
                     <li>Au-delà, des méthodes algorithmiques (comme Quine-McCluskey ou des heuristiques comme Espresso) sont utilisées, souvent implémentées dans des logiciels de CAO.</li>
                 </ul>
             </li>
        </ul>
    </div>

    <!-- Page 52: Minimization Examples - Karnaugh (Placeholder) -->
    <div class="slide" id="page52">
        <div class="header-small">Cours d'électronique numérique - Algèbre de Boole</div>
        <h2 class="slide-title">Minimisation de Fonctions</h2>
        <ul>
            <li><strong>Exemples</strong> (Minimisation avec Karnaugh, potentiellement avec cas indifférents)</li>
        </ul>
        <p><em>(Cette diapositive est un placeholder pour des exemples supplémentaires de minimisation via les tableaux de Karnaugh, possiblement illustrant l'utilisation des cas indifférents 'X').</em></p>
        <p>Exemple avec cas indifférents : Soit \( f(a,b,c,d) = \sum m(0, 1, 2, 8, 9, 10) \) avec les cas indifférents \( d(a,b,c,d) = \sum d(5, 7, 13, 15) \).</p>
         <p>On placerait les '1' aux positions 0, 1, 2, 8, 9, 10 et les 'X' aux positions 5, 7, 13, 15 dans un K-Map à 4 variables. On chercherait ensuite les plus grands groupes possibles de '1' en utilisant les 'X' si nécessaire.</p>
         <p style="text-align:center; color: #666;">[Placeholder for K-Map Example with Don't Cares]</p>
    </div>

    <!-- Section Transition: Coding -->
     <h2 style="text-align:center; margin-top: 40px; color: #003399;">Codage</h2>

    <!-- Page 53: Coding Title -->
    <div class="slide" id="page53">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Codage</h2>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Codage
        </div>
         <p style="text-align: center; margin-top: 20px;">Cette section aborde les différentes manières de représenter l'information (nombres, caractères) sous forme numérique binaire.</p>
    </div>

    <!-- Page 54: Coding Overview -->
    <div class="slide" id="page54">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Codage</h2>
        <p>Principaux sujets abordés dans cette section :</p>
        <ul>
            <li><strong>Système de base : codage décimal</strong> (Rappel du système de numération usuel).</li>
            <li><strong>Conversion décimal-binaire et binaire-décimal</strong> (Méthodes de passage entre la base 10 et la base 2).</li>
             <li>Problème du nombre de bits : \( \nexists n \in \mathbb{N} \) tel que \( 2^n = 10 \).
                <br><em>(Signifie qu'un nombre exact de bits ne peut pas représenter exactement les 10 chiffres décimaux 0-9 sans reste ni manque. Il n'existe pas d'entier n tel que 2^n = 10).</em>
                <br>Nécessité du <strong>codage octal</strong> (base 8) ou <strong>héxadécimal</strong> (base 16) comme intermédiaires pratiques pour représenter des groupes de bits.
            </li>
            <li><strong>Codage DCB (Décimal Codé Binaire)</strong> ou BCD (Binary Coded Decimal) : Représenter chaque chiffre décimal individuellement par un groupe de 4 bits.</li>
            <li><strong>Code de Gray</strong> ou binaire réfléchi : Code binaire où deux valeurs successives ne diffèrent que d'un seul bit (utile pour éviter les erreurs transitoires dans les compteurs ou capteurs de position).</li>
            <li><strong>Code ASCII</strong> (American Standard Code for Information Interchange) : Codage standard pour représenter les caractères (lettres, chiffres, symboles) par des nombres binaires (généralement sur 7 ou 8 bits).</li>
        </ul>
    </div>

    <!-- Page 55: Binary-to-Decimal Conversion -->
    <div class="slide" id="page55">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Conversion binaire-décimal</h2>
        <ul>
            <li>La conversion d'un nombre binaire en son équivalent décimal s'effectue simplement en réalisant la <strong>somme des bits pondérés par leur position</strong> (puissance de 2 correspondante).</li>
             <li>Formule générale pour un nombre binaire \( b_{n-1}b_{n-2}...b_1b_0 \):
                 <div class="formula">
                     Valeur Décimale = \( \sum_{i=0}^{n-1} b_i \times 2^i \)
                 </div>
                 où \( b_i \) est la valeur du bit à la position \( i \) (0 ou 1), et \( 2^i \) est le poids de cette position. La position 0 est le bit le moins significatif (LSB), la position \( n-1 \) est le bit le plus significatif (MSB).
            </li>
        </ul>
        <p>Exemple : Convertir \( 10110_2 \) en décimal.</p>
        <div style="margin: 15px 0; padding: 10px; background-color: #f0f0f0; border-left: 3px solid #007bff;">
            Nombre Binaire :        1   0   1   1   0 <br>
             Position du bit (i) :     4   3   2   1   0 <br>
            Poids (\(2^i\)) :               \(2^4\) \(2^3\) \(2^2\) \(2^1\) \(2^0\) <br>
             Poids :                    16   8   4   2   1 <br><br>
            Nombre Décimal = \( (1 \times 16) + (0 \times 8) + (1 \times 4) + (1 \times 2) + (0 \times 1) \) <br>
            Nombre Décimal = \( 16 + 0 + 4 + 2 + 0 = 22_{10} \)
        </div>
        <p>Donc, \( 10110_2 = 22_{10} \).</p>
    </div>

    <!-- Page 56: Decimal-to-Binary Conversion -->
    <div class="slide" id="page56">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Conversion décimal-binaire</h2>
        <ul>
            <li>La conversion décimal-binaire peut s'effectuer en utilisant la méthode inverse de la précédente (trouver la plus grande puissance de 2 inférieure au nombre, la soustraire, et répéter avec le reste), mais c'est souvent fastidieux pour de grands nombres.</li>
            <li>Une méthode plus systématique est celle des <strong>divisions successives par 2</strong>.</li>
        </ul>
        <p>Procédure :</p>
        <ol>
             <li>Diviser le nombre décimal par 2.</li>
             <li>Noter le reste (qui sera 0 ou 1). Ce reste est le bit de poids le plus faible (LSB) du nombre binaire.</li>
             <li>Remplacer le nombre par le quotient obtenu.</li>
             <li>Répéter les étapes 1 à 3 jusqu'à ce que le quotient devienne 0.</li>
             <li>Les restes successifs, lus de bas en haut (du dernier au premier), forment le nombre binaire.</li>
        </ol>
        <p>Exemple : Convertir \( 29_{10} \) en binaire.</p>
        <pre style="font-family: monospace; font-size: 1.2em; line-height: 1.5; text-align: center; border: 1px dashed #ccc; padding: 10px; width: fit-content; margin: auto;">
   29 / 2 = 14 reste 1  (LSB)
   14 / 2 =  7 reste 0
    7 / 2 =  3 reste 1
    3 / 2 =  1 reste 1
    1 / 2 =  0 reste 1  (MSB)
        </pre>
         <p style="text-align: center;">En lisant les restes du bas vers le haut : <strong>11101</strong>.</p>
        <p>Donc, \( 29_{10} = 11101_2 \).</p>
    </div>

    <!-- Page 57: Hexadecimal Coding Introduction -->
    <div class="slide" id="page57">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Codage Hexadécimal</h2>
        <ul>
            <li>Le codage hexadécimal (base 16) est très utilisé en informatique car il permet de représenter de longues chaînes binaires de manière plus compacte et lisible.</li>
            <li>Il travaille avec des groupes de 4 bits, appelés <strong>quartets</strong> (ou nibbles). Par exemple : \( 1010_2 \).</li>
            <li>Pourquoi 4 bits ? Car \( 2^4 = 16 \), donc chaque groupe de 4 bits peut être représenté par un unique symbole hexadécimal.</li>
            <li>C'est particulièrement intéressant car la taille du mot binaire de base dans beaucoup d'architectures d'ordinateurs est l'<strong>octet</strong> (byte), qui est composé de 8 bits.</li>
            <li>Un <strong>octet</strong> = Deux <strong>Quartets</strong>.
                 <br>Exemple: L'octet \( 11010110_2 \) peut être vu comme \( (1101)(0110)_2 \). Chaque quartet sera converti en un symbole hexadécimal.</li>
        </ul>
    </div>

    <!-- Page 58: Hexadecimal Symbols -->
    <div class="slide" id="page58">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Codage Hexadécimal</h2>
        <ul>
             <li>La base du système Héxadécimal est la <strong>base 16</strong>.</li>
             <li>Il faut donc <strong>16 symboles</strong> distincts pour représenter les chiffres de cette base.</li>
             <li>On utilise les 10 chiffres décimaux (0 à 9) et les 6 premières lettres de l'alphabet (A à F) :
                 <div class="formula" style="font-size: 1.3em; text-align: center;">
                     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
                 </div>
            </li>
             <li>Correspondance des lettres :
                 <ul>
                     <li>A = 10 (décimal)</li>
                     <li>B = 11 (décimal)</li>
                     <li>C = 12 (décimal)</li>
                     <li>D = 13 (décimal)</li>
                     <li>E = 14 (décimal)</li>
                     <li>F = 15 (décimal)</li>
                 </ul>
            </li>
         </ul>
        <p>Notation : On indique souvent la base par un indice (ex: \( 3A_{16} \)) ou un préfixe (ex: `0x3A` en C/Java, `#3A` en HTML/CSS, `$3A` dans certains assembleurs).</p>
    </div>

    <!-- Page 59: Hexadecimal-Decimal-Binary Table -->
    <div class="slide" id="page59">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Codage Hexadécimal</h2>
        <p>Table de correspondance entre Hexadécimal, Décimal et Binaire (sur 4 bits) :</p>
         <table border="1" style="border-collapse: collapse; margin: 15px auto; text-align: center;">
            <thead>
                <tr><th>Hexa</th><th>Décimal</th><th>Binaire (Quartet)</th><th> </th><th>Hexa</th><th>Décimal</th><th>Binaire (Quartet)</th></tr>
            </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td>0000</td><td></td><td>8</td><td>8</td><td>1000</td></tr>
                 <tr><td>1</td><td>1</td><td>0001</td><td></td><td>9</td><td>9</td><td>1001</td></tr>
                 <tr><td>2</td><td>2</td><td>0010</td><td></td><td>A</td><td>10</td><td>1010</td></tr>
                 <tr><td>3</td><td>3</td><td>0011</td><td></td><td>B</td><td>11</td><td>1011</td></tr>
                 <tr><td>4</td><td>4</td><td>0100</td><td></td><td>C</td><td>12</td><td>1100</td></tr>
                 <tr><td>5</td><td>5</td><td>0101</td><td></td><td>D</td><td>13</td><td>1101</td></tr>
                 <tr><td>6</td><td>6</td><td>0110</td><td></td><td>E</td><td>14</td><td>1110</td></tr>
                 <tr><td>7</td><td>7</td><td>0111</td><td></td><td>F</td><td>15</td><td>1111</td></tr>
             </tbody>
         </table>
         <p>Cette table est fondamentale pour les conversions Binaire <-> Hexadécimal : il suffit de grouper les bits par 4 (en partant de la droite) et de remplacer chaque groupe par le symbole hexadécimal correspondant (ou inversement).</p>
         <p>Exemple : \( 11010110_2 = (1101)(0110)_2 = D6_{16} \).</p>
          <p>Exemple : \( 5C_{16} = (0101)(1100)_2 = 01011100_2 \).</p>
    </div>

    <!-- Page 60: Hexadecimal-to-Decimal Conversion -->
    <div class="slide" id="page60">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Conversion Hexadécimal-Décimal</h2>
        <ul>
            <li>De même que pour la conversion binaire-décimal, il s'agit ici de faire une <strong>sommation pondérée des symboles</strong> par leur position (puissance de 16).</li>
            <li>Formule générale pour un nombre hexadécimal \( h_{n-1}h_{n-2}...h_1h_0 \):
                 <div class="formula">
                    Valeur Décimale = \( \sum_{i=0}^{n-1} \text{valeur}(h_i) \times 16^i \)
                 </div>
                 où \( \text{valeur}(h_i) \) est la valeur décimale du symbole hexadécimal à la position \( i \), et \( 16^i \) est le poids de cette position.
            </li>
         </ul>
         <p>Exemple : Convertir \( A2E_{16} \) en décimal.</p>
         <div style="margin: 15px 0; padding: 10px; background-color: #f0f0f0; border-left: 3px solid #007bff;">
            Nombre Hexadécimal :    A      2      E <br>
            Position du symbole (i) : 2      1      0 <br>
            Poids (\(16^i\)) :               \(16^2\)   \(16^1\)   \(16^0\) <br>
            Poids :                      256    16      1 <br>
            Valeur Décimale Symboles: 10     2      14 <br><br>
             Nombre Décimal = \( (10 \times 16^2) + (2 \times 16^1) + (14 \times 16^0) \) <br>
             Nombre Décimal = \( (10 \times 256) + (2 \times 16) + (14 \times 1) \) <br>
             Nombre Décimal = \( 2560 + 32 + 14 = 2606_{10} \)
         </div>
         <p>Donc, \( A2E_{16} = 2606_{10} \).</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 61: Decimal-to-Hexadecimal Conversion -->
    <div class="slide" id="page61">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Conversion Décimal-Hexadécimal</h2>
        <ul>
            <li>De même que pour la conversion décimal-binaire, on a recours à la <strong>division successive</strong>, mais cette fois par <strong>16</strong>.</li>
        </ul>
        <p>Procédure :</p>
        <ol>
            <li>Diviser le nombre décimal par 16.</li>
            <li>Noter le reste (qui sera entre 0 et 15). Convertir ce reste en son symbole hexadécimal (0-9, A-F). Ce symbole est le chiffre de poids le plus faible (LSD) du nombre hexadécimal.</li>
             <li>Remplacer le nombre par le quotient obtenu.</li>
             <li>Répéter les étapes 1 à 3 jusqu'à ce que le quotient devienne 0.</li>
             <li>Les symboles hexadécimaux correspondant aux restes successifs, lus de bas en haut (du dernier au premier), forment le nombre hexadécimal.</li>
        </ol>
        <p>Exemple : Convertir \( 311_{10} \) en hexadécimal.</p>
        <pre style="font-family: monospace; font-size: 1.2em; line-height: 1.5; text-align: center; border: 1px dashed #ccc; padding: 10px; width: fit-content; margin: auto;">
   311 / 16 = 19 reste 7   (LSD -> 7)
    19 / 16 =  1 reste 3   (-> 3)
     1 / 16 =  0 reste 1   (MSD -> 1)
        </pre>
         <p style="text-align: center;">En lisant les restes (convertis en symboles hexa) du bas vers le haut : <strong>137</strong>.</p>
        <p>Donc, \( 311_{10} = 137_{16} \).</p>
    </div>

    <!-- Page 62: Hexadecimal-to-Binary Conversion -->
    <div class="slide" id="page62">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Conversion Hexadécimal-Binaire</h2>
        <ul>
            <li>La conversion hexadécimal-binaire est très directe.</li>
            <li>Le nombre binaire est déduit en <strong>remplaçant chaque chiffre hexadécimal par son quartet binaire</strong> (groupe de 4 bits) équivalent, en utilisant la table de correspondance (voir page 59).</li>
        </ul>
        <p>Exemple : Convertir \( E3B1_{16} \) en binaire.</p>
         <table style="margin: 15px auto; text-align: center; border-spacing: 10px 0;">
             <tr>
                 <td>Nombre Hexadécimal:</td>
                 <td style="font-size: 1.3em; font-weight: bold;">E</td>
                 <td style="font-size: 1.3em; font-weight: bold;">3</td>
                 <td style="font-size: 1.3em; font-weight: bold;">B</td>
                 <td style="font-size: 1.3em; font-weight: bold;">1</td>
             </tr>
             <tr>
                 <td>Nombre Binaire (Quartets):</td>
                 <td style="font-family: monospace;">1110</td>
                 <td style="font-family: monospace;">0011</td>
                 <td style="font-family: monospace;">1011</td>
                 <td style="font-family: monospace;">0001</td>
             </tr>
         </table>
         <p style="text-align: center;">En juxtaposant les quartets : \( 1110001110110001_2 \)</p>
         <p>Donc, \( E3B1_{16} = 1110001110110001_2 \).</p>
    </div>

    <!-- Page 63: Binary-to-Hexadecimal Conversion -->
    <div class="slide" id="page63">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Conversion Binaire-Hexadécimal</h2>
        <ul>
            <li>La méthode est l'inverse de la précédente.</li>
            <li>On <strong>regroupe les bits</strong> du nombre binaire par <strong>quartets (groupes de 4)</strong>, en commençant par le bit de poids le plus faible (le plus à droite). Si le groupe le plus à gauche n'a pas 4 bits, on complète avec des zéros non significatifs à gauche.</li>
            <li>On remplace ensuite chaque quartet par son <strong>équivalent hexadécimal</strong> (0-9, A-F).</li>
        </ul>
        <p>Exemple : Convertir \( 0101101011001011_2 \) en hexadécimal.</p>
        <table style="margin: 15px auto; text-align: center; border-spacing: 10px 0;">
             <tr>
                 <td>Nombre Binaire (groupé):</td>
                 <td style="font-family: monospace;">0101</td>
                 <td style="font-family: monospace;">1010</td>
                 <td style="font-family: monospace;">1100</td>
                 <td style="font-family: monospace;">1011</td>
             </tr>
             <tr>
                 <td>Nombre Hexadécimal:</td>
                 <td style="font-size: 1.3em; font-weight: bold;">5</td>
                 <td style="font-size: 1.3em; font-weight: bold;">A</td>
                 <td style="font-size: 1.3em; font-weight: bold;">C</td>
                 <td style="font-size: 1.3em; font-weight: bold;">B</td>
             </tr>
         </table>
        <p style="text-align: center;">En juxtaposant les symboles : \( 5ACB_{16} \)</p>
        <p>Donc, \( 0101101011001011_2 = 5ACB_{16} \).</p>
         <p>Autre exemple : Convertir \( 1101101_2 \) en hexadécimal.</p>
         <p style="text-align: center;">Groupement : \( (0110)(1101)_2 \) (ajout d'un zéro à gauche)</p>
         <p style="text-align: center;">Conversion : \( 6D_{16} \)</p>
    </div>

    <!-- Page 64: Notations -->
    <div class="slide" id="page64">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Notations</h2>
        <p>Ambiguïté potentielle :</p>
        <ul>
            <li>Les symboles <strong>0</strong> et <strong>1</strong> appartiennent aux codes binaire, décimal et hexadécimal.</li>
            <li>Les symboles <strong>0, 1, 2, 3, 4, 5, 6, 7, 8, 9</strong> appartiennent aux codes décimal et hexadécimal.</li>
        </ul>
        <p>Par exemple, que représente "100" ? Est-ce 100 en décimal, 100 en binaire (4 en décimal), ou 100 en hexadécimal (256 en décimal) ?</p>
        <p>Nécessité d'une <strong>convention d'écriture</strong> pour différencier les bases :</p>
        <ul>
             <li><strong>Indice</strong> indiquant la base :
                <ul>
                    <li>Binaire : \( 100_B \) ou \( 100_2 \)</li>
                    <li>Décimal : \( 100_{10} \) ou simplement \( 100 \) (souvent la base par défaut si non spécifiée)</li>
                    <li>Hexadécimal : \( 100_H \) ou \( 100_{16} \)</li>
                </ul>
             </li>
             <li><strong>Préfixes</strong> (courants en programmation) :
                 <ul>
                     <li>Binaire : `0b100`</li>
                     <li>Octal : `0o100` (ou `0100` en C/Java, attention)</li>
                     <li>Hexadécimal : `0x100`</li>
                 </ul>
             </li>
              <li><strong>Suffixes</strong> :
                 <ul>
                     <li>Hexadécimal : `100h` (souvent en assembleur)</li>
                 </ul>
             </li>
        </ul>
         <p>Dans ce cours, nous utiliserons principalement les indices (\( _2, _{10}, _{16} \)) ou le contexte pour lever l'ambiguïté.</p>
    </div>

    <!-- Page 65: Binary Coded Decimal (BCD) Introduction -->
    <div class="slide" id="page65">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Décimal Codé Binaire : DCB (ou BCD)</h2>
        <p>Le code DCB (Décimal Codé Binaire), ou BCD (Binary Coded Decimal) en anglais, est une méthode pour représenter les nombres décimaux en utilisant le binaire.</p>
        <ul>
            <li>Principe : <strong>Remplacer chaque chiffre</strong> d'un nombre décimal individuellement par son <strong>équivalent binaire sur 4 bits</strong> (un quartet).</li>
            <li>Il s'agit d'une <strong>correspondance directe</strong> entre chaque chiffre décimal et un groupe de 4 bits.</li>
        </ul>
        <p>Exemple 1 : Coder \( 5371_{10} \) en DCB.</p>
         <table style="margin: 15px auto; text-align: center; border-spacing: 10px 0;">
             <tr>
                 <td>Nombre Décimal:</td>
                 <td>5</td>
                 <td>3</td>
                 <td>7</td>
                 <td>1</td>
             </tr>
             <tr>
                 <td>Nombre Binaire (DCB):</td>
                 <td style="font-family: monospace;">0101</td>
                 <td style="font-family: monospace;">0011</td>
                 <td style="font-family: monospace;">0111</td>
                 <td style="font-family: monospace;">0001</td>
             </tr>
         </table>
         <p style="text-align: center;">Donc, \( 5371_{10} = 0101\ 0011\ 0111\ 0001_{DCB} \).</p>

         <p>Exemple 2 : Décoder \( 0101\ 1001\ 1000\ 0011_{DCB} \).</p>
         <table style="margin: 15px auto; text-align: center; border-spacing: 10px 0;">
              <tr>
                 <td>Nombre Binaire (DCB):</td>
                 <td style="font-family: monospace;">0101</td>
                 <td style="font-family: monospace;">1001</td>
                 <td style="font-family: monospace;">1000</td>
                 <td style="font-family: monospace;">0011</td>
             </tr>
              <tr>
                 <td>Nombre Décimal:</td>
                 <td>5</td>
                 <td>9</td>
                 <td>8</td>
                 <td>3</td>
             </tr>
         </table>
        <p style="text-align: center;">Donc, \( 0101\ 1001\ 1000\ 0011_{DCB} = 5983_{10} \).</p>
        <p><strong>Attention :</strong> Ne pas confondre le code DCB avec la conversion binaire pure.</p>
    </div>

    <!-- Page 66: BCD Properties and Comparison -->
    <div class="slide" id="page66">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Décimal Codé Binaire (DCB/BCD)</h2>
        <p>Propriétés et inconvénients du code DCB :</p>
        <ul>
            <li><strong>Sous-Utilisation de l'espace de représentation binaire :</strong>
                <ul>
                    <li>Chaque chiffre décimal (0-9) est codé sur 4 bits.</li>
                    <li>Or, 4 bits peuvent représenter \( 2^4 = 16 \) valeurs différentes (0000 à 1111).</li>
                    <li>Les combinaisons binaires correspondant aux valeurs décimales 10 à 15 ne sont <strong>jamais utilisées</strong> en DCB pour représenter un chiffre.</li>
                </ul>
            </li>
            <li>Il y a donc <strong>6 représentations interdites</strong> pour chaque quartet en DCB :
                <br>\( 1010_2, 1011_2, 1100_2, 1101_2, 1110_2, 1111_2 \)
                <br>(Correspondant à A, B, C, D, E, F en hexadécimal).
            </li>
            <li><strong>Différence majeure entre codage binaire pur et DCB :</strong>
                <ul>
                    <li>Un nombre codé en DCB utilise généralement <strong>plus de bits</strong> que le même nombre codé en binaire pur.</li>
                    <li>L'arithmétique (addition, soustraction) sur les nombres DCB est <strong>différente</strong> de l'arithmétique binaire standard et nécessite des ajustements spécifiques.</li>
                </ul>
            </li>
        </ul>
        <p>Exemple : Le nombre décimal 231.</p>
        <ul>
            <li>Conversion en <strong>binaire pur</strong> : \( 231_{10} = 11100111_2 \) (utilise 8 bits).</li>
             <li>Codage en <strong>DCB</strong> :
                <br>2 -> 0010
                <br>3 -> 0011
                <br>1 -> 0001
                <br>\( 231_{10} = 0010\ 0011\ 0001_{DCB} \) (utilise 12 bits).
            </li>
        </ul>
        <p>Le DCB est utile dans les systèmes où l'interface avec l'affichage décimal est fréquente (calculatrices, horloges, multimètres) car il évite des conversions complexes.</p>
    </div>

    <!-- Page 67: Gray Code -->
    <div class="slide" id="page67">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Code de Gray</h2>
        <p>Le Code de Gray, ou code binaire réfléchi, est un système de codage binaire ayant une propriété particulière :</p>
        <ul>
            <li>Deux représentations de <strong>nombres consécutifs ne diffèrent que d'un seul bit</strong>.</li>
        </ul>
        <p>Cette propriété est très utile pour éviter les erreurs ou les états transitoires ambigus dans certains systèmes mécaniques ou électroniques, comme les capteurs de position rotatifs (codeurs optiques) ou certains compteurs, car un petit changement de position ne provoque qu'un seul changement de bit.</p>
        <p>Table de comparaison pour 4 bits (Décimal / Binaire standard / Code Gray) :</p>
        <div style="display: flex; justify-content: space-around;">
            <table border="1" style="border-collapse: collapse; text-align: center;">
                <thead><tr><th>Décimal</th><th>Binaire</th><th>Gray</th></tr></thead>
                <tbody>
                    <tr><td>0</td><td>0000</td><td>0000</td></tr>
                    <tr><td>1</td><td>0001</td><td>0001</td></tr>
                    <tr><td>2</td><td>0010</td><td>0011</td></tr>
                    <tr><td>3</td><td>0011</td><td>0010</td></tr>
                    <tr><td>4</td><td>0100</td><td>0110</td></tr>
                    <tr><td>5</td><td>0101</td><td>0111</td></tr>
                    <tr><td>6</td><td>0110</td><td>0101</td></tr>
                    <tr><td>7</td><td>0111</td><td>0100</td></tr>
                </tbody>
            </table>
            <table border="1" style="border-collapse: collapse; text-align: center;">
                 <thead><tr><th>Décimal</th><th>Binaire</th><th>Gray</th></tr></thead>
                 <tbody>
                     <tr><td>8</td><td>1000</td><td>1100</td></tr>
                     <tr><td>9</td><td>1001</td><td>1101</td></tr>
                     <tr><td>10</td><td>1010</td><td>1111</td></tr>
                     <tr><td>11</td><td>1011</td><td>1110</td></tr>
                     <tr><td>12</td><td>1100</td><td>1010</td></tr>
                     <tr><td>13</td><td>1101</td><td>1011</td></tr>
                     <tr><td>14</td><td>1110</td><td>1001</td></tr>
                     <tr><td>15</td><td>1111</td><td>1000</td></tr>
                 </tbody>
             </table>
        </div>
        <p>Notez par exemple qu'entre 7 (\(0100_G\)) et 8 (\(1100_G\)), seul le premier bit change. En binaire standard, entre 7 (\(0111_B\)) et 8 (\(1000_B\)), les 4 bits changent.</p>
        <p>Il existe des algorithmes simples pour convertir entre le binaire standard et le code de Gray.</p>
    </div>

    <!-- Page 68: ASCII Code Introduction -->
    <div class="slide" id="page68">
        <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">Code ASCII</h2>
        <ul>
            <li><strong>Besoin de traiter de l'information non numérique :</strong> Texte, symboles, commandes.</li>
             <li><strong>Information Alphanumérique :</strong> Contient des lettres (majuscules, minuscules), des chiffres, des signes de ponctuation, des symboles spéciaux, des caractères de contrôle (retour chariot, tabulation...). Ex: `, ? R t j`</li>
             <li><strong>Mise en place d'un codage standard : l'ASCII</strong>
                 <ul>
                    <li>Signifie <strong>American Standard Code for Information Interchange</strong>.</li>
                    <li>Standard historique et encore très utilisé pour représenter les caractères en informatique.</li>
                 </ul>
             </li>
             <li><strong>ASCII standard (original) utilise 7 bits :</strong>
                 <ul>
                     <li>\( 2^7 = 128 \) codes possibles.</li>
                    <li>Couvre : 26 lettres minuscules, 26 lettres majuscules, 10 chiffres (0-9), ~33 signes de ponctuation et symboles, et ~33 caractères de contrôle non imprimables.</li>
                     <li>La diapositive mentionne "7 signes de ponctuation soit 69 signes à coder", ce qui semble être une simplification ou une erreur. Le standard ASCII 7 bits définit bien plus que 69 caractères imprimables et de contrôle.</li>
                 </ul>
             </li>
             <li><strong>ASCII étendu utilise 8 bits :</strong>
                <ul>
                    <li>\( 2^8 = 256 \) codes possibles.</li>
                    <li>Les 128 premiers codes (0-127) sont identiques à l'ASCII standard.</li>
                    <li>Les 128 codes suivants (128-255) sont utilisés pour des caractères supplémentaires : lettres accentuées (spécifiques aux langues), symboles graphiques, autres symboles.</li>
                    <li>Attention : Il existe plusieurs variantes d'ASCII étendu (ISO-8859-1, Windows-1252, etc.) qui diffèrent dans l'assignation des caractères pour les codes 128-255. L'UTF-8 est maintenant la norme dominante pour le texte.</li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Page 69: ASCII Example -->
    <div class="slide" id="page69">
         <div class="header-small">Cours d'électronique numérique - Codage</div>
        <h2 class="slide-title">ASCII</h2>
        <p>Exemple de codes ASCII (représentés en hexadécimal sur 7 bits, souvent stockés sur 8 bits avec le bit de poids fort à 0) :</p>
         <table style="margin: 15px auto; text-align: center; border-spacing: 15px 5px;">
            <thead>
                <tr><th>Caractère</th><th>Code Hexadécimal</th></tr>
            </thead>
             <tbody>
                 <tr><td>A</td><td>\( 41_{16} \)</td></tr>
                 <tr><td>E</td><td>\( 45_{16} \)</td></tr>
                 <tr><td>I</td><td>\( 49_{16} \)</td></tr>
                 <tr><td>M</td><td>\( 4D_{16} \)</td></tr>
                 <tr><td>N</td><td>\( 4E_{16} \)</td></tr>
                 <tr><td>Q</td><td>\( 51_{16} \)</td></tr>
                 <tr><td>R</td><td>\( 52_{16} \)</td></tr>
                 <tr><td>U</td><td>\( 55_{16} \)</td></tr>
                 <!-- Ajout pour l'exemple -->
                 <tr><td>(espace)</td><td>\( 20_{16} \)</td></tr>
                 <tr><td>0</td><td>\( 30_{16} \)</td></tr>
                 <tr><td>a</td><td>\( 61_{16} \)</td></tr>
            </tbody>
         </table>

        <p>Codage du mot "NUMERIQUE" en utilisant les codes hexadécimaux ASCII :</p>
        <div class="formula" style="font-size: 1.1em; word-wrap: break-word;">
            N    U    M    E    R    I     Q    U    E <br>
            \( 4E_H \ 55_H \ 4D_H \ 45_H \ 52_H \ 49_H \ 51_H \ 55_H \ 45_H \)
        </div>
        <p>En mémoire, cela serait stocké comme une séquence d'octets (par exemple, en binaire : 01001110 01010101 ...).</p>
    </div>

    <!-- Page 70: Transition to VHDL -->
    <div class="slide" id="page70">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">Conception</h2>
         <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Conception
         </div>
        <p style="text-align: center; margin-top: 20px;">Cette section marque le début de l'étude des méthodes de conception de circuits numériques, probablement en utilisant un langage de description matérielle comme VHDL.</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Section Transition: Introduction to VHDL -->
     <h2 style="text-align:center; margin-top: 40px; color: #003399;">Introduction à VHDL</h2>

    <!-- Page 71: How to Design a Circuit? -->
    <div class="slide" id="page71">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">Comment Concevoir un Circuit ?</h2>
        <p>L'approche pour concevoir un circuit numérique dépend fortement de sa taille et de sa complexité :</p>
        <ul>
            <li>Cela dépend du circuit.</li>
            <li><strong>Petits circuits :</strong> Peuvent être conçus "à la main", en dessinant directement le <strong>schématique</strong> (diagramme des portes logiques et de leurs connexions).</li>
            <li><strong>Circuits moyens :</strong> Peuvent être conçus "à la main" en utilisant des <strong>composants discrets</strong> (circuits intégrés standards contenant quelques portes, bascules, compteurs, etc.) connectés sur une carte de circuit imprimé (PCB).</li>
            <li><strong>Gros circuits</strong> (complexes, des milliers ou millions de portes) : Sont conçus à l'aide de <strong>langages de Description de circuits numériques</strong> (HDL - Hardware Description Languages). Ces langages permettent de décrire le comportement et/ou la structure du circuit de manière textuelle, à un niveau d'abstraction plus élevé.</li>
        </ul>
    </div>

    <!-- Page 72: Hardware Description Languages (HDLs) -->
    <div class="slide" id="page72">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">Les Langages de description</h2>
        <p>Les langages utilisés pour décrire le matériel électronique sont de type HDL :</p>
        <ul>
            <li><strong>Langage de type HDL : Hardware Description Language</strong>. Permet de décrire la structure et le comportement des systèmes électroniques numériques.</li>
            <li>Principaux langages HDL utilisés :
                <ul>
                    <li><strong>VHDL</strong> (VHSIC Hardware Description Language - VHSIC: Very High Speed Integrated Circuits) :
                        <br>Issu d'une volonté (initiée par le département de la Défense américain) d'Industriels et de Chercheurs de définir un langage HDL standardisé pour la documentation, la simulation et la synthèse de circuits.</li>
                    <li><strong>Verilog</strong> :
                         <br>Initialement développé par la société Gateway Design Automation (plus tard acquise par Cadence Design Systems). Très populaire, notamment aux États-Unis et en Asie. Standardisé par l'IEEE.</li>
                    <li><strong>SystemC</strong> :
                         <br>Extension C++ utilisée pour la modélisation au niveau système. Permet de <strong>Mettre au même niveau Logiciel et Matériel</strong> dans la description et la simulation, facilitant la co-conception matériel/logiciel.</li>
                 </ul>
             </li>
        </ul>
        <p>Ce cours se concentrera sur VHDL.</p>
    </div>

    <!-- Page 73: VHDL History and Levels -->
    <div class="slide" id="page73">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">VHDL</h2>
        <ul>
            <li><strong>Historique :</strong> Existe depuis <strong>1987</strong>, date de la première norme IEEE (IEEE 1076-1987). Une révision majeure a eu lieu en <strong>1993</strong> (IEEE 1076-1993), suivie d'autres mises à jour (2000, 2002, 2008, 2019).</li>
            <li>C'est un langage <strong>mûr et couramment utilisé</strong> dans l'industrie et l'enseignement, particulièrement en Europe.</li>
            <li><strong>3 Niveaux (Styles) de Description principaux :</strong> VHDL permet de décrire un circuit à différents niveaux d'abstraction :
                <ul>
                    <li><strong>Niveau Structurel :</strong> Décrit le circuit comme un assemblage de composants interconnectés (comme un schéma-bloc ou un netlist). On décrit "comment c'est fait" en termes de sous-modules.</li>
                    <li><strong>Niveau Flot de Données (Dataflow) :</strong> Décrit comment les données circulent entre les registres et comment elles sont transformées par des opérateurs logiques ou arithmétiques, souvent via des affectations concurrentes de signaux.</li>
                    <li><strong>Niveau Comportemental (Behavioral) :</strong> Décrit le fonctionnement du circuit de manière algorithmique, en utilisant des constructions séquentielles (similaires à un langage de programmation : if/then/else, case, loops). On décrit "ce que ça fait".</li>
                </ul>
                <p>Ces styles peuvent être mélangés au sein d'une même description.</p>
            </li>
        </ul>
    </div>

    <!-- Page 74: VHDL - RTL -->
    <div class="slide" id="page74">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">VHDL - RTL</h2>
        <p>Un niveau de description particulièrement important pour la conception est le niveau RTL :</p>
        <ul>
            <li><strong>RTL : Register Transfer Level</strong> (Niveau Transfert de Registres).</li>
            <li>C'est un style de description (principalement comportemental et flot de données) qui modélise le circuit en termes de :
                <ul>
                    <li>Stockage de données dans des registres (variables mémorisées, souvent synchronisées par une horloge).</li>
                    <li>Transfert de données entre registres.</li>
                    <li>Opérations logiques et arithmétiques effectuées sur ces données entre les transferts.</li>
                </ul>
            </li>
             <li><strong>Description Synthétisable :</strong> L'avantage majeur du style RTL est qu'il correspond à une abstraction qui peut être automatiquement traduite en une structure matérielle (portes logiques, bascules) par un outil logiciel appelé <strong>synthétiseur</strong>. Toutes les constructions VHDL ne sont pas synthétisables, mais celles utilisées au niveau RTL le sont généralement.</li>
             <li><strong>Utilisable pour fondre un circuit :</strong> Le résultat de la synthèse (une netlist de portes) peut ensuite être utilisé pour la fabrication physique du circuit intégré (ASIC) ou la configuration d'un composant programmable (FPGA). ("Fondre" fait référence historiquement à la fabrication des masques pour la photolithographie).</li>
             <li><strong>Utilisée dans ce cours :</strong> Le style RTL sera le principal niveau de description utilisé dans les exemples et exercices VHDL de ce cours, car il est le plus pertinent pour la conception de circuits numériques concrets.</li>
        </ul>
    </div>

    <!-- Page 75: VHDL - Basic Structure -->
    <div class="slide" id="page75">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">VHDL - Base</h2>
        <p>Un fichier de description VHDL typique pour un composant est structuré autour de <strong>3 blocs de base</strong> :</p>
        <ol>
            <li><strong>Les bibliothèques (Library Declarations) :</strong>
                <ul>
                    <li>Permettent d'accéder à des définitions préexistantes (types de données, fonctions, composants...).</li>
                    <li>La bibliothèque `ieee` est standard et fondamentale, notamment pour les types logiques (`std_logic`) et les opérations associées.</li>
                    <li>On utilise les clauses `library` et `use` pour déclarer et rendre visibles les contenus des bibliothèques.</li>
                </ul>
            </li>
            <li><strong>L'entité (Entity) :</strong>
                <ul>
                    <li>Décrit l'<strong>interface</strong> du composant, sa "boîte noire" vue de l'extérieur.</li>
                    <li>Définit le <strong>nom</strong> du composant.</li>
                    <li>Liste les <strong>ports</strong> d'entrée (`in`), de sortie (`out`), bidirectionnels (`inout`) ou tampon (`buffer`), ainsi que leur <strong>type</strong> (ex: `std_logic`, `std_logic_vector`, `integer`...).</li>
                 </ul>
             </li>
             <li><strong>L'architecture (Architecture) :</strong>
                <ul>
                    <li>Décrit le <strong>fonctionnement interne</strong> ou la <strong>structure</strong> du composant défini par l'entité.</li>
                    <li>Il peut y avoir plusieurs architectures pour une même entité (par exemple, une comportementale, une structurelle).</li>
                    <li>Contient le code VHDL (déclarations de signaux internes, affectations concurrentes, processus séquentiels, instanciations de composants...) qui réalise la fonctionnalité désirée.</li>
                </ul>
             </li>
        </ol>
    </div>

    <!-- Page 76: VHDL - Library Example -->
    <div class="slide" id="page76">
         <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">VHDL - Bibliothèque</h2>
        <p>Exemple typique de déclarations de bibliothèques au début d'un fichier VHDL :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all; -- Ou de préférence: use ieee.numeric_std.all;
        </code></pre>
        <ul>
            <li><code>library ieee;</code> : Déclare que nous allons utiliser la bibliothèque standard `ieee`.</li>
            <li><code>use ieee.std_logic_1164.all;</code> : Rend visible tout le contenu (`.all`) du package `std_logic_1164` de la bibliothèque `ieee`. Ce package définit les types fondamentaux `std_logic` et `std_logic_vector` (logique à 9 états : 'U', 'X', '0', '1', 'Z', 'W', 'L', 'H', '-') et les opérateurs logiques de base (and, or, not, xor...).</li>
            <li><code>use ieee.std_logic_unsigned.all;</code> : Rend visible le contenu du package `std_logic_unsigned`. Ce package (non standard mais très répandu, fourni par Synopsys) permet de réaliser des opérations arithmétiques directement sur des vecteurs `std_logic_vector` en les interprétant comme des nombres non signés.
                <br><strong>Note :</strong> La norme VHDL plus récente recommande l'utilisation du package standard `ieee.numeric_std.all` qui fournit les types `unsigned` et `signed` et les opérations associées, offrant une meilleure gestion des types et de la sémantique arithmétique. Cependant, `std_logic_unsigned` est encore vu dans du code plus ancien.
            </li>
        </ul>
    </div>

    <!-- Page 77: VHDL - Entity Example -->
    <div class="slide" id="page77">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">VHDL - Entité</h2>
        <p>Exemple de déclaration d'une entité pour une porte ET (AND) simple avec deux entrées A, B et une sortie S :</p>
        <pre><code class="language-vhdl">
entity MON_ET is
    port(
        A : in  std_logic;  -- Port d'entrée A de type std_logic
        B : in  std_logic;  -- Port d'entrée B de type std_logic
        S : out std_logic   -- Port de sortie S de type std_logic
    );
end entity MON_ET;
        </code></pre>
        <ul>
            <li><code>entity MON_ET is ... end entity MON_ET;</code> : Définit un bloc d'entité nommé `MON_ET`.</li>
            <li><code>port(...)</code> : Déclare la liste des ports.</li>
            <li><code>A : in std_logic;</code> : Définit un port nommé `A`, de direction `in` (entrée) et de type `std_logic`. Les déclarations de port se terminent par un point-virgule.</li>
             <li><code>S : out std_logic</code> : Définit un port nommé `S`, de direction `out` (sortie) et de type `std_logic`. Notez l'absence de point-virgule après la dernière déclaration de port dans la liste.</li>
        </ul>
        <p>Cette entité définit l'interface du composant "MON_ET".</p>
    </div>

    <!-- Page 78: VHDL - Architecture Example -->
    <div class="slide" id="page78">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">VHDL - L'architecture</h2>
        <p>Exemple d'une architecture de style "Flot de Données" (Dataflow) pour l'entité `MON_ET` définie précédemment, réalisant la fonction ET logique :</p>
        <p>Fonction logique à réaliser : \( S = A \text{ et } B \)</p>
        <pre><code class="language-vhdl">
architecture FLOT of MON_ET is
begin
    S <= A and B; -- Affectation concurrente du signal S
end architecture FLOT;
        </code></pre>
        <ul>
             <li><code>architecture FLOT of MON_ET is ... end architecture FLOT;</code> : Définit un bloc d'architecture nommé `FLOT`, associé à l'entité `MON_ET`.</li>
             <li>La partie entre `is` et `begin` est utilisée pour les déclarations locales à l'architecture (signaux internes, constantes, types, fonctions, procédures, composants...). Ici, elle est vide.</li>
             <li><code>begin ... end architecture;</code> : Délimite le corps de l'architecture, contenant les instructions concurrentes qui décrivent le comportement ou la structure.</li>
            <li><code>S <= A and B;</code> : C'est une instruction d'<strong>affectation concurrente de signal</strong>. Elle signifie que la valeur du signal `S` est mise à jour à chaque fois que la valeur de `A` ou de `B` change, avec le résultat de l'opération logique `A and B`. L'opérateur `<=` est utilisé pour l'affectation de signaux.</li>
         </ul>
         <p>Cette architecture décrit comment calculer la sortie `S` à partir des entrées `A` et `B` de manière continue (concurrentielle).</p>
    </div>

    <!-- Page 79: Design Flow -->
    <div class="slide" id="page79">
         <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">Flot de conception (Design Flow)</h2>
        <p>Le processus typique pour passer d'une description HDL à un circuit physique ou configuré :</p>
        <ol>
            <li><strong>Description / Spécification :</strong> Définir ce que le circuit doit faire.</li>
            <li><strong>Codage HDL :</strong> Décrire le circuit en VHDL (ou Verilog) au niveau RTL ou comportemental.</li>
             <li><strong>Simulation Fonctionnelle :</strong> Simuler le code HDL pour vérifier qu'il correspond au comportement attendu (vérification logique, indépendante de la technologie cible). Création de "testbenches" pour appliquer des stimuli et observer les sorties.</li>
             <li><strong>Synthèse logique :</strong> Traduire la description HDL (RTL) en une liste de connexions de composants logiques élémentaires (portes, bascules) spécifiques à une technologie cible (bibliothèque de cellules standards pour un ASIC, ou ressources logiques d'un FPGA). L'outil de synthèse optimise le circuit (surface, vitesse, consommation).</li>
             <li><strong>Simulation Post-Synthèse (Gate-Level Simulation) :</strong> Simuler la netlist de portes générée par la synthèse, en incluant éventuellement des estimations de délais, pour vérifier que la fonctionnalité est préservée et que les performances temporelles préliminaires sont correctes.</li>
             <li><strong>Placement et Routage (Place & Route) :</strong>
                 <ul>
                     <li><strong>Placement :</strong> Déterminer la position physique de chaque composant logique (cellule) sur la puce (ASIC) ou dans les blocs logiques (FPGA).</li>
                     <li><strong>Routage :</strong> Dessiner les interconnexions (pistes métalliques) entre les composants placés.</li>
                 </ul>
                Cette étape est cruciale pour les performances finales (délais de propagation dans les fils).
            </li>
             <li><strong>Simulation Post-Layout (Timing Simulation) :</strong> Simuler le circuit en incluant les délais précis extraits après le placement et le routage pour une vérification temporelle finale.</li>
            <li><strong>Génération des fichiers de fabrication/configuration :</strong>
                <ul>
                    <li>ASIC : Réaliser les <strong>masques</strong> (photomasques) pour les différentes étapes de fabrication (lithographie).</li>
                    <li>FPGA : Générer le fichier de configuration ("bitstream") qui sera chargé dans le FPGA pour implémenter le circuit.</li>
                 </ul>
             </li>
             <li><strong>Fabrication / Configuration :</strong>
                 <ul>
                     <li>ASIC : "<strong>Cuisson</strong>" (fabrication des wafers de silicium en salle blanche).</li>
                    <li>FPGA : Chargement du bitstream dans le composant.</li>
                 </ul>
             </li>
            <li><strong>Test :</strong> Vérifier le circuit fabriqué/configuré.</li>
        </ol>
        <p>(La diapositive simplifie un peu ce flot complexe).</p>
    </div>

    <!-- Page 80: HDL Applications -->
    <div class="slide" id="page80">
        <div class="header-small">Cours d'électronique numérique - Introduction à VHDL</div>
        <h2 class="slide-title">Langage HDL, a quoi ça sert ?</h2>
        <p>Les langages de description matérielle comme VHDL sont utilisés pour plusieurs tâches essentielles dans le domaine de l'électronique numérique :</p>
        <ul>
            <li><strong>À la conception d'ASIC</strong> (Application-Specific Integrated Circuit) :
                 <ul>
                     <li>Permet de décrire des circuits intégrés complexes sur mesure, optimisés pour une application spécifique.</li>
                     <li>Le code HDL est synthétisé, placé et routé pour générer les masques nécessaires à la fabrication.</li>
                 </ul>
            </li>
             <li><strong>À la programmation de FPGA</strong> (Field-Programmable Gate Array) :
                <ul>
                    <li>Les FPGA sont des circuits intégrés contenant une matrice de blocs logiques et d'interconnexions configurables.</li>
                    <li>Le code HDL est synthétisé, placé et routé pour générer un fichier de configuration (bitstream) qui programme le FPGA pour réaliser la fonctionnalité décrite.</li>
                    <li>Permet un prototypage rapide et une reconfigurabilité.</li>
                    <li><em>(Sera abordé dans le cours SSN - Systèmes Séquentiels Numériques, ou un cours similaire sur les FPGA).</em></li>
                </ul>
            </li>
            <li><strong>À la vérification fonctionnelle de circuits numériques :</strong>
                <ul>
                     <li>Les HDL sont massivement utilisés pour créer des environnements de simulation complexes (testbenches).</li>
                     <li>Ces testbenches génèrent des stimuli pour le circuit sous test (DUT - Design Under Test), vérifient ses sorties par rapport à un modèle de référence, et rapportent les erreurs.</li>
                     <li>La vérification est une part majeure (souvent >50%) de l'effort de conception d'un circuit complexe.</li>
                </ul>
            </li>
        </ul>
    </div>
    <!-- Continuing the document... -->

    <!-- Section Transition: Combinational Logic -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Logique Combinatoire</h2>

    <!-- Page 81: Combinational Logic Title -->
    <div class="slide" id="page81">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire</h2>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Logique Combinatoire
        </div>
         <p style="text-align: center; margin-top: 20px;">Cette section applique les concepts de l'algèbre de Boole à la conception de circuits électroniques dont la sortie ne dépend que de l'état actuel des entrées.</p>
    </div>

    <!-- Page 82: Link Boolean Algebra to Electronics -->
    <div class="slide" id="page82">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire</h2>
        <ul>
            <li><strong>Transposition de l'algèbre de Boole à l'électronique :</strong>
                <ul>
                    <li>Les concepts de l'algèbre de Boole (variables Vrai/Faux ou 1/0, opérations ET/OU/NON) peuvent être directement implémentés avec des circuits électroniques.</li>
                </ul>
            </li>
            <li>Rendu possible grâce à des composants électroniques comme le <strong>transistor</strong> (utilisé comme un interrupteur commandé).
                 <ul>
                     <li>Un transistor peut être "passant" (ON, représentant par exemple un '1' ou un niveau de tension HAUT) ou "bloqué" (OFF, représentant un '0' ou un niveau de tension BAS), en fonction d'une <strong>tension de commande</strong> appliquée à son entrée (grille ou base).</li>
                     <li>En combinant des transistors, on peut réaliser les fonctions logiques de base (portes NON, ET, OU, NAND, NOR...).</li>
                 </ul>
             </li>
             <li>Le domaine de validité de ce qui suit est l'<strong>électronique numérique</strong> : on travaille avec des signaux représentant des valeurs discrètes (typiquement 0 et 1), implémentées par des niveaux de tension définis (par exemple, 0V pour '0' et 5V ou 3.3V pour '1').</li>
        </ul>
    </div>

    <!-- Page 83: Definition of Combinational Logic -->
    <div class="slide" id="page83">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire</h2>
        <p><strong>Définition :</strong></p>
        <p>
            Un circuit électronique est dit <strong>combinatoire</strong> si ses <strong>sorties</strong> ( \( s_1, \dots, s_m \) ) à un instant donné sont <strong>uniquement déterminées</strong> par la <strong>combinaison</strong> actuelle de ses <strong>variables d'entrées</strong> ( \( e_1, \dots, e_n \) ), et ceci après un certain <strong>temps fini</strong> (appelé délai de propagation).
        </p>
        <p>
             Autrement dit, l'état des sorties ne dépend <strong>pas</strong> de l'historique des entrées passées ni d'un état interne mémorisé. Le circuit n'a pas de mémoire.
        </p>
         <p>
             L'état d'un système combinatoire est donc défini à tout instant (après stabilisation) par la combinaison actuelle des variables d'entrée \( e_1, \dots, e_i, \dots, e_n \).
        </p>
        <p>Chaque sortie peut être exprimée comme une fonction booléenne des entrées : \( s_j = f_j(e_1, \dots, e_n) \).</p>
    </div>

    <!-- Page 84: Combinational Circuit Diagram -->
    <div class="slide" id="page84">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire</h2>
        <p>Représentation schématique d'un circuit combinatoire :</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_combinational_circuit.png" alt="Diagramme d'un circuit combinatoire avec entrées e1..en et sorties s1..sm" style="border: 1px solid #ccc; padding: 20px; max-width: 400px; background-color: #f8f8f8;">
            <p style="color: #666;">[Placeholder for Combinational Circuit Diagram]</p>
        </div>
        <ul>
            <li>Entrées : \( e_1, \dots, e_i, \dots, e_n \)</li>
            <li>Sorties : \( s_1, \dots, s_j, \dots, s_m \)</li>
            <li>\( t_p \) : Délai de propagation (temps nécessaire pour que les sorties se stabilisent après un changement des entrées).</li>
            <li>Le circuit interne est constitué d'un réseau de portes logiques (ET, OU, NON, etc.) sans boucle de rétroaction (feedback) qui créerait une mémorisation.</li>
        </ul>
    </div>

    <!-- Page 85: Timing Hazards -->
    <div class="slide" id="page85">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Les Aléas Temporels (Hazards)</h2>
        <p>Un problème potentiel dans les circuits combinatoires concerne les aléas temporels.</p>
        <ul>
            <li>Considérons l'expression \( a + \bar{a} \). En algèbre de Boole, \( a + \bar{a} = 1 \).</li>
            <li>Cependant, dans un circuit réel, le signal \( a \) et son complément \( \bar{a} \) (produit par un inverseur) peuvent ne pas changer exactement au même moment en raison des délais de propagation différents dans les portes.</li>
            <li>Si \( a \) passe de 0 à 1, il peut y avoir un très court instant où \( a \) et \( \bar{a} \) sont tous les deux à 0 (si l'inverseur est plus lent à réagir). Durant cet instant, la sortie du circuit implémentant \( a + \bar{a} \) pourrait brièvement passer à 0 avant de revenir à 1. C'est un <strong>aléa statique</strong> (la sortie devrait rester stable à 1, mais présente un glitch).</li>
             <li>La question \( a + \bar{a} = 0? \) sur la diapositive est rhétorique et pointe vers ce phénomène : est-il possible que cette expression, qui devrait toujours être 1, vaille momentanément 0 ? Oui, à cause des délais.</li>
             <li>De même, pour \( a \cdot \bar{a} = 0 \), un aléa pourrait faire que la sortie passe brièvement à 1 lors d'une transition de \( a \).</li>
        </ul>
        <p>Les aléas sont des changements de sortie transitoires non désirés qui se produisent lors d'un changement des variables d'entrée. Ils peuvent être problématiques, notamment s'ils sont utilisés comme signal d'horloge ou de validation pour un circuit séquentiel.</p>
        <p>La conception de circuits combinatoires robustes implique souvent des techniques pour détecter et éliminer ces aléas (par exemple, en utilisant des termes redondants issus des regroupements dans les tableaux de Karnaugh).</p>
    </div>

    <!-- Page 86: Basic Operators - Single Variable -->
    <div class="slide" id="page86">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire - Opérateurs de base</h2>
        <p>Implémentation des fonctions logiques de base avec des portes électroniques.</p>
        <p><strong>Fonctions à une variable :</strong></p>
        <ul>
            <li><strong>Buffer (Identité) :</strong> \( s = a \)
                <ul>
                     <li>La sortie recopie l'entrée.</li>
                     <li>Utile pour amplifier un signal, adapter des impédances, ou introduire un délai contrôlé.</li>
                     <li>Symboles (Norme US ANSI/IEEE à gauche, Norme IEC/Européenne à droite) :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_buffer_symbols.png" alt="Symboles ANSI et IEC pour un buffer" style="vertical-align: middle; max-height: 50px;">
                         <span style="color: #666;">[Placeholder: Buffer Symbols ANSI/IEC]</span>
                    </li>
                 </ul>
             </li>
             <li><strong>Inverseur (NON / NOT) :</strong> \( s = \bar{a} \)
                <ul>
                    <li>La sortie est le complément logique de l'entrée.</li>
                    <li>Symboles :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_inverter_symbols.png" alt="Symboles ANSI et IEC pour un inverseur" style="vertical-align: middle; max-height: 50px;">
                         <span style="color: #666;">[Placeholder: Inverter Symbols ANSI/IEC]</span>
                         <br>(Le petit cercle sur le symbole indique l'inversion logique).
                    </li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Page 87: Basic Operators - AND/NAND -->
    <div class="slide" id="page87">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire - Opérateurs de base</h2>
        <p><strong>Fonctions à deux variables (Exemples) :</strong></p>
         <ul>
            <li><strong>ET (AND) :</strong> \( s = a \cdot b \)
                 <ul>
                     <li>La sortie est 1 si et seulement si les deux entrées sont à 1.</li>
                     <li>Symboles :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_and_symbols.png" alt="Symboles ANSI et IEC pour une porte ET" style="vertical-align: middle; max-height: 60px;">
                         <span style="color: #666;">[Placeholder: AND gate Symbols ANSI/IEC]</span>
                         <br>(Le symbole '&' dans le rectangle IEC représente la fonction ET).
                     </li>
                 </ul>
             </li>
             <li><strong>NON-ET (NAND) :</strong> \( s = \overline{a \cdot b} \)
                 <ul>
                     <li>La sortie est 0 si et seulement si les deux entrées sont à 1 (inverse de ET).</li>
                     <li>Les portes NAND sont universelles (on peut réaliser toutes les autres fonctions logiques uniquement avec des portes NAND).</li>
                     <li>Symboles (Porte ET suivie d'un inverseur) :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_nand_symbols.png" alt="Symboles ANSI et IEC pour une porte NON-ET" style="vertical-align: middle; max-height: 60px;">
                         <span style="color: #666;">[Placeholder: NAND gate Symbols ANSI/IEC]</span>
                         <br>(Notez le cercle d'inversion en sortie).
                    </li>
                 </ul>
             </li>
        </ul>
    </div>

    <!-- Page 88: Basic Operators - OR/NOR -->
    <div class="slide" id="page88">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire - Opérateurs de base</h2>
        <p><strong>Fonctions à deux variables (Suite) :</strong></p>
         <ul>
            <li><strong>OU (OR) :</strong> \( s = a + b \)
                 <ul>
                     <li>La sortie est 1 si au moins une des entrées est à 1.</li>
                     <li>Symboles :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_or_symbols.png" alt="Symboles ANSI et IEC pour une porte OU" style="vertical-align: middle; max-height: 60px;">
                         <span style="color: #666;">[Placeholder: OR gate Symbols ANSI/IEC]</span>
                         <br>(Le symbole '≥1' dans le rectangle IEC représente la fonction OU).
                     </li>
                 </ul>
             </li>
             <li><strong>NON-OU (NOR) :</strong> \( s = \overline{a + b} \)
                 <ul>
                     <li>La sortie est 1 si et seulement si les deux entrées sont à 0 (inverse de OU).</li>
                    <li>Les portes NOR sont également universelles.</li>
                    <li>Symboles (Porte OU suivie d'un inverseur) :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_nor_symbols.png" alt="Symboles ANSI et IEC pour une porte NON-OU" style="vertical-align: middle; max-height: 60px;">
                         <span style="color: #666;">[Placeholder: NOR gate Symbols ANSI/IEC]</span>
                         <br>(Notez le cercle d'inversion en sortie).
                    </li>
                 </ul>
             </li>
        </ul>
    </div>

    <!-- Page 89: Basic Operators - XOR/XNOR -->
    <div class="slide" id="page89">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Logique Combinatoire - Opérateurs de base</h2>
        <p><strong>Fonctions à deux variables (Fin) :</strong></p>
        <ul>
            <li><strong>OU-EXCLUSIF (XOR) :</strong> \( s = a \oplus b = a\bar{b} + \bar{a}b \)
                 <ul>
                    <li>La sortie est 1 si les entrées sont différentes.</li>
                    <li>Symboles :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_xor_symbols.png" alt="Symboles ANSI et IEC pour une porte OU-EXCLUSIF" style="vertical-align: middle; max-height: 60px;">
                         <span style="color: #666;">[Placeholder: XOR gate Symbols ANSI/IEC]</span>
                          <br>(Le symbole '=1' dans le rectangle IEC signifie "sortie à 1 si un nombre impair d'entrées est à 1").
                     </li>
                 </ul>
            </li>
            <li><strong>NON-OU-EXCLUSIF (XNOR) / Équivalence :</strong> \( s = \overline{a \oplus b} = ab + \bar{a}\bar{b} \)
                <ul>
                    <li>La sortie est 1 si les entrées sont identiques.</li>
                     <li>Symboles (Porte XOR suivie d'un inverseur) :</li>
                     <li style="list-style: none; margin-top: 10px;">
                         <img src="placeholder_xnor_symbols.png" alt="Symboles ANSI et IEC pour une porte NON-OU-EXCLUSIF" style="vertical-align: middle; max-height: 60px;">
                         <span style="color: #666;">[Placeholder: XNOR gate Symbols ANSI/IEC]</span>
                         <br>(Notez le cercle d'inversion en sortie).
                    </li>
                </ul>
            </li>
        </ul>
        <p>(Note: l'équation pour XNOR dans l'OCR était incorrecte, elle a été corrigée : \( \overline{a \oplus b} = ab + \bar{a}\bar{b} \))</p>
    </div>

    <!-- Page 90: Transition to Complex Combinational Functions -->
    <div class="slide" id="page90">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Plan du Cours</h2>
         <p>Progression dans le plan du cours :</p>
         <ul>
             <li>Introduction</li>
             <li>Algèbre de Boole et Logique Combinatoire</li>
             <li>Introduction au VHDL</li>
             <li>Fonctions Combinatoire Simples <span style="color: #666;">(Opérateurs de base vus)</span></li>
             <li><strong style="color: #dc3545;">Fonctions Combinatoires Complexes</strong> <span style="color: #666;">(Prochaine section)</span></li>
             <li>Fonctions Séquentielles Simples</li>
             <li>Fonctions Séquentielles Complexes</li>
             <li>Pipeline</li>
             <li>Technologie des circuits numériques</li>
             <li>Les Convertisseurs Analogiques-Numériques et Numériques-Analogiques</li>
        </ul>
         <p>La section suivante abordera des circuits combinatoires plus élaborés (additionneurs, multiplexeurs, décodeurs...).</p>
    </div>

    <!-- Continuing the document... -->

    <!-- Section Transition: Complex Combinational Functions -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Fonctions Combinatoires Complexes</h2>

    <!-- Page 91: Complex Combinational Functions Title -->
    <div class="slide" id="page91">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Fonctions Combinatoires Complexes</h2>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Fonctions Combinatoires Complexes
        </div>
        <p style="text-align: center; margin-top: 20px;">Cette section explore des blocs de construction combinatoires plus élaborés, utilisés fréquemment dans la conception de systèmes numériques.</p>
    </div>

    <!-- Page 92: Introduction to Complex Functions -->
    <div class="slide" id="page92">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Introduction</h2>
        <p>Les fonctions combinatoires complexes sont des circuits qui réalisent des opérations logiques plus sophistiquées que les portes de base.</p>
        <ul>
            <li>Elles sont <strong>composées à partir des opérateurs de base</strong> (ET, OU, NON, XOR...).</li>
            <li>Elles servent souvent au <strong>conditionnement de données</strong> (mise en forme, sélection, routage).</li>
             <li>Elles permettent le <strong>contrôle de données</strong> (activation/désactivation de chemins de données, comparaison).</li>
             <li>Comme toute fonction combinatoire, elles sont complètement <strong>définies par leur table de vérité</strong> (ou une expression booléenne équivalente, un schéma logique, etc.).</li>
        </ul>
        <p>Exemples courants : comparateurs, multiplexeurs, démultiplexeurs, encodeurs, décodeurs, additionneurs, etc.</p>
    </div>

    <!-- Page 93: Equality Function (2 bits) -->
    <div class="slide" id="page93">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Fonction Egalité</h2>
        <p>Un comparateur d'égalité vérifie si deux entrées (ou deux mots binaires) sont identiques.</p>
        <p><strong>Egalité 2 bits :</strong> Comparaison de deux bits uniques \( a \) et \( b \).</p>
        <ul>
            <li>La sortie \( s \) doit être 1 si \( a = b \), et 0 sinon.</li>
        </ul>
        <p>Table de vérité :</p>
        <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
             <thead>
                 <tr><th style="padding: 5px;">\( a \)</th><th style="padding: 5px;">\( b \)</th><th style="padding: 5px; border-left: 2px solid black;">\( s \)</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">1</td></tr>
                 <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td></tr>
                 <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">0</td></tr>
                 <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td></tr>
             </tbody>
        </table>
        <p>L'expression logique correspondante est celle de la fonction NON-OU-EXCLUSIF (XNOR) :</p>
        <div class="formula">
             \( s = \overline{a \oplus b} = ab + \bar{a}\bar{b} \)
        </div>
    </div>

    <!-- Page 94: Equality Function (2 bits) - VHDL -->
    <div class="slide" id="page94">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Egalité - VHDL</h2>
        <p>Code VHDL pour le comparateur d'égalité de 2 bits (fonction XNOR) :</p>
         <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour le comparateur d'égalité 1 bit
entity egalite_1bit is
    port(
        a, b : in  std_logic;     -- Entrées à comparer
        s    : out std_logic      -- Sortie (1 si a=b, 0 sinon)
    );
end entity egalite_1bit; -- Nom modifié pour clarté

-- Architecture utilisant l'opérateur XNOR implicite (NOT XOR)
architecture flot of egalite_1bit is
begin
    -- s vaut '1' si a et b sont égaux, '0' sinon.
    -- a xnor b  est équivalent à not(a xor b)
    s <= not (a xor b);
end architecture flot;
        </code></pre>
        <p>Cette architecture utilise directement l'opérateur `xor` suivi de `not` pour implémenter la fonction XNOR, qui correspond à l'égalité.</p>
        <p><em>(Note: Le nom de l'entité a été légèrement modifié pour indiquer qu'il s'agit d'une comparaison 1-bit pour éviter la confusion avec l'exemple suivant).</em></p>
    </div>

    <!-- Page 95: Equality Function (2x2 bits) -->
    <div class="slide" id="page95">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Fonction Egalité</h2>
        <p><strong>Egalité 2 mots de 2 bits :</strong></p>
        <ul>
            <li>On compare deux mots \( a \) et \( b \), chacun composé de 2 bits : \( a = a_1a_0 \) et \( b = b_1b_0 \).</li>
            <li>La sortie \( s \) doit être 1 si \( a = b \), c'est-à-dire si \( a_1 = b_1 \) <strong>ET</strong> \( a_0 = b_0 \).</li>
        </ul>
        <p>Tableau de Karnaugh pour la fonction \( s(a_1, a_0, b_1, b_0) \). Les lignes représentent \(a_1a_0\), les colonnes \(b_1b_0\), en code Gray.</p>
        <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
             <thead>
                 <tr>
                     <th rowspan="2" style="padding: 5px;">\( a_1a_0 \setminus b_1b_0 \)</th>
                     <th colspan="4" style="padding: 5px;">\( b_1b_0 \)</th>
                 </tr>
                 <tr>
                     <th style="padding: 5px;">00</th> <th style="padding: 5px;">01</th> <th style="padding: 5px;">11</th> <th style="padding: 5px;">10</th>
                 </tr>
             </thead>
             <tbody>
                <tr><th style="padding: 5px;">00</th><td style="background-color: #ccffcc;">1</td><td>0</td><td>0</td><td>0</td></tr>
                <tr><th style="padding: 5px;">01</th><td>0</td><td style="background-color: #ccffcc;">1</td><td>0</td><td>0</td></tr>
                <tr><th style="padding: 5px;">11</th><td>0</td><td>0</td><td style="background-color: #ccffcc;">1</td><td>0</td></tr>
                <tr><th style="padding: 5px;">10</th><td>0</td><td>0</td><td>0</td><td style="background-color: #ccffcc;">1</td></tr>
             </tbody>
        </table>
        <p>Les '1' (en vert) apparaissent uniquement lorsque la combinaison \(a_1a_0\) est identique à la combinaison \(b_1b_0\). Il n'y a pas de regroupements possibles dans ce K-Map (chaque '1' est isolé).</p>
        <p>Expression logique dérivée de la condition \( (a_1 = b_1) \text{ ET } (a_0 = b_0) \) :</p>
        <div class="formula">
            \( s = (\overline{a_1 \oplus b_1}) \cdot (\overline{a_0 \oplus b_0}) \)
        </div>
        <p><em>(L'OCR sur la diapositive a une erreur dans la formule, utilisant \(a_1 \oplus b_1\) au lieu de \(\overline{a_1 \oplus b_1}\)).</em></p>

        <p><strong>Egalité de 2 mots de n bits :</strong> Généralisation</p>
        <ul>
            <li>Soient \( a = a_{n-1}...a_0 \) et \( b = b_{n-1}...b_0 \).</li>
            <li>Les deux mots sont égaux si et seulement si tous les bits correspondants sont égaux : \( a_i = b_i \) pour tout \( i \) de 0 à \( n-1 \).</li>
            <li>L'expression logique est le produit (ET) des comparaisons d'égalité de chaque paire de bits :</li>
        </ul>
         <div class="formula">
            \( s = (\overline{a_{n-1} \oplus b_{n-1}}) \cdot (\overline{a_{n-2} \oplus b_{n-2}}) \cdot \dots \cdot (\overline{a_1 \oplus b_1}) \cdot (\overline{a_0 \oplus b_0}) \)
            <br>
            \( s = \prod_{i=0}^{n-1} (\overline{a_i \oplus b_i}) \)
        </div>
         <p><em>(Encore une fois, l'OCR sur la diapositive a une erreur, omettant la négation sur les XOR).</em></p>
    </div>

    <!-- Page 96: Equality Function (2x2 bits) - VHDL -->
    <div class="slide" id="page96">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Egalité - VHDL</h2>
        <p>Code VHDL pour le comparateur d'égalité de deux mots de 2 bits ( \( a=a_1a_0, b=b_1b_0 \) ) :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour le comparateur d'égalité 2 bits
entity egalite_2bits is
    port(
        a, b : in  std_logic_vector(1 downto 0); -- Mots de 2 bits en entrée
        s    : out std_logic                     -- Sortie (1 si a=b, 0 sinon)
    );
end entity egalite_2bits;

-- Architecture "flot de données" basée sur la formule logique
architecture flot of egalite_2bits is
begin
    -- s = (a1=b1) AND (a0=b0)
    -- s = (NOT(a1 XOR b1)) AND (NOT(a0 XOR b0))
    s <= not (a(1) xor b(1)) and not (a(0) xor b(0));
end architecture flot;
        </code></pre>
        <ul>
            <li><code>std_logic_vector(1 downto 0)</code> : Définit les entrées `a` et `b` comme des vecteurs de 2 bits, indexés 1 (MSB) et 0 (LSB).</li>
            <li><code>a(1)</code> accède au bit 1 du vecteur `a`, <code>a(0)</code> accède au bit 0.</li>
            <li>L'architecture implémente directement la formule \( s = (\overline{a_1 \oplus b_1}) \cdot (\overline{a_0 \oplus b_0}) \).</li>
        </ul>
    </div>

    <!-- Page 97: Equality Function - Alternative VHDL -->
    <div class="slide" id="page97">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Egalité - VHDL</h2>

        <div style="background-color: #ffdddd; border: 2px solid red; padding: 10px; margin-bottom: 15px;">
             <strong>VHDL après l'UE LE201</strong><br>
             Ce que peut faire VHDL<br>
             Hors du cadre du cours LE201 (Probablement car utilise un process et une comparaison directe de vecteurs)
        </div>

        <p>Une manière alternative et plus abstraite d'écrire le comparateur d'égalité en VHDL, utilisant un style comportemental (process) et l'opérateur d'égalité prédéfini pour les `std_logic_vector` :</p>

        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

entity egalite_2bits is -- Même entité que précédemment
    port(
        a, b : in  std_logic_vector(1 downto 0);
        s    : out std_logic
    );
end entity egalite_2bits;

-- Architecture comportementale utilisant un process
architecture comp of egalite_2bits is
begin
    -- Un process est sensible aux signaux listés entre parenthèses
    -- Il s'exécute chaque fois qu'un de ces signaux change
    process(a, b) is
    begin
        -- Comparaison directe des vecteurs a et b
        if a = b then
            s <= '1'; -- Si égaux, sortie s = 1
        else
            s <= '0'; -- Sinon, sortie s = 0
        end if;
    end process;
end architecture comp;
        </code></pre>
        <ul>
             <li>Cette approche est plus concise et plus proche de la spécification fonctionnelle.</li>
             <li>L'outil de synthèse est capable de traduire cette description comportementale en un circuit logique équivalent (probablement basé sur des portes XNOR et AND, comme dans l'architecture `flot`).</li>
             <li>Elle est mentionnée comme étant "Hors du cadre du cours LE201", suggérant que ce cours se concentre peut-être davantage sur le style flot de données ou structurel, ou que les `process` sont vus plus tard.</li>
        </ul>
    </div>

    <!-- Page 98: Multiplexers Introduction -->
    <div class="slide" id="page98">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs</h2>
        <p>Un <strong>Multiplexeur</strong> (MUX) est un circuit combinatoire qui agit comme un <strong>aiguillage</strong> de données.</p>
        <ul>
            <li>Fonction principale : Sélectionner <strong>une</strong> parmi plusieurs entrées de données et la recopier sur une unique sortie.</li>
            <li><strong>Une commande choisit l'entrée :</strong> Le choix de l'entrée à connecter à la sortie est déterminé par la valeur appliquée sur des entrées de commande (ou de sélection).</li>
            <li><strong>Entrée choisie recopiée sur la sortie :</strong> La valeur logique de l'entrée de données sélectionnée apparaît sur la sortie du multiplexeur (après un délai de propagation).</li>
        </ul>
        <p>Structure typique d'un multiplexeur \( n \) vers 1 :</p>
        <ul>
            <li><strong>Partie Commande :</strong> \( p \) bits de sélection. Ces \( p \) bits permettent de coder \( 2^p \) combinaisons différentes.</li>
            <li><strong>Partie Donnée :</strong> \( n = 2^p \) entrées de données, et 1 sortie de données.</li>
        </ul>
        <p>Un multiplexeur est souvent appelé un sélecteur de données.</p>
         <div style="text-align: center; margin-top: 15px;">
             <img src="placeholder_mux_symbol.png" alt="Symbole générique d'un multiplexeur N vers 1" style="vertical-align: middle; max-height: 80px;">
             <span style="color: #666;">[Placeholder: Generic MUX Symbol]</span>
        </div>
    </div>

    <!-- Page 99: 2-to-1 Multiplexer Truth Table (K-Map style) -->
    <div class="slide" id="page99">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs 2 vers 1 - Table de vérité</h2>
        <p>Un multiplexeur 2 vers 1 possède :</p>
        <ul>
            <li>2 entrées de données : \( a \) (entrée 0), \( b \) (entrée 1).</li>
            <li>1 entrée de sélection : \( sel \).</li>
            <li>1 sortie : \( s \).</li>
        </ul>
        <p>Fonctionnement :</p>
        <ul>
            <li>Si \( sel = 0 \), alors \( s = a \).</li>
            <li>Si \( sel = 1 \), alors \( s = b \).</li>
        </ul>
        <p>Table de vérité (représentée ici sous forme de K-Map avec \(a, b\) en lignes/colonnes et \(sel\) comme variable de décision) :</p>
         <table border="1" style="border-collapse: collapse; text-align: center; margin: 15px auto;">
             <thead>
                 <tr>
                    <th rowspan="2" style="padding: 5px;">\( sel \setminus ab \)</th>
                    <th colspan="4" style="padding: 5px;">\( ab \)</th>
                 </tr>
                 <tr>
                    <th style="padding: 5px;">00</th> <th style="padding: 5px;">01</th> <th style="padding: 5px;">11</th> <th style="padding: 5px;">10</th>
                 </tr>
             </thead>
             <tbody>
                 <!-- Ligne sel = 0 -->
                <tr><th style="padding: 5px;">0</th>
                    <td>0</td> <!-- a=0, b=0 -> s=a=0 -->
                    <td>0</td> <!-- a=0, b=1 -> s=a=0 -->
                    <td style="background-color: #ccffcc;">1</td> <!-- a=1, b=1 -> s=a=1 -->
                    <td style="background-color: #ccffcc;">1</td> <!-- a=1, b=0 -> s=a=1 -->
                </tr>
                 <!-- Ligne sel = 1 -->
                <tr><th style="padding: 5px;">1</th>
                    <td>0</td> <!-- a=0, b=0 -> s=b=0 -->
                    <td style="background-color: #ccccff;">1</td> <!-- a=0, b=1 -> s=b=1 -->
                    <td style="background-color: #ccccff;">1</td> <!-- a=1, b=1 -> s=b=1 -->
                    <td>0</td> <!-- a=1, b=0 -> s=b=0 -->
                 </tr>
            </tbody>
        </table>
        <p>Dérivation de l'équation logique :</p>
        <ul>
            <li>Quand \( sel = 0 \) (donc \( \overline{sel} = 1 \)), la sortie \( s \) doit être \( a \). Terme : \( \overline{sel} \cdot a \).</li>
            <li>Quand \( sel = 1 \), la sortie \( s \) doit être \( b \). Terme : \( sel \cdot b \).</li>
        </ul>
         <p>La sortie globale est la somme (OU) de ces deux conditions :</p>
        <div class="formula">
             \( s = \overline{sel} \cdot a + sel \cdot b \)
        </div>
         <p><em>(Note: Le K-Map sur la diapositive originale est une représentation non standard et potentiellement confuse de la table de vérité du MUX. La table ci-dessus est un K-Map classique pour s(sel, a, b). L'équation déduite est correcte.)</em></p>
    </div>

    <!-- Page 100: 2-to-1 Multiplexer Schematic -->
    <div class="slide" id="page100">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs 2 vers 1</h2>
        <p><strong>Schéma logique</strong> implémentant l'équation \( s = \overline{sel} \cdot a + sel \cdot b \) :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_mux2to1_schematic.png" alt="Schéma logique d'un multiplexeur 2 vers 1 utilisant des portes AND, OR et NOT" style="border: 1px solid #ccc; padding: 10px; max-width: 350px;">
             <p style="color: #666;">[Placeholder for MUX 2-to-1 Schematic]</p>
         </div>
        <p>Le circuit comprend :</p>
        <ul>
             <li>Un inverseur (NOT) pour calculer \( \overline{sel} \).</li>
             <li>Deux portes ET (AND) :
                <ul>
                    <li>La première calcule \( \overline{sel} \cdot a \).</li>
                    <li>La seconde calcule \( sel \cdot b \).</li>
                </ul>
            </li>
             <li>Une porte OU (OR) qui combine les sorties des portes ET pour produire la sortie finale \( s \).</li>
        </ul>
        <p>Ce schéma réalise l'aiguillage : si \( sel=0 \), la porte ET du haut est activée (par \( \overline{sel}=1 \)) et laisse passer \(a\), tandis que la porte ET du bas est désactivée (par \( sel=0 \)). Si \( sel=1 \), c'est l'inverse.</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 101: VHDL for 2-to-1 MUX (Basic) -->
    <div class="slide" id="page101">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">VHDL - mux2v1</h2>
        <p>Code VHDL pour un multiplexeur 2 vers 1 ( \( s = \overline{sel} \cdot a + sel \cdot b \) ) en utilisant un style flot de données basé sur l'équation logique :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour le multiplexeur 2 vers 1
entity m2v1 is -- Nom court pour MUX 2 vers 1
    port(
        a, b : in  std_logic;     -- Entrées de données
        sel  : in  std_logic;     -- Entrée de sélection
        s    : out std_logic      -- Sortie
    );
end entity m2v1;

-- Architecture flot de données
architecture flot of m2v1 is
begin
    -- Implémente s = (a AND (NOT sel)) OR (b AND sel);
    s <= (a and not(sel)) or (b and sel);
end architecture flot;
        </code></pre>
        <p>Cette architecture traduit directement l'équation booléenne en une affectation concurrente VHDL.</p>
    </div>

    <!-- Page 102: VHDL for 2-to-1 MUX (Advanced) -->
    <div class="slide" id="page102">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">VHDL - mux2v1</h2>

        <div style="background-color: #fff3cd; border: 1px solid #ffeeba; padding: 10px; margin-bottom: 15px;">
             <strong>VHDL un petit cran en plus</strong><br>
             Où l'on utilise des constructions VHDL un peu plus expressives
        </div>

        <p>Une autre manière d'écrire l'architecture pour le multiplexeur 2 vers 1, en utilisant l'affectation conditionnelle de signal (`when/else`) :</p>

        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

entity m2v1 is -- Même entité que précédemment
    port(
        a, b : in  std_logic;
        sel  : in  std_logic;
        s    : out std_logic
    );
end entity m2v1;

-- Architecture utilisant l'affectation conditionnelle
architecture flot of m2v1 is
begin
    -- Affecte 'a' à 's' quand sel='0', sinon affecte 'b'
    s <= a when sel = '0' else b;

    -- Commentaire original: -- s prend la valeur de a
    -- Commentaire original: -- sinon si sel <> '0' s p... (commentaire tronqué)
end architecture flot;
        </code></pre>
        <ul>
            <li><code>s <= a when sel = '0' else b;</code> : Cette instruction concurrente signifie : "Le signal `s` prend la valeur de `a` lorsque la condition `sel = '0'` est vraie, sinon (`else`) il prend la valeur de `b`".</li>
            <li>Ceci décrit directement le comportement du multiplexeur de manière plus concise et souvent plus lisible que l'équation booléenne directe.</li>
            <li>C'est une construction VHDL synthétisable qui sera traduite par l'outil de synthèse en un circuit logique équivalent.</li>
        </ul>
    </div>

    <!-- Page 103: 4-to-1 Multiplexer Introduction -->
    <div class="slide" id="page103">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs 4 vers 1</h2>
        <p>Un multiplexeur 4 vers 1 sélectionne une parmi quatre entrées de données.</p>
        <ul>
            <li><strong>4 entrées de données</strong> (par exemple : \( a, b, c, d \)).</li>
            <li>Pour sélectionner une parmi 4 entrées, il faut \( p \) bits de commande tels que \( 2^p = 4 \), donc \( p = 2 \). Il faut <strong>2 commandes</strong> (bits de sélection, par exemple : \( sel1, sel0 \)).</li>
            <li>Nombre total d'entrées = 4 données + 2 commandes = 6 entrées.</li>
            <li>Une table de vérité complète aurait \( 2^6 = 64 \) lignes.</li>
            <li>Cependant, <strong>toutes les lignes ne sont pas intéressantes</strong> ou nécessaires pour comprendre le fonctionnement. La valeur des entrées de données non sélectionnées n'importe pas pour déterminer la sortie à un instant donné.</li>
            <li>Le fonctionnement dépend principalement de la <strong>commande</strong> : pour une valeur donnée des bits de sélection, seule <strong>une variable</strong> de donnée est <strong>pertinente</strong> (celle qui est sélectionnée).</li>
        </ul>
        <p>On utilise une table de vérité simplifiée ou une équation logique pour décrire le MUX 4 vers 1.</p>
    </div>

    <!-- Page 104: 4-to-1 Multiplexer Equation -->
    <div class="slide" id="page104">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs 4 vers 1</h2>
        <p>Table de vérité simplifiée (fonctionnelle) :</p>
         <table border="1">
             <thead>
                 <tr><th style="padding: 5px;">sel1</th><th style="padding: 5px;">sel0</th><th style="padding: 5px; border-left: 2px solid black;">Sortie s</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">\( a \) (Entrée 0)</td></tr>
                 <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">\( b \) (Entrée 1)</td></tr>
                 <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">\( c \) (Entrée 2)</td></tr>
                 <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">\( d \) (Entrée 3)</td></tr>
            </tbody>
        </table>
        <p>Dérivation de l'équation logique :</p>
        <ul>
             <li>Si \( sel1=0, sel0=0 \) (\(\overline{sel1} \cdot \overline{sel0}\)), alors \( s = a \). Terme : \( \overline{sel1} \cdot \overline{sel0} \cdot a \).</li>
             <li>Si \( sel1=0, sel0=1 \) (\(\overline{sel1} \cdot sel0\)), alors \( s = b \). Terme : \( \overline{sel1} \cdot sel0 \cdot b \).</li>
             <li>Si \( sel1=1, sel0=0 \) (\(sel1 \cdot \overline{sel0}\)), alors \( s = c \). Terme : \( sel1 \cdot \overline{sel0} \cdot c \).</li>
             <li>Si \( sel1=1, sel0=1 \) (\(sel1 \cdot sel0\)), alors \( s = d \). Terme : \( sel1 \cdot sel0 \cdot d \).</li>
        </ul>
        <p>L'équation complète est la somme (OU) de ces termes :</p>
        <div class="formula">
             \( s = (\overline{sel1} \cdot \overline{sel0} \cdot a) + (\overline{sel1} \cdot sel0 \cdot b) + (sel1 \cdot \overline{sel0} \cdot c) + (sel1 \cdot sel0 \cdot d) \)
        </div>
         <p><em>(Note: L'équation sur la diapositive originale semble incorrecte, les barres de négation sont mal placées.)</em></p>
    </div>

    <!-- Page 105: 4-to-1 Multiplexer Schematic -->
    <div class="slide" id="page105">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs 4 vers 1</h2>
        <p>Schéma logique implémentant l'équation du multiplexeur 4 vers 1 :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_mux4to1_schematic.png" alt="Schéma logique d'un multiplexeur 4 vers 1" style="border: 1px solid #ccc; padding: 10px; max-width: 450px;">
             <p style="color: #666;">[Placeholder for MUX 4-to-1 Schematic]</p>
        </div>
         <p>Le circuit comprend :</p>
        <ul>
            <li>Deux inverseurs pour générer \( \overline{sel0} \) et \( \overline{sel1} \).</li>
            <li>Quatre portes ET à 3 entrées :
                <ul>
                    <li>\( \overline{sel1} \cdot \overline{sel0} \cdot a \)</li>
                    <li>\( \overline{sel1} \cdot sel0 \cdot b \)</li>
                    <li>\( sel1 \cdot \overline{sel0} \cdot c \)</li>
                    <li>\( sel1 \cdot sel0 \cdot d \)</li>
                </ul>
            </li>
             <li>Une porte OU à 4 entrées qui combine les sorties des portes ET pour produire la sortie finale \( s \).</li>
        </ul>
    </div>

    <!-- Page 106: Using Multiplexers to Implement Logic Functions -->
    <div class="slide" id="page106">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplexeurs</h2>
        <p>Application intéressante des multiplexeurs :</p>
        <ul>
             <li><strong>Permet de réaliser des fonctions logiques</strong> quelconques.</li>
             <li>Un multiplexeur \( n \) vers 1 (avec \( n = 2^p \) entrées de données et \( p \) entrées de sélection) peut réaliser <strong>n'importe quelle fonction logique de \( p \) variables</strong>.</li>
             <li>Principe :
                 <ul>
                     <li>Utiliser les \( p \) variables de la fonction comme <strong>commandes</strong> (entrées de sélection) du multiplexeur.</li>
                     <li>Connecter les <strong>valeurs des entrées de données</strong> du multiplexeur à '0' ou '1' (ou à une autre variable si on réalise une fonction de p+1 variables) de manière à correspondre aux <strong>valeurs de la fonction</strong> pour chaque combinaison des variables de commande.</li>
                 </ul>
             </li>
        </ul>
        <p>Exemple : Réaliser la fonction ET \( s = x \cdot y \) en utilisant un multiplexeur 4 vers 1.</p>
        <ul>
            <li>Variables de la fonction : \( x, y \). Utilisons-les comme commandes \( sel1=x, sel0=y \).</li>
            <li>Table de vérité de la fonction ET :</li>
        </ul>
         <table border="1">
             <thead>
                 <tr><th>x (sel1)</th><th>y (sel0)</th><th>s = x.y</th><th>Entrée MUX sélectionnée</th><th>Valeur à appliquer à l'entrée MUX</th></tr>
            </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td>0</td><td>a (entrée 00)</td><td>a = 0</td></tr>
                 <tr><td>0</td><td>1</td><td>0</td><td>b (entrée 01)</td><td>b = 0</td></tr>
                 <tr><td>1</td><td>0</td><td>0</td><td>c (entrée 10)</td><td>c = 0</td></tr>
                 <tr><td>1</td><td>1</td><td>1</td><td>d (entrée 11)</td><td>d = 1</td></tr>
             </tbody>
         </table>
        <p>Donc, pour réaliser \( s = x \cdot y \) avec un MUX 4 vers 1 où \( x, y \) sont les commandes : connecter l'entrée de donnée 'a' à 0, 'b' à 0, 'c' à 0, et 'd' à 1.</p>
    </div>

    <!-- Page 107: Demultiplexers Introduction -->
    <div class="slide" id="page107">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Démultiplexeurs</h2>
        <p>Un <strong>Démultiplexeur</strong> (DEMUX) réalise la fonction <strong>inverse du multiplexeur</strong>.</p>
        <ul>
            <li>Il agit comme un aiguillage qui connecte une unique entrée de données vers l'une parmi plusieurs sorties possibles.</li>
            <li>Structure typique d'un démultiplexeur 1 vers \( n \) :
                <ul>
                    <li><strong>1</strong> entrée de données (par exemple : \( a \)).</li>
                    <li><strong>p</strong> entrées de commande (sélection), où \( n = 2^p \).</li>
                    <li><strong>n = \( 2^p \) sorties</strong> (par exemple : \( s_0, s_1, \dots, s_{n-1} \)).</li>
                </ul>
            </li>
            <li>La valeur des entrées de commande détermine vers quelle sortie l'entrée de données est dirigée. Toutes les autres sorties sont généralement maintenues à une valeur inactive (souvent '0').</li>
        </ul>
         <p>Exemple : <strong>Démultiplexeur 1 vers 2</strong>.</p>
         <ul>
             <li>1 entrée de donnée \( a \).</li>
             <li>1 entrée de commande \( sel \) (\( p=1, n=2^1=2 \)).</li>
             <li>2 sorties \( s_1, s_0 \).</li>
         </ul>
         <p>Table de vérité :</p>
          <table border="1">
             <thead>
                 <tr><th>sel</th><th>a</th><th style="border-left: 2px solid black;">s1</th><th>s0</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>0</td></tr>
                 <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td></tr> <!-- sel=0 -> a va sur s0 -->
                 <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>0</td></tr>
                 <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td></tr> <!-- sel=1 -> a va sur s1 -->
             </tbody>
         </table>
    </div>

    <!-- Page 108: Demultiplexer 1-to-2 Equation -->
    <div class="slide" id="page108">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Démultiplexeurs</h2>
        <p>Reprise de la table de vérité du démultiplexeur 1 vers 2 :</p>
         <table border="1">
            <thead>
                <tr><th>sel</th><th>a</th><th style="border-left: 2px solid black;">s1</th><th>s0</th></tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>0</td></tr>
                <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td></tr>
                <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>0</td></tr>
                <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td></tr>
            </tbody>
         </table>
        <p>Dérivation des équations logiques pour chaque sortie :</p>
         <ul>
             <li>Sortie \( s_0 \) : vaut 1 uniquement lorsque \( sel = 0 \) ET \( a = 1 \).
                 <div class="formula">\( s_0 = \overline{sel} \cdot a \)</div>
             </li>
             <li>Sortie \( s_1 \) : vaut 1 uniquement lorsque \( sel = 1 \) ET \( a = 1 \).
                 <div class="formula">\( s_1 = sel \cdot a \)</div>
             </li>
         </ul>
         <p><em>(Note : L'équation pour s0 sur la diapositive originale était incorrecte, la barre de négation manquait sur sel.)</em></p>
    </div>

    <!-- Page 109: Demultiplexer 1-to-2 Schematic -->
    <div class="slide" id="page109">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Démultiplexeurs</h2>
        <p>Schéma logique implémentant le démultiplexeur 1 vers 2 avec les équations \( s_0 = \overline{sel} \cdot a \) et \( s_1 = sel \cdot a \) :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_demux1to2_schematic.png" alt="Schéma logique d'un démultiplexeur 1 vers 2" style="border: 1px solid #ccc; padding: 10px; max-width: 300px;">
             <p style="color: #666;">[Placeholder for DEMUX 1-to-2 Schematic]</p>
        </div>
        <p>Le circuit comprend :</p>
        <ul>
            <li>Un inverseur pour calculer \( \overline{sel} \).</li>
            <li>Deux portes ET (AND) :
                <ul>
                    <li>La première calcule \( s_0 = \overline{sel} \cdot a \).</li>
                    <li>La seconde calcule \( s_1 = sel \cdot a \).</li>
                </ul>
            </li>
        </ul>
        <p>L'entrée \( a \) est connectée aux deux portes ET. La commande \( sel \) (et son inverse) active l'une ou l'autre des portes ET, dirigeant ainsi la valeur de \( a \) vers la sortie \( s_0 \) ou \( s_1 \).</p>
    </div>

    <!-- Page 110: Demultiplexer 1-to-2 VHDL -->
    <div class="slide" id="page110">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Démultiplexeurs - VHDL</h2>
        <p>Code VHDL pour un démultiplexeur 1 vers 2 :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour le démultiplexeur 1 vers 2
entity demux is
    port (
        sel : in  std_logic;     -- Entrée de sélection
        a   : in  std_logic;     -- Entrée de données
        s0  : out std_logic;     -- Sortie 0
        s1  : out std_logic      -- Sortie 1
    );
end entity demux;

-- Architecture flot de données utilisant des affectations conditionnelles
architecture flot of demux is
begin
    -- Sortie s0 : active (égale à 'a') si sel='0', sinon inactive ('0')
    s0 <= a when sel = '0' else '0';

    -- Sortie s1 : active (égale à 'a') si sel='1', sinon inactive ('0')
    s1 <= a when sel = '1' else '0';

    -- Alternative basée sur les équations logiques:
    -- s0 <= a and not(sel);
    -- s1 <= a and sel;
end architecture flot;
        </code></pre>
        <ul>
            <li>Cette architecture utilise des affectations conditionnelles `when/else` pour décrire le comportement de chaque sortie.</li>
            <li>Si `sel = '0'`, `s0` prend la valeur de `a` et `s1` prend la valeur '0'.</li>
            <li>Si `sel = '1'`, `s0` prend la valeur '0' et `s1` prend la valeur de `a`.</li>
            <li>Une alternative serait d'implémenter directement les équations logiques \( s_0 = a \cdot \overline{sel} \) et \( s_1 = a \cdot sel \) avec les opérateurs `and` et `not`.</li>
        </ul>
    </div>


    <!-- End of added content -->
    <!-- Continuing the document... -->

    <!-- Page 111: Decoders Introduction -->
    <div class="slide" id="page111">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Décodeurs</h2>
        <p>Un décodeur est un circuit combinatoire qui effectue l'opération inverse d'un encodeur.</p>
        <ul>
            <li>Fonction : Convertir un code binaire en entrée en une sortie active parmi plusieurs.</li>
            <li>Effectue un <strong>Décodage Binaire → Codage "1 parmi n"</strong> (aussi appelé "one-hot").</li>
            <li>Structure typique : <strong>\( n \) entrées</strong> (représentant un nombre binaire) et <strong>\( 2^n \) sorties</strong>.</li>
            <li>Pour une combinaison donnée des \(n\) entrées (correspondant à un nombre \(k\)), seule la sortie numéro \(k\) est active (généralement à '1', les autres étant à '0').</li>
        </ul>
        <p>Exemple : Décodeur 2 vers 4 (\( n=2 \), \( 2^n=4 \) sorties).</p>
        <ul>
            <li>Entrées : \( a, b \) (formant un nombre binaire \(ab\)).</li>
            <li>Sorties : \( s_3, s_2, s_1, s_0 \).</li>
        </ul>
         <p>Table de vérité :</p>
         <table border="1">
             <thead>
                 <tr><th>a</th><th>b</th><th style="border-left: 2px solid black;">s3</th><th>s2</th><th>s1</th><th>s0</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>1</td></tr> <!-- Entrée 00 -> Sortie s0 active -->
                 <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>1</td><td>0</td></tr> <!-- Entrée 01 -> Sortie s1 active -->
                 <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>0</td><td>0</td></tr> <!-- Entrée 10 -> Sortie s2 active -->
                 <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>0</td><td>0</td></tr> <!-- Entrée 11 -> Sortie s3 active -->
            </tbody>
         </table>
         <ul>
             <li>Pour analyser ou concevoir un décodeur, il faut considérer chaque sortie séparément. Il y a donc <strong>autant de tableaux de Karnaugh (ou d'équations) que de sorties</strong> !</li>
            <li>Derivation des équations (trivial dans ce cas, chaque sortie correspond à un minterme des entrées) :</li>
             <ul>
                 <li>\( s_0 = \bar{a} \cdot \bar{b} \) (actif pour l'entrée 00)</li>
                 <li>\( s_1 = \bar{a} \cdot b \) (actif pour l'entrée 01)</li>
                 <li>\( s_2 = a \cdot \bar{b} \) (actif pour l'entrée 10)</li>
                 <li>\( s_3 = a \cdot b \) (actif pour l'entrée 11)</li>
             </ul>
             <li><em>(Note : Les équations sur la diapositive originale sont incorrectes.)</em></li>
         </ul>
    </div>

    <!-- Page 112: Decoder Schematic (2-to-4) -->
    <div class="slide" id="page112">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Décodeur</h2>
        <p>Schéma logique pour un décodeur 2 vers 4, basé sur les équations des mintermes :</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_decoder2to4_schematic.png" alt="Schéma logique d'un décodeur 2 vers 4" style="border: 1px solid #ccc; padding: 10px; max-width: 350px;">
            <p style="color: #666;">[Placeholder for Decoder 2-to-4 Schematic]</p>
         </div>
         <p>Le circuit comprend :</p>
         <ul>
             <li>Deux inverseurs pour générer \( \bar{a} \) et \( \bar{b} \).</li>
             <li>Quatre portes ET (AND) à 2 entrées, chacune calculant un des mintermes :
                 <ul>
                     <li>\( s_0 = \bar{a} \cdot \bar{b} \)</li>
                     <li>\( s_1 = \bar{a} \cdot b \)</li>
                     <li>\( s_2 = a \cdot \bar{b} \)</li>
                     <li>\( s_3 = a \cdot b \)</li>
                 </ul>
             </li>
         </ul>
         <p>Pour chaque combinaison de \(a, b\), une seule des portes ET aura ses deux entrées à '1', activant ainsi la sortie correspondante.</p>
    </div>

    <!-- Page 113: Decoder Symbol (4-to-16) -->
    <div class="slide" id="page113">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Décodeur</h2>
        <p><strong>Décodeur Binaire Base n :</strong> Symbole générique.</p>
        <p>Exemple : Décodeur 4 vers 16.</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_decoder4to16_symbol.png" alt="Symbole d'un décodeur 4 vers 16" style="border: 1px solid #ccc; padding: 10px; max-width: 400px;">
             <p style="color: #666;">[Placeholder for Decoder 4-to-16 Symbol]</p>
         </div>
         <ul>
             <li>Entrées : Un nombre binaire de 4 bits, \( a = a_3a_2a_1a_0 \).</li>
             <li>Sorties : 16 lignes de sortie, numérotées de 0 à 15 (ou 0 à F en hexadécimal).</li>
             <li>Fonctionnement : Si l'entrée \( a \) représente la valeur \( k \), alors la sortie numéro \( k \) est active (par exemple à 1), et toutes les autres sorties sont inactives (à 0).</li>
             <li>Les décodeurs sont utilisés pour sélectionner des périphériques (décodage d'adresse), convertir des codes, piloter des afficheurs 7 segments (avec une logique supplémentaire), etc.</li>
         </ul>
    </div>

    <!-- Page 114: Encoders Introduction -->
    <div class="slide" id="page114">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Encodeurs</h2>
        <p>Un encodeur réalise la fonction <strong>inverse des décodeurs</strong> : il convertit une information de type "1 parmi N" en un code binaire.</p>
        <ul>
            <li>Structure typique : <strong>\( 2^n \) entrées</strong> et <strong>\( n \) sorties</strong>.</li>
             <li>Principe de base (encodeur simple) : On suppose qu'<strong>une seule des \( 2^n \) entrées est active</strong> (à '1') à un instant donné. L'encodeur produit sur ses \( n \) sorties le code binaire correspondant à l'indice de l'entrée active.</li>
         </ul>
        <p>Exemple : Encodeur simple 4 vers 2.</p>
        <ul>
             <li>Entrées : \( s_3, s_2, s_1, s_0 \) (une seule doit être active).</li>
             <li>Sorties : \( a, b \) (code binaire de l'entrée active).</li>
        </ul>
         <p>Table de vérité (cas simple, une seule entrée active) :</p>
        <table border="1">
             <thead>
                 <tr><th>s3</th><th>s2</th><th>s1</th><th>s0</th><th style="border-left: 2px solid black;">a</th><th>b</th></tr>
             </thead>
             <tbody>
                <!-- Cas où une seule entrée est active -->
                <tr><td>0</td><td>0</td><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>0</td></tr> <!-- s0 active -> sortie 00 -->
                <tr><td>0</td><td>0</td><td>1</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>1</td></tr> <!-- s1 active -> sortie 01 -->
                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">1</td><td>0</td></tr> <!-- s2 active -> sortie 10 -->
                <tr><td>1</td><td>0</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">1</td><td>1</td></tr> <!-- s3 active -> sortie 11 -->
                <!-- Cas où aucune entrée n'est active (sortie indéfinie ou 00 par défaut) -->
                 <tr><td>0</td><td>0</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">X</td><td>X</td></tr>
                 <!-- Cas où plusieurs entrées sont actives (gérés par encodeurs de priorité) -->
            </tbody>
         </table>
        <p>Dérivation des équations pour l'encodeur simple :</p>
         <ul>
             <li>Sortie \( b \) (bit de poids faible) est 1 si \( s_1=1 \) OU \( s_3=1 \). Donc : \( b = s_1 + s_3 \).</li>
             <li>Sortie \( a \) (bit de poids fort) est 1 si \( s_2=1 \) OU \( s_3=1 \). Donc : \( a = s_2 + s_3 \).</li>
         </ul>
         <p><em>(Note : Les équations sur la diapositive originale sont beaucoup plus complexes et semblent correspondre à un type d'encodeur différent ou sont incorrectes. Les équations \(b = s_1 + s_3\) et \(a = s_2 + s_3\) sont correctes pour un encodeur simple 4 vers 2 où une seule entrée est active).</em></p>
         <p><strong>Encodeurs de priorité :</strong> Si plusieurs entrées peuvent être actives simultanément, un encodeur de priorité génère le code de l'entrée active ayant la plus haute priorité prédéfinie.</p>
    </div>

    <!-- Page 115: Encoder Schematic (4-to-2) -->
    <div class="slide" id="page115">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Encodeurs</h2>
        <p>Schéma logique pour un encodeur simple 4 vers 2, basé sur les équations \( b = s_1 + s_3 \) et \( a = s_2 + s_3 \) :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_encoder4to2_schematic.png" alt="Schéma logique d'un encodeur simple 4 vers 2" style="border: 1px solid #ccc; padding: 10px; max-width: 300px;">
             <p style="color: #666;">[Placeholder for Encoder 4-to-2 Schematic (Simple)]</p>
         </div>
         <p>Le circuit comprend simplement deux portes OU :</p>
        <ul>
            <li>Une porte OU pour calculer \( b = s_1 + s_3 \).</li>
            <li>Une porte OU pour calculer \( a = s_2 + s_3 \).</li>
        </ul>
        <p><em>(Note : Le schéma sur la diapositive originale est beaucoup plus complexe et correspond aux équations complexes/incorrectes de la diapositive précédente. Le schéma ici représente l'encodeur simple.)</em></p>
    </div>

    <!-- Page 116: Transition to Arithmetic Functions -->
    <div class="slide" id="page116">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Fonctions Combinatoires Complexes</h2>
         <div style="text-align: center; font-size: 1.3em; margin-top: 30px; font-style: italic;">
            (Sous-section :)
        </div>
        <div style="text-align: center; font-size: 1.5em; margin-top: 10px;">
             Fonctions Combinatoires Arithmétiques
        </div>
         <p style="text-align: center; margin-top: 20px;">Nous allons maintenant étudier des circuits combinatoires spécifiquement conçus pour réaliser des opérations arithmétiques (addition, soustraction, etc.) sur des nombres binaires.</p>
    </div>

    <!-- Page 117: Signed Numbers - Sign-Magnitude -->
    <div class="slide" id="page117">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Nombres Signés</h2>
        <ul>
            <li><strong>Comment Coder les Nombres Signés en Binaire ?</strong> Les représentations vues jusqu'ici (binaire pur, DCB) concernaient des nombres non signés (positifs). Il faut une méthode pour représenter les nombres négatifs.</li>
            <li><strong>Introduire un bit de signe :</strong> Une approche simple est de réserver un bit (généralement le <strong>bit de poids fort</strong> - MSB) pour indiquer le signe :
                <ul>
                    <li>0 : Nombre positif</li>
                    <li>1 : Nombre négatif</li>
                </ul>
                 Les bits restants représentent la magnitude (valeur absolue) du nombre. C'est le codage <strong>Signe + Valeur Absolue</strong>.
            </li>
        </ul>
        <p>Exemple : Nombre sur 4 bits (\( b_3 b_2 b_1 b_0 \)). \( b_3 \) est le bit de signe.</p>
        <table border="1">
            <thead>
                 <tr><th>\(b_3\)</th><th>\(b_2\)</th><th>\(b_1\)</th><th>\(b_0\)</th><th style="border-left: 2px solid black;">Signe</th><th style="border-left: 2px solid black;">Valeur décimale</th></tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>1</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">+</td><td style="border-left: 2px solid black;">4 (car 100 = 4)</td></tr>
                 <tr><td>1</td><td>1</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">-</td><td style="border-left: 2px solid black;">-4 (car 100 = 4)</td></tr>
                 <tr><td>0</td><td>0</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">+</td><td style="border-left: 2px solid black;">0 (+0)</td></tr>
                 <tr><td>1</td><td>0</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">-</td><td style="border-left: 2px solid black;">0 (-0)</td></tr>
            </tbody>
        </table>
        <ul>
            <li><strong>Inconvénients du codage Signe + Valeur Absolue :</strong>
                <ul>
                    <li>Deux représentations pour zéro (+0 et -0).</li>
                    <li><strong>Nécessite trop de logique pour réaliser des opérateurs arithmétiques.</strong> L'addition et la soustraction deviennent complexes car il faut traiter le signe séparément et comparer les magnitudes. Par exemple, A + B dépend des signes de A et B : cela peut être une addition ou une soustraction de magnitudes.</li>
                </ul>
             </li>
        </ul>
    </div>

    <!-- Page 118: Two's Complement Introduction -->
    <div class="slide" id="page118">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément à 2</h2>
        <ul>
            <li><strong>Utilisation d'un codage qui permet de limiter les opérateurs :</strong> Pour simplifier les opérations arithmétiques (en particulier, pour que l'addition binaire standard fonctionne aussi bien pour les nombres positifs que négatifs), on utilise principalement la représentation en <strong>Complément à 2</strong>.</li>
            <li><strong>Complément à 2 :</strong>
                 <ul>
                     <li>Le <strong>Bit de signe</strong> est toujours le <strong>bit de poids fort</strong> (MSB).
                         <ul>
                             <li><strong>Si bit de signe = 0 :</strong> Le nombre est positif, et les bits restants représentent sa valeur absolue (comme en binaire non signé). Le nombre est codé directement.</li>
                             <li><strong>Si bit de signe = 1 :</strong> Le nombre est négatif. La représentation binaire n'est PAS la valeur absolue avec un signe '1'. Pour obtenir la valeur absolue, il faut appliquer l'opération de <strong>Complément à 2</strong> à la représentation binaire.</li>
                         </ul>
                     </li>
                </ul>
            </li>
             <li><strong>Principe mathématique</strong> (pour un nombre négatif \(-X\) sur \(n\) bits) : La représentation en complément à 2 correspond à \( 2^n - |X| \).
                 <ul>
                     <li>Cela crée une arithmétique modulaire (modulo \(2^n\)) où la soustraction \(A - B\) devient une addition \(A + (-B)\), en utilisant la représentation de \(-B\) en complément à 2.</li>
                 </ul>
            </li>
             <li>Ce codage n'a qu'une seule représentation pour zéro (00...0) et simplifie grandement la conception des unités arithmétiques et logiques (ALU).</li>
        </ul>
    </div>

    <!-- Page 119: Two's Complement Examples -->
    <div class="slide" id="page119">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément à 2</h2>
        <p>Exemples sur 4 bits :</p>
        <ul>
            <li><strong>Codage de +7 :</strong>
                <ul>
                    <li>Le nombre est positif, donc le bit de signe (\( b_3 \)) est 0.</li>
                    <li>La valeur absolue est 7, qui s'écrit \( 111_2 \) sur 3 bits.</li>
                    <li>Représentation sur 4 bits : \( 0111_2 \).</li>
                </ul>
                 <table border="1">
                     <thead>
                         <tr><th>\(b_3\)</th><th>\(b_2\)</th><th>\(b_1\)</th><th>\(b_0\)</th><th style="border-left: 2px solid black;">Signe</th><th style="border-left: 2px solid black;">Valeur décimale</th></tr>
                     </thead>
                     <tbody>
                         <tr><td>0</td><td>1</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">+</td><td style="border-left: 2px solid black;">7</td></tr>
                     </tbody>
                 </table>
             </li>
             <li><strong>Codage de -7 :</strong>
                <ul>
                    <li>Le nombre est négatif, donc le bit de signe (\( b_3 \)) sera 1.</li>
                     <li>On calcule le complément à 2 de la valeur absolue 7 (\( 0111_2 \)).</li>
                     <li>Méthode 1 (Calcul \( 2^n - |X| \)): \( n=4 \), \( |X|=7 \). \( 2^4 - 7 = 16 - 7 = 9 \). Le codage binaire de 9 est \( 1001_2 \).</li>
                     <li>Méthode 2 (Inverser + Ajouter 1) :
                        <ul>
                            <li>Valeur absolue (+7) : \( 0111 \)</li>
                             <li>Inverser les bits (Complément à 1) : \( 1000 \)</li>
                             <li>Ajouter 1 : \( 1000 + 1 = 1001 \)</li>
                        </ul>
                     </li>
                     <li>Représentation sur 4 bits : \( 1001_2 \).</li>
                 </ul>
                <table border="1">
                     <thead>
                         <tr><th>\(b_3\)</th><th>\(b_2\)</th><th>\(b_1\)</th><th>\(b_0\)</th><th style="border-left: 2px solid black;">Signe</th><th style="border-left: 2px solid black;">Valeur décimale</th></tr>
                     </thead>
                     <tbody>
                         <tr><td>1</td><td>0</td><td>0</td><td>1</td><td style="border-left: 2px solid black;">-</td><td style="border-left: 2px solid black;">-7</td></tr>
                     </tbody>
                 </table>
             </li>
        </ul>
    </div>

    <!-- Page 120: Two's Complement Calculation Steps -->
    <div class="slide" id="page120">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément à 2</h2>
        <p><strong>Étapes pratiques pour complémenter à 2</strong> un nombre binaire (c'est-à-dire, pour trouver la représentation de l'opposé d'un nombre) :</p>
        <ol>
             <li><strong>Faire le complément à 1</strong> du nombre : Inverser chaque bit (0 devient 1, 1 devient 0).</li>
             <li><strong>Ajouter 1</strong> au résultat du complément à 1 (en utilisant l'addition binaire standard).</li>
        </ol>
        <p>Exemple : Codage de -5 sur 4 bits.</p>
        <ol>
            <li>Prendre la représentation de la valeur absolue (+5) : \( 5_{10} = 0101_2 \).</li>
            <li>Calculer le complément à 1 (inverser les bits) : \( \text{C1}(0101) = 1010_2 \).</li>
            <li>Ajouter 1 au complément à 1 : \( 1010 + 1 = 1011_2 \).</li>
        </ol>
        <p>Donc, la représentation de -5 en complément à 2 sur 4 bits est \( 1011_2 \).</p>

        <p>Tableau récapitulatif de l'exemple :</p>
         <table border="1">
            <thead>
                <tr><th>\(b_3\)</th><th>\(b_2\)</th><th>\(b_1\)</th><th>\(b_0\)</th><th style="border-left: 2px solid black;">Commentaires</th></tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>1</td><td>0</td><td>1</td><td style="border-left: 2px solid black;">Valeur Absolue (+5)</td></tr>
                <tr><td>1</td><td>0</td><td>1</td><td>0</td><td style="border-left: 2px solid black;">Complément à 1 (Inversion bit à bit)</td></tr>
                <tr><td> </td><td> </td><td>+</td><td>1</td><td style="border-left: 2px solid black;">Ajout de 1</td></tr>
                <tr style="border-top: 2px solid black;"><td>1</td><td>0</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">Complément à 2 (Résultat = -5)</td></tr>
            </tbody>
        </table>
        <p><strong>Règle rapide (alternative) :</strong> En partant du bit de poids faible (droite), laisser inchangés tous les zéros jusqu'au premier '1' rencontré. Laisser ce premier '1' inchangé. Inverser tous les bits suivants (à gauche de ce premier '1').</p>
        <p>Exemple -5 : \( 0101 \). Le premier '1' est à droite. Le laisser. Inverser le reste : \( 101 \). Résultat : \( 1011 \).</p>
        <p>Exemple -4 (\(0100\)) : Laisser \(00\) puis le premier \(1\). Inverser ce qui reste (le 0 à gauche). Résultat : \(1100\).</p>
    </div>


    <!-- End of added content -->
    <!-- Continuing the document... -->

    <!-- Page 121: Two's Complement Advantages -->
    <div class="slide" id="page121">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément à 2</h2>
        <p><strong>Avantages</strong> de la représentation en complément à 2 :</p>
        <ul>
            <li><strong>Unicité du 0 :</strong> Il n'y a qu'une seule représentation pour zéro ( \( 00...0 \) ). Contrairement au codage signe + valeur absolue qui a +0 et -0.</li>
            <li><strong>Utilisation du même opérateur pour l'addition et la soustraction :</strong>
                 <ul>
                    <li>L'addition binaire standard fonctionne correctement, que les nombres soient positifs ou négatifs.</li>
                     <li>La soustraction \( A - B \) peut être réalisée comme une addition \( A + (-B) \), où \( -B \) est la représentation de B en complément à 2.</li>
                    <li>Cela simplifie grandement la conception de l'Unité Arithmétique et Logique (ALU) d'un processeur.</li>
                 </ul>
             </li>
            <li>Illustre l'<strong>arithmétique Modulo \( 2^n \)</strong> : Les opérations sont effectuées comme si le résultat "bouclait" après avoir atteint \( 2^n \).
                <ul>
                    <li>Exemple simplifié en base 16 sur 1 "digit" (\( n=4 \) bits, \( 2^n=16 \), modulo \( 10_H = 16_{10} \)).</li>
                    <li>Calculer \( 9_H - 4_H \). La valeur absolue 4 est \( 4_H \).</li>
                    <li>Le complément à 2 de \( 4_H \) (sur 4 bits, donc \(0100_2\)) est \( 1100_2 = C_H \). (Calcul : \( 10_H - 4_H = C_H \)).</li>
                    <li>L'opération devient \( 9_H + C_H \).</li>
                    <li>\( 9_{16} + C_{16} = 9 + 12 = 21_{10} \).</li>
                    <li>\( 21 \text{ modulo } 16 = 5 \). En hexadécimal : \( 9_H + C_H = 15_H \). \( 15_H \text{ modulo } 10_H = 5_H \).</li>
                    <li>Résultat : \( 9_H - 4_H = 5_H \).</li>
                    <li>L'addition \( (9_H + C_H) \text{ modulo } (10_H) \) donne le bon résultat \( 5_H \).</li>
                </ul>
            </li>
             <li>Des exemples en binaire illustreront cela plus clairement.</li>
        </ul>
    </div>

    <!-- Page 122: Two's Complement Mathematical Justification -->
    <div class="slide" id="page122">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément à 2</h2>
        <p>Justification mathématique (arithmétique modulaire) :</p>
        <ul>
            <li><strong>Codage sur N bits</strong>, N fini. On travaille en modulo \( 2^N \).</li>
            <li>On veut coder un nombre négatif \( -P \) sur N bits, où \( P \) est la valeur absolue positive, \( P \in [0, 2^{N-1}-1] \) (pour laisser le bit de signe). La formule \(P \in [0, 2^N]\) dans la diapo est un peu large, elle devrait être restreinte pour les nombres représentables.</li>
             <li>Par définition de l'arithmétique modulaire, on sait que \( -P \equiv (2^N - P) \pmod{2^N} \).</li>
             <li>On pose \( CP \) (notation non standard) la représentation binaire de \( 2^N - P \).</li>
             <li>On pose que la représentation de \( -P \) sur N bits est la représentation binaire de \( (2^N - P) \).</li>
             <li>Ce qui donne : la représentation de \(-P\) est \( (2^N - P) \pmod{2^N} \).</li>
             <li>Comme \( P \) est la valeur absolue (donc \( 0 \le P < 2^N \)), on a bien \( (2^N - P) \pmod{2^N} \). La représentation binaire de \( (2^N - P) \) est bien celle de \( -P \) dans cette arithmétique.</li>
         </ul>
         <p>Pourquoi \( 2^N - P \) correspond à "inverser et ajouter 1" ?</p>
         <ul>
             <li>Le complément à 1 de \( P \) (inverser les bits) correspond à \( (2^N - 1) - P \).
                 <br> (Ex: sur 4 bits, \( N=4 \), \( 2^4-1 = 15 = 1111_2 \). \( 1111 - P \) revient à inverser les bits de P car \( 1-0=1, 1-1=0 \)).</li>
             <li>Donc, Complément à 2 = C1(P) + 1 = \( ((2^N - 1) - P) + 1 = 2^N - P \).</li>
         </ul>
         <p>Cela confirme que la méthode pratique "inverser et ajouter 1" calcule bien la représentation \( 2^N - P \) nécessaire pour l'arithmétique modulaire.</p>
         <p><em>(Note : La diapositive utilise CP comme notation pour \(2^N-P\), ce qui peut prêter à confusion. L'intervalle pour P est aussi un peu large dans la diapo.)</em></p>
    </div>

    <!-- Page 123: Two's Complement Interpretation Formula -->
    <div class="slide" id="page123">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément à 2</h2>
        <p>Formule d'interprétation de la valeur décimale \( V \) d'un nombre \( B = b_{N-1}b_{N-2}...b_0 \) codé en complément à 2 sur N bits :</p>

        <div style="background-color: #e9ecef; padding: 10px; margin-bottom: 15px; border-left: 3px solid #007bff;">
            <strong>Si \( P \) est positif (bit de signe \( b_{N-1} = 0 \)) :</strong>
             <p>La valeur est simplement la conversion binaire non signée standard.</p>
             <div class="formula">
                 \( V = \sum_{i=0}^{N-1} b_i \times 2^i \)
                 <br> (Comme \( b_{N-1}=0 \), on peut aussi écrire \( V = \sum_{i=0}^{N-2} b_i \times 2^i \) )
             </div>
        </div>

        <div style="background-color: #f8f9fa; padding: 10px; margin-bottom: 15px; border-left: 3px solid #6c757d;">
            <strong>Si \( P \) est négatif (bit de signe \( b_{N-1} = 1 \)) :</strong>
            <p>La diapositive montre une dérivation un peu complexe. L'idée est que la représentation \( B \) correspond à \( 2^N - |P| \). La valeur \(V\) est \( -|P| \).</p>
             <p>Une formule directe plus courante interprète le bit de signe \( b_{N-1} \) comme ayant un <strong>poids négatif</strong> \( -2^{N-1} \), tandis que les autres bits ont leur poids positif standard :</p>
             <div class="formula">
                  \( V = -b_{N-1} \times 2^{N-1} + \sum_{i=0}^{N-2} b_i \times 2^i \)
             </div>
        </div>

        <div style="background-color: #ffdddd; border: 2px solid red; padding: 10px;">
             <strong>Nombre en complément à 2 (Formule générale unique) :</strong>
             <p>La formule avec le poids négatif pour le MSB fonctionne pour les nombres positifs et négatifs :</p>
            <div class="formula">
                 \( V = -b_{N-1} \times 2^{N-1} + \sum_{i=0}^{N-2} b_i \times 2^i \)
            </div>
            <ul>
                <li>Si \( b_{N-1}=0 \) (positif), le premier terme est nul, et on retrouve la somme standard.</li>
                <li>Si \( b_{N-1}=1 \) (négatif), la formule donne directement la valeur négative correcte.</li>
            </ul>
             <p>Exemple (4 bits) : \( 1011_2 \). \( b_3=1, b_2=0, b_1=1, b_0=1 \).</p>
             <p>\( V = -1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = -8 + 0 + 2 + 1 = -5 \).</p>
        </div>
    </div>

    <!-- Page 124: Half Adder Definition -->
    <div class="slide" id="page124">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Demi-Additionneur (Half Adder)</h2>
        <p>Le demi-additionneur est le bloc de base pour l'addition binaire.</p>
        <ul>
             <li>Fonction : Réalise l'addition de <strong>deux bits</strong> uniques, \( a \) et \( b \).</li>
            <li>Sorties : Produit deux bits en sortie :
                <ul>
                    <li><strong>s (Sum) :</strong> Le bit de somme (résultat de l'addition modulo 2).</li>
                    <li><strong>r (Carry-out) :</strong> Le bit de retenue (carry) généré par l'addition.</li>
                </ul>
            </li>
        </ul>
        <p>Réalisation d'un demi-additionneur :</p>
        <p>Table de vérité :</p>
         <table border="1">
            <thead>
                 <tr><th>a</th><th>b</th><th style="border-left: 2px solid black;">s (Somme)</th><th>r (Retenue)</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>0</td></tr> <!-- 0+0 = 0, retenue 0 -->
                 <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td></tr> <!-- 0+1 = 1, retenue 0 -->
                 <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">1</td><td>0</td></tr> <!-- 1+0 = 1, retenue 0 -->
                 <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td></tr> <!-- 1+1 = 0, retenue 1 -->
             </tbody>
         </table>
        <p>Equations logiques :</p>
        <ul>
            <li>La colonne 's' correspond à la fonction <strong>OU-Exclusif (XOR)</strong>.
                 <div class="formula">\( s = a \oplus b \)</div>
            </li>
             <li>La colonne 'r' correspond à la fonction <strong>ET (AND)</strong>.
                 <div class="formula">\( r = a \cdot b \)</div>
                 (Note: la diapo utilise 'r' pour la retenue, 'c' pour carry est aussi très courant).
             </li>
        </ul>
    </div>

    <!-- Page 125: Half Adder Schematic -->
    <div class="slide" id="page125">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Demi-Additionneur</h2>
        <p>Schéma logique du demi-additionneur, basé sur les équations \( s = a \oplus b \) et \( c = a \cdot b \) (en utilisant 'c' pour carry) :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_half_adder_schematic.png" alt="Schéma logique d'un demi-additionneur" style="border: 1px solid #ccc; padding: 10px; max-width: 300px;">
             <p style="color: #666;">[Placeholder for Half Adder Schematic]</p>
        </div>
        <p>Le circuit comprend :</p>
        <ul>
             <li>Une porte XOR pour calculer la somme \( s \).</li>
             <li>Une porte AND pour calculer la retenue de sortie \( c \).</li>
        </ul>
    </div>

    <!-- Page 126: Half Adder VHDL -->
    <div class="slide" id="page126">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Demi-Additionneur</h2>
        <p>Code VHDL pour un demi-additionneur (Half Adder) :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour le demi-additionneur
entity demi_add is
    port(
        a, b : in  std_logic;     -- Entrées des deux bits à additionner
        s    : out std_logic;     -- Sortie Somme
        c    : out std_logic      -- Sortie Retenue (Carry)
    );
end entity demi_add;

-- Architecture flot de données
architecture flot of demi_add is
begin
    -- Calcul de la somme (XOR)
    s <= a xor b;

    -- Calcul de la retenue (AND)
    c <= a and b;
end architecture flot;
        </code></pre>
        <p>Cette architecture implémente directement les équations logiques du demi-additionneur en utilisant les opérateurs VHDL `xor` et `and`.</p>
    </div>

    <!-- Page 127: Full Adder Introduction -->
    <div class="slide" id="page127">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 1 bit (Full Adder)</h2>
        <p>Pour additionner des nombres de plusieurs bits, il faut pouvoir propager la retenue d'une colonne (position de bit) à la suivante. Le demi-additionneur ne suffit pas car il n'a pas d'entrée pour une retenue venant de la colonne précédente.</p>
        <ul>
            <li><strong>Introduction d'une retenue d'entrée (Carry-in) :</strong> L'additionneur complet (Full Adder) prend en compte cette retenue.</li>
            <li>Il additionne <strong>trois variables d'entrées</strong> :
                <ul>
                    <li>\( a_i \) : bit i du premier opérande.</li>
                    <li>\( b_i \) : bit i du second opérande.</li>
                    <li>\( c_i \) : retenue (carry-in) provenant de l'addition des bits de la position précédente (i-1).</li>
                </ul>
            </li>
            <li>Il produit <strong>deux sorties</strong> :
                <ul>
                    <li>\( s_i \) : bit de somme pour la position i.</li>
                    <li>\( c_{i+1} \) : retenue (carry-out) générée par l'addition à la position i, qui sera utilisée comme carry-in pour la position suivante (i+1).</li>
                 </ul>
             </li>
            <li>Equations logiques (dérivables de la table de vérité de l'addition de 3 bits) :
                <ul>
                    <li>Somme : \( s_i = a_i \oplus b_i \oplus c_i \)</li>
                    <li>Retenue de sortie : \( c_{i+1} = (a_i \cdot b_i) + (a_i \cdot c_i) + (b_i \cdot c_i) \)
                        <br>(La retenue est 1 si au moins deux des trois entrées sont à 1).
                        <br>Forme alternative : \( c_{i+1} = (a_i \oplus b_i) \cdot c_i + a_i \cdot b_i \)</li>
                 </ul>
            </li>
             <li><strong>Utilisation de deux demi-additionneurs :</strong> Un additionneur complet peut être construit en combinant deux demi-additionneurs et une porte OU.</li>
        </ul>
    </div>

    <!-- Page 128: Full Adder Implementation with Half Adders -->
    <div class="slide" id="page128">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 1 bit</h2>
        <p>Implémentation d'un additionneur complet (Full Adder) à l'aide de deux demi-additionneurs (HA) et une porte OU :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_full_adder_from_ha.png" alt="Schéma d'un additionneur complet construit avec deux demi-additionneurs" style="border: 1px solid #ccc; padding: 10px; max-width: 550px;">
             <p style="color: #666;">[Placeholder for Full Adder from HAs Schematic]</p>
        </div>
        <p>Fonctionnement :</p>
        <ol>
            <li>Le premier HA additionne \( a_i \) et \( b_i \), produisant une somme partielle \( s_{p} = a_i \oplus b_i \) et une retenue partielle \( c_{p1} = a_i \cdot b_i \).</li>
            <li>Le second HA additionne la somme partielle \( s_{p} \) et la retenue d'entrée \( c_i \), produisant la somme finale \( s_i = s_{p} \oplus c_i = (a_i \oplus b_i) \oplus c_i \) et une seconde retenue partielle \( c_{p2} = s_{p} \cdot c_i = (a_i \oplus b_i) \cdot c_i \).</li>
             <li>La retenue de sortie finale \( c_{i+1} \) est générée si le premier HA a produit une retenue (\( c_{p1} \)) OU si le second HA a produit une retenue (\( c_{p2} \)). Donc, \( c_{i+1} = c_{p1} + c_{p2} = (a_i \cdot b_i) + (a_i \oplus b_i) \cdot c_i \).</li>
        </ol>
        <p>Cette structure est une manière classique de construire un additionneur complet.</p>
    </div>

    <!-- Page 129: Full Adder VHDL (Structural) -->
    <div class="slide" id="page129">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 1 bit</h2>
        <p>Code VHDL pour un additionneur complet (Full Adder) en utilisant un style <strong>structurel</strong>, basé sur l'assemblage de deux demi-additionneurs (composant `demi_add` supposé défini comme à la page 126).</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour l'additionneur complet 1 bit
entity add1 is
    port(
        a, b, cin : in  std_logic;     -- Entrées a, b, et carry-in
        s, cout   : out std_logic      -- Sorties somme et carry-out
    );
end entity add1;

-- Architecture structurelle
architecture struct of add1 is
    -- Déclaration du composant demi-additionneur
    component demi_add is
        port(
            a, b : in  std_logic;
            s    : out std_logic;
            c    : out std_logic
        );
    end component demi_add;

    -- Déclaration des signaux internes pour connecter les composants
    signal stemp, ctemp1, ctemp2 : std_logic;

begin
    -- Instanciation du premier demi-additionneur
    -- Calcule a + b -> somme partielle stemp, retenue ctemp1
    demi_add1 : demi_add -- Référence au composant
        port map(
            a => a,       -- Connecte port 'a' de demi_add à signal 'a' de add1
            b => b,       -- Connecte port 'b' de demi_add à signal 'b' de add1
            s => stemp,    -- Connecte port 's' de demi_add à signal interne 'stemp'
            c => ctemp1   -- Connecte port 'c' de demi_add à signal interne 'ctemp1'
        );

    -- Instanciation du second demi-additionneur
    -- Calcule stemp + cin -> somme finale s, retenue ctemp2
    demi_add2 : demi_add
        port map(
            a => stemp,   -- Entrée a du HA2 = sortie s du HA1
            b => cin,    -- Entrée b du HA2 = carry-in global
            s => s,       -- Sortie s du HA2 = somme finale globale
            c => ctemp2   -- Sortie c du HA2 = deuxième retenue partielle
        );

    -- Calcul de la retenue de sortie finale (cout = ctemp1 OR ctemp2)
    cout <= ctemp1 or ctemp2;

end architecture struct;
        </code></pre>
         <p>Cette description montre comment assembler des composants prédéfinis (`demi_add`) pour en créer un plus complexe (`add1`). Les signaux internes (`stemp`, `ctemp1`, `ctemp2`) servent de "fils" pour relier les sorties d'un composant aux entrées d'un autre ou à la logique combinatoire externe (la porte OU).</p>
         <p><em>(Note: L'instanciation dans l'OCR originale utilise `entity work.demi-add(flot)` qui est une syntaxe plus ancienne ou spécifique à certains outils pour la configuration directe. L'utilisation de `component` est plus standard pour une description structurelle.)</em></p>
    </div>

    <!-- Page 130: Full Adder VHDL (Dataflow) -->
    <div class="slide" id="page130">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 1 bit</h2>
        <p>Code VHDL alternatif pour un additionneur complet (Full Adder) en utilisant un style <strong>flot de données</strong>, basé sur les équations logiques directes.</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

-- Entité pour l'additionneur complet 1 bit (identique)
entity add1 is
    port(
        a, b, cin : in  std_logic;
        s, cout   : out std_logic
    );
end entity add1;

-- Architecture flot de données
architecture flot of add1 is
begin
    -- Calcul de la somme: s = a XOR b XOR cin
    s <= a xor b xor cin;

    -- Calcul de la retenue: cout = (a AND b) OR (a AND cin) OR (b AND cin)
    cout <= (a and b) or (a and cin) or (b and cin);

    -- Forme alternative pour la retenue:
    -- cout <= (a and b) or ((a xor b) and cin);

end architecture flot;
        </code></pre>
        <p>Cette architecture décrit directement le comportement logique de l'additionneur complet sans référence explicite à sa structure interne (comme les demi-additionneurs).</p>
        <p>L'outil de synthèse choisira la meilleure implémentation en termes de portes logiques pour réaliser ces équations, en fonction de la technologie cible et des contraintes (vitesse, surface).</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 131: Full Adder VHDL (Advanced) -->
    <div class="slide" id="page131">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 1 bit</h2>

        <div style="background-color: #ffdddd; border: 2px solid red; padding: 10px; margin-bottom: 15px;">
             <strong>VHDL après l'UE LE201</strong><br>
             Ce que peut faire VHDL<br>
             Hors du cadre du cours LE201 (Probablement car utilise des packages arithmétiques)
        </div>

        <p>Une autre façon (plus abstraite et souvent préférée) de décrire un additionneur en VHDL est d'utiliser les opérateurs arithmétiques prédéfinis dans les packages numériques standards (`numeric_std` ou les anciens `std_logic_arith`/`std_logic_unsigned`).</p>
        <p><em>Attention : Le code suivant est une simplification extrême et incorrecte pour un additionneur 1 bit avec retenue. Il additionne juste a et b sans gérer la retenue d'entrée ni de sortie correctement via l'opérateur '+'.</em></p>

        <pre><code class="language-vhdl">
-- Code incorrect présenté sur la diapositive --
library ieee;
use ieee.std_logic_1164.all;
-- Il manque l'inclusion d'un package numérique (ex: numeric_std)
-- pour que l'opérateur '+' soit défini pour std_logic.

entity add1 is -- L'entité devrait inclure cin et cout
    port( a,b : in std_logic;
          s : out std_logic);
end entity add1;

architecture comport of add1 is
begin
    -- Ceci est incorrect :
    -- 1. L'opérateur '+' n'est pas défini pour std_logic par défaut.
    -- 2. Cela ne gère pas la retenue d'entrée (cin).
    -- 3. Cela ne calcule pas la retenue de sortie (cout).
    -- s <= a + b; -- !! SYNTAXE INCORRECTE / SEMANTIQUE INCOMPLETE !!
end architecture comport;
        </code></pre>

        <p><strong>Code Correct (Exemple Conceptuel utilisant `numeric_std`) :</strong></p>
         <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all; -- Package standard pour l'arithmétique

entity add1_numeric is
    port(
        a, b, cin : in  std_logic;
        s, cout   : out std_logic
    );
end entity add1_numeric;

architecture behave of add1_numeric is
    -- Signaux internes pour la conversion de type
    signal term1, term2, term3, sum_internal : unsigned(0 downto 0);
    signal result_internal : unsigned(1 downto 0);
begin
    -- Conversion des entrées std_logic en vecteurs unsigned(0 downto 0)
    term1 <= unsigned'('0' & a);
    term2 <= unsigned'('0' & b);
    term3 <= unsigned'('0' & cin);

    -- Addition (produit un résultat sur 2 bits: retenue & somme)
    result_internal <= term1 + term2 + term3;

    -- Assignation aux sorties (conversion inverse)
    s    <= result_internal(0); -- Bit de poids faible = somme
    cout <= result_internal(1); -- Bit de poids fort = retenue

    -- Note: C'est une façon verbeuse pour 1 bit, mais illustre le principe
    -- pour des vecteurs plus larges.
end architecture behave;
        </code></pre>
         <p>L'utilisation directe de l'opérateur `+` est plus courante pour des vecteurs (`std_logic_vector`) représentant des nombres multi-bits, après les avoir convertis en types `unsigned` ou `signed` du package `numeric_std`.</p>
    </div>

    <!-- Page 132: 4-bit Ripple Carry Adder Structure -->
    <div class="slide" id="page132">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 4 bits</h2>
        <p>Pour additionner des nombres de plusieurs bits (par exemple, 4 bits), on peut connecter plusieurs additionneurs complets 1 bit en cascade. C'est la structure de l'<strong>additionneur à propagation de retenue</strong> (Ripple Carry Adder).</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adder4bit_ripple.png" alt="Schéma d'un additionneur 4 bits à propagation de retenue" style="border: 1px solid #ccc; padding: 10px; max-width: 600px;">
             <p style="color: #666;">[Placeholder for 4-bit Ripple Carry Adder Schematic]</p>
        </div>
        <p>Fonctionnement :</p>
        <ul>
             <li>Le premier additionneur (le plus à droite, pour le bit 0) additionne \( a_0, b_0 \) et la retenue d'entrée initiale \( c_0 \), produisant la somme \( s_0 \) et une retenue \( c_1 \).</li>
             <li>Le deuxième additionneur (pour le bit 1) additionne \( a_1, b_1 \) et la retenue \( c_1 \) venant de l'étage précédent, produisant \( s_1 \) et \( c_2 \).</li>
             <li>Ce processus se répète pour chaque bit. La retenue "se propage" ("ripple") de droite à gauche.</li>
             <li>Le dernier additionneur (pour le bit 3) produit la somme \( s_3 \) et la retenue finale de l'additionneur 4 bits, \( c_4 \).</li>
        </ul>
        <p>Inconvénient : Le délai de calcul total est proportionnel au nombre de bits, car chaque étage doit attendre la retenue de l'étage précédent. Pour des additionneurs très larges, ce délai peut devenir significatif.</p>
    </div>

    <!-- Page 133: 4-bit Adder Entity -->
    <div class="slide" id="page133">
         <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 4 bits : Entité</h2>
        <p>Déclaration de l'entité VHDL pour un additionneur 4 bits :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

ENTITY add4 IS
    port (
        a    : in  std_logic_vector(3 downto 0); -- Opérande A (4 bits)
        b    : in  std_logic_vector(3 downto 0); -- Opérande B (4 bits)
        cin  : in  std_logic;                    -- Retenue d'entrée initiale (Carry-in)
        s    : out std_logic_vector(3 downto 0); -- Somme (4 bits)
        cout : out std_logic                     -- Retenue de sortie finale (Carry-out)
    );
END ENTITY add4;
        </code></pre>
        <ul>
             <li>Les opérandes d'entrée `a` et `b`, ainsi que la somme `s`, sont définis comme des vecteurs de 4 bits (`std_logic_vector(3 downto 0)`), indexés de 3 (MSB) à 0 (LSB).</li>
             <li>Les retenues d'entrée `cin` et de sortie `cout` sont des bits uniques (`std_logic`).</li>
        </ul>
    </div>

    <!-- Page 134: 4-bit Adder Simple Structural Architecture -->
    <div class="slide" id="page134">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 4 bits : Architecture Simple (Structurelle)</h2>
        <p>Architecture structurelle "simple" (explicite) pour l'additionneur 4 bits, implémentant la structure à propagation de retenue en instanciant 4 additionneurs 1 bit (`add1`, supposé défini).</p>
         <pre><code class="language-vhdl">
ARCHITECTURE struct_simple OF add4 IS
    -- Déclaration du composant additionneur 1 bit
    component add1 is
        port( a,b,cin : in std_logic;
              s,cout : out std_logic);
    end component add1;

    -- Signal interne pour propager les retenues intermédiaires
    -- c(0) = cin, c(1)=retenue après bit 0, ..., c(4)=cout final
    signal c : std_logic_vector(4 downto 0);

BEGIN
    -- Connecter la retenue d'entrée initiale au signal interne c(0)
    c(0) <= cin;

    -- Connecter la retenue de sortie finale au port cout
    cout <= c(4);

    -- Instancier les 4 additionneurs 1 bit
    -- Etage 0 (LSB)
    add1_0 : add1 -- Référence au composant
        port map (a=>a(0), b=>b(0), cin=>c(0), s=>s(0), cout=>c(1));

    -- Etage 1
    add1_1 : add1
        port map (a=>a(1), b=>b(1), cin=>c(1), s=>s(1), cout=>c(2));

    -- Etage 2
    add1_2 : add1
        port map (a=>a(2), b=>b(2), cin=>c(2), s=>s(2), cout=>c(3));

    -- Etage 3 (MSB)
    add1_3 : add1
        port map (a=>a(3), b=>b(3), cin=>c(3), s=>s(3), cout=>c(4));

END ARCHITECTURE struct_simple;
        </code></pre>
         <p>Cette description connecte explicitement chaque bit des entrées `a` et `b`, ainsi que les signaux de retenue intermédiaires `c(i)`, aux ports correspondants de chaque instance de l'additionneur 1 bit (`add1_0` à `add1_3`).</p>
         <p><em>(Note: La diapo utilise `entity work.add1(flot)` pour l'instanciation, remplacé ici par la méthode plus standard utilisant `component`.)</em></p>
    </div>

    <!-- Page 135: 4-bit Adder Generate Architecture -->
    <div class="slide" id="page135">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Additionneur 4 bits : Architecture avec Génération</h2>
        <p>Architecture structurelle utilisant une instruction `generate` pour créer les 4 instances de l'additionneur 1 bit de manière plus compacte et paramétrable.</p>
        <pre><code class="language-vhdl">
ARCHITECTURE struct_generate OF add4 IS
    -- Déclaration du composant additionneur 1 bit (identique à la précédente)
    component add1 is
        port( a,b,cin : in std_logic;
              s,cout : out std_logic);
    end component add1;

    -- Signal interne pour les retenues (identique)
    signal c : std_logic_vector(4 downto 0);

BEGIN
    -- Connexion des retenues d'entrée et de sortie (identique)
    c(0) <= cin;
    cout <= c(4);

    -- Boucle de génération pour instancier les 4 additionneurs
    instance_gen : for i in 0 to 3 generate -- Boucle pour i = 0, 1, 2, 3
        add1_i : add1 -- Instanciation d'un add1 pour chaque i
            port map (
                a    => a(i),     -- Connecte a(i) de l'entrée add4
                b    => b(i),     -- Connecte b(i) de l'entrée add4
                cin  => c(i),     -- Retenue d'entrée de l'étage i
                s    => s(i),     -- Somme de sortie de l'étage i
                cout => c(i+1)    -- Retenue de sortie de l'étage i (devient cin pour i+1)
            );
    end generate instance_gen; -- Fin de la boucle de génération

END ARCHITECTURE struct_generate;
        </code></pre>
        <ul>
             <li>L'instruction `for i in 0 to 3 generate ... end generate;` crée automatiquement 4 copies du code contenu à l'intérieur, une pour chaque valeur de `i` (0, 1, 2, 3).</li>
             <li>À l'intérieur de la boucle `generate`, l'indice `i` peut être utilisé pour accéder aux bits spécifiques des vecteurs `a`, `b`, `s` et `c`.</li>
             <li>C'est une manière beaucoup plus élégante et maintenable de décrire des structures régulières et répétitives comme l'additionneur à propagation de retenue, surtout pour un grand nombre de bits.</li>
        </ul>
         <p><em>(Note: La diapo utilise `entity work.add1(flot)` pour l'instanciation, remplacé ici par la méthode plus standard utilisant `component`.)</em></p>
    </div>

    <!-- Page 136: Array Multiplier -->
    <div class="slide" id="page136">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Multiplieur</h2>
        <p>Implémentation d'un multiplieur combinatoire, souvent basée sur l'<strong>algorithme de multiplication "papier-crayon"</strong>.</p>
        <ul>
             <li>Principe : Générer les produits partiels (chaque bit du multiplicande multiplié par chaque bit du multiplicateur - opération AND), puis sommer ces produits partiels décalés.</li>
             <li>Structure : Souvent réalisée sous forme d'un <strong>multiplieur en réseau (Array Multiplier)</strong>.</li>
             <li>Complexité : Pour multiplier un nombre de \( n \) bits par un nombre de \( m \) bits, cela nécessite environ \( n \times m \) portes AND pour générer les produits partiels et une structure d'additionneurs (souvent des additionneurs complets organisés en réseau) pour sommer les produits partiels. Le nombre d'additions dépend de la structure exacte. La diapo mentionne "\( n \times m \) additions de \( n \) bits", ce qui est une approximation de la complexité.</li>
        </ul>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_array_multiplier.png" alt="Schéma d'un multiplieur en réseau (Array Multiplier)" style="border: 1px solid #ccc; padding: 10px; max-width: 500px;">
             <p style="color: #666;">[Placeholder for Array Multiplier Schematic]</p>
        </div>
        <p>Le schéma montre un exemple (probablement 3 bits x 3 bits). Chaque intersection génère un produit partiel (AND, implicite dans le schéma où les lignes se croisent?). Ces produits sont ensuite sommés par des additionneurs complets (représentés par des boîtes avec entrées a, b, ci et sorties s, ci+1) pour former le résultat final (p0 à p5).</p>
    </div>

    <!-- Page 137: VHDL Time Modeling -->
    <div class="slide" id="page137">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément VHDL : Modélisation du temps</h2>
        <p>VHDL permet non seulement de décrire la logique d'un circuit, mais aussi de modéliser son <strong>comportement temporel</strong>, ce qui est essentiel pour la simulation.</p>
        <ul>
             <li>La clause <strong>`after`</strong> peut être utilisée dans les affectations de signaux pour spécifier un délai de propagation.</li>
        </ul>
        <p>Exemple : Modélisation d'une porte ET avec un délai de 25 nanosecondes.</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

entity mon_et_delayed is -- Nom modifié pour clarté
    port(
        a, b : in  std_logic;
        s    : out std_logic
    );
end entity mon_et_delayed;

architecture flot of mon_et_delayed is
begin
    -- Affecte le résultat de (a and b) au signal s
    -- MAIS seulement après un délai de 25 ns
    s <= a and b after 25 ns;
end architecture flot;
        </code></pre>
        <ul>
            <li>Cette description est utile pour la <strong>simulation</strong> afin d'obtenir des chronogrammes plus réalistes.</li>
            <li>La clause `after` est généralement <strong>ignorée par les outils de synthèse</strong>. Les délais réels du circuit synthétisé dépendront de la technologie cible, du placement et du routage, et non de la valeur spécifiée dans le code VHDL avec `after`.</li>
            <li>Pour une analyse temporelle précise après synthèse, on utilise des simulations post-synthèse ou post-layout qui incorporent les délais réels extraits par les outils (souvent via des fichiers SDF - Standard Delay Format).</li>
        </ul>
    </div>

    <!-- Page 138: VHDL Concatenation and Slicing -->
    <div class="slide" id="page138">
        <div class="header-small">Cours d'électronique numérique - Logique Combinatoire</div>
        <h2 class="slide-title">Complément VHDL : Décalage et mise à l'échelle (Concaténation)</h2>
        <p>VHDL fournit des opérateurs pour manipuler les vecteurs de bits, notamment pour le décalage ou l'extension par concaténation.</p>
        <ul>
             <li>L'opérateur de <strong>concaténation</strong> est <strong>`&`</strong>. Il permet de joindre des bits ou des vecteurs pour en former un plus grand.</li>
             <li>Le <strong>slicing</strong> (extraction de sous-vecteurs) utilise la notation `(range)`, par exemple `a(3 downto 1)`.</li>
        </ul>
        <p>Exemple de concaténation pour réaliser des décalages ou des mises à l'échelle (changement de taille de vecteur) :</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;

entity conversion is
    port(
        a  : in  std_logic_vector(5 downto 0); -- Entrée 6 bits
        -- Sorties 12 bits
        s, s2, s3 : out std_logic_vector(11 downto 0)
    );
end entity conversion;

architecture flot of conversion is
    -- Signal pour affecter une valeur à 'a' pour l'exemple
    -- (Normalement 'a' est une entrée externe)
    signal a_internal : std_logic_vector(5 downto 0) := "010101";
begin
    -- Affectation interne pour l'exemple (ne serait pas dans un design réel)
    -- a <= "010101"; -- !! Affecter une entrée n'est pas possible !!

    -- s <= "0000" & a & "00";
    -- Concatène 4 zéros, les 6 bits de 'a', et 2 zéros.
    -- Si a = "010101", alors s = "0000" & "010101" & "00" = "000001010100"
    s <= "0000" & a_internal & "00"; -- Utilise le signal interne

    -- s2 <= "00000" & a & '0';
    -- Concatène 5 zéros, les 6 bits de 'a', et 1 zéro.
    -- Si a = "010101", alors s2 = "00000" & "010101" & '0' = "000000101010"
    s2 <= "00000" & a_internal & '0';

    -- s3 <= a & "000000";
    -- Concatène les 6 bits de 'a' et 6 zéros.
    -- Si a = "010101", alors s3 = "010101" & "000000" = "010101000000"
    s3 <= a_internal & "000000";

end architecture flot;
        </code></pre>
        <p>Cet exemple montre comment utiliser la concaténation (`&`) pour positionner un vecteur (`a`) à l'intérieur d'un vecteur plus large (`s`, `s2`, `s3`), en ajoutant des zéros à gauche ou à droite, ce qui est utile pour l'alignement des données, les décalages logiques ou la mise à l'échelle.</p>
        <p><em>(Note: Le code original affecte une valeur à l'entrée `a`, ce qui n'est pas possible. L'exemple a été corrigé en utilisant un signal interne `a_internal` pour illustrer le fonctionnement de la concaténation).</em></p>
    </div>

    <!-- Page 139: Course Plan - Sequential Logic -->
    <div class="slide" id="page139">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Plan du Cours</h2>
        <p>Progression dans le plan du cours :</p>
        <ul>
             <li>Introduction</li>
             <li>Algèbre de Boole et Logique Combinatoire</li>
             <li>Introduction au VHDL</li>
             <li>Fonctions Combinatoires Simples</li>
             <li>Fonctions Combinatoires Complexes <span style="color: #666;">(Fin de section)</span></li>
             <li><strong style="color: #dc3545;">Eléments séquentiels de base : Les Bascules</strong> <span style="color: #666;">(Prochaine section)</span></li>
             <li>Fonctions Séquentielles Complexes</li>
             <li>Pipeline</li>
             <li>Technologie des circuits numériques</li>
             <li>Les Convertisseurs Analogiques-Numériques et Numériques-Analogiques</li>
        </ul>
         <p>La section suivante introduit les circuits séquentiels, dont la sortie dépend non seulement des entrées actuelles mais aussi de l'état précédent (mémoire).</p>
    </div>

    <!-- Page 140: Basic Sequential Elements Introduction -->
    <div class="slide" id="page140">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les éléments séquentiels de base</h2>
        <p>Contrairement aux circuits combinatoires, les circuits séquentiels possèdent une mémoire interne.</p>
        <ul>
            <li><strong>Eléments de base :</strong> Les composants fondamentaux des circuits séquentiels sont les éléments de mémorisation (bascules, registres).</li>
            <li><strong>Régulation du flux des données :</strong> Les circuits séquentiels permettent de contrôler quand et comment les données sont traitées et déplacées dans un système numérique, souvent en synchronisation avec un signal d'horloge.</li>
            <li><strong>Fonction Mémorisation :</strong> Leur caractéristique clé est la capacité à conserver un état (une valeur binaire) même après la disparition de l'entrée qui l'a causé.</li>
             <li><strong>Eléments Asynchrones :</strong> Leur état peut changer à tout moment en réponse à un changement des entrées (ex: bascules RS simples). Ils sont sensibles aux aléas et plus difficiles à concevoir de manière fiable pour des systèmes complexes.</li>
             <li><strong>Eléments Synchrones :</strong> Leur état ne change qu'à des instants précis, déterminés par un signal d'horloge (clock). C'est l'approche dominante pour la conception de systèmes numériques complexes car elle facilite la synchronisation et la gestion du temps. Les changements d'état se produisent typiquement sur les fronts (montants ou descendants) de l'horloge (ex: bascules D, JK, T synchrones).</li>
        </ul>
        <p>Les bascules (latches et flip-flops) sont les briques de construction de la mémoire et des machines à états finis.</p>
    </div>


    <!-- End of added content -->
    <!-- Continuing the document... -->

    <!-- Section Transition: Sequential Logic -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Logique Séquentielle</h2>

    <!-- Page 141: Asynchronous Elements Title -->
    <div class="slide" id="page141">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Eléments Asynchrones</h2>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Les Bascules Asynchrones
        </div>
        <p style="text-align: center; margin-top: 20px;">Introduction aux éléments de mémoire de base dont l'état peut changer indépendamment d'un signal d'horloge, en réponse directe aux changements des entrées.</p>
    </div>

    <!-- Page 142: RS Latch Schematic (NOR based) -->
    <div class="slide" id="page142">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule RS (Latch RS Asynchrone)</h2>
        <p>Une des bascules les plus fondamentales, construite ici avec deux portes NON-OU (NOR) interconnectées (rétroaction).</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_rs_latch_nor.png" alt="Schéma d'une bascule RS asynchrone à base de portes NOR" style="max-width: 400px;">
             <p style="color: #666;">[Placeholder for NOR-based RS Latch Schematic]</p>
        </div>
        <ul>
            <li>Entrées : Généralement notées R (Reset) et S (Set). Sur ce schéma, les entrées sont les lignes arrivant sur les portes NOR (en bas pour S, en haut pour R - convention à vérifier).</li>
            <li>Sorties : Q et \( \bar{Q} \). Elles sont normalement complémentaires.</li>
            <li>Fonctionnement : La rétroaction permet au circuit de "mémoriser" un état (0 ou 1). Les entrées R et S permettent de forcer l'état mémorisé.</li>
            <li>Les '0' sur le schéma indiquent un état stable possible (quand R=0, S=0, la sortie peut être Q=0, \(\bar{Q}\)=1 ou Q=1, \(\bar{Q}\)=0).</li>
        </ul>
    </div>

    <!-- Page 143: RS Latch Truth Table -->
    <div class="slide" id="page143">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule RS</h2>
        <p>Comportement de la bascule RS (construite avec des portes NOR) :</p>
        <ul>
             <li><strong>Table de Vérité :</strong> (Q représente l'état précédent de la sortie Q, \( \bar{Q} \) l'état précédent de la sortie complémentaire)</li>
        </ul>
         <table border="1">
             <thead>
                 <tr><th>R</th><th>S</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation (Hold)</td></tr>
                 <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Mise à 1 (Set)</td></tr>
                 <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Mise à 0 (Reset)</td></tr>
                 <tr><td>1</td><td>1</td><td style="border-left: 2px solid black; background-color: #ffdddd;">0?</td><td style="background-color: #ffdddd;">0?</td><td style="background-color: #ffdddd;">Etat Interdit (Invalid)</td></tr>
             </tbody>
         </table>
         <p>Explication des modes :</p>
         <ul>
            <li><strong>R=0, S=0 :</strong> Les sorties conservent leur état précédent (Mémorisation).</li>
            <li><strong>R=0, S=1 :</strong> Force la sortie Q à 1 (Set), et \( \bar{Q} \) à 0.</li>
            <li><strong>R=1, S=0 :</strong> Force la sortie Q à 0 (Reset), et \( \bar{Q} \) à 1.</li>
            <li><strong>R=1, S=1 :</strong> Cette combinaison est <strong>interdite</strong> pour une bascule RS NOR car elle force les deux sorties Q et \( \bar{Q} \) à 0 simultanément, ce qui contredit leur nature complémentaire. De plus, si R et S retournent à 0 simultanément après cet état, l'état futur est indéterminé (course critique).</li>
         </ul>
         <ul>
            <li>C'est un <strong>Elément Asynchrone :</strong> Les sorties réagissent directement aux changements de R et S (après le délai des portes).</li>
            <li>C'est la <strong>Base de toutes les bascules :</strong> Les bascules plus complexes (synchrones, D, JK, T) sont souvent construites à partir de cette structure de base ou d'une structure RS NAND équivalente.</li>
        </ul>
    </div>

    <!-- Page 144: (Ungated) D Latch Schematic -->
    <div class="slide" id="page144">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D (Latch D Asynchrone/Transparent)</h2>
        <p>Une bascule D simple (non cadencée, ou "transparente") peut être dérivée d'une bascule RS en ajoutant un inverseur. L'objectif est d'éviter l'état interdit R=1, S=1.</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_d_latch_ungated.png" alt="Schéma d'une bascule D asynchrone (transparente)" style="max-width: 450px;">
             <p style="color: #666;">[Placeholder for Ungated D Latch Schematic]</p>
         </div>
         <ul>
             <li>Entrée : D (Data).</li>
             <li>L'entrée D est connectée directement à l'entrée S de la bascule RS sous-jacente.</li>
             <li>L'inverse de D (\( \bar{D} \)) est connecté à l'entrée R.</li>
             <li>Fonctionnement :
                 <ul>
                     <li>Si D=1 : alors S=1, R=0 => Q passe à 1 (Set).</li>
                     <li>Si D=0 : alors S=0, R=1 => Q passe à 0 (Reset).</li>
                 </ul>
             </li>
             <li>La sortie Q suit donc <strong>directement</strong> la valeur de l'entrée D. On dit qu'elle est "transparente".</li>
            <li>Ce type de bascule simple n'est pas très utile en soi pour la mémorisation contrôlée, mais constitue la base des bascules D synchrones.</li>
            <li>Les valeurs 0 et 1 sur le schéma illustrent un état possible (D=1, donc S=1, R=0, forçant Q=1, \(\bar{Q}\)=0).</li>
         </ul>
    </div>

    <!-- Page 145: D Latch/Flip-Flop Symbol -->
    <div class="slide" id="page145">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D</h2>
        <p>Symbole schématique générique pour un élément de mémorisation de type D (peut représenter un latch ou un flip-flop selon le contexte et les autres entrées non montrées comme l'horloge).</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_d_element_symbol.png" alt="Symbole schématique d'une bascule D" style="max-width: 250px;">
             <p style="color: #666;">[Placeholder for D-type element Symbol]</p>
        </div>
        <ul>
            <li>Entrée : D (Donnée).</li>
            <li>Sortie principale : Q (recopie la valeur de D au moment approprié).</li>
            <li>Sortie complémentaire (optionnelle mais fréquente) : \( \bar{Q} \).</li>
        </ul>
    </div>

    <!-- Page 146: Synchronous Elements Title -->
    <div class="slide" id="page146">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Eléments Synchrones</h2>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
             Bascules Synchrones
        </div>
        <p style="text-align: center; margin-top: 20px;">Introduction aux éléments de mémoire dont le changement d'état est contrôlé par un signal d'horloge, permettant la synchronisation dans les systèmes numériques.</p>
    </div>

    <!-- Page 147: Gated D Latch (Level-Triggered) Schematic -->
    <div class="slide" id="page147">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur niveau (Gated D Latch)</h2>
        <p>Une bascule D synchrone simple est la <strong>bascule D active sur niveau</strong> (ou verrou D, Gated D Latch).</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_d_latch_gated.png" alt="Schéma d'une bascule D active sur niveau (Gated D Latch)" style="max-width: 500px;">
             <p style="color: #666;">[Placeholder for Gated D Latch Schematic]</p>
        </div>
        <ul>
             <li>Elle possède une entrée de données D et une entrée de commande supplémentaire, souvent appelée Enable (EN), Gate (G) ou Clock (CK/CLK), ici nommée H sur la diapo suivante.</li>
            <li>Fonctionnement :
                <ul>
                    <li>Quand l'entrée de commande (H) est <strong>active</strong> (par exemple, H=1) : la bascule est "transparente", la sortie Q suit la valeur de l'entrée D.</li>
                    <li>Quand l'entrée de commande (H) est <strong>inactive</strong> (par exemple, H=0) : la bascule est "verrouillée" (latched), la sortie Q conserve la dernière valeur qu'elle avait juste avant que H ne devienne inactive, indépendamment des changements de D.</li>
                </ul>
             </li>
             <li>Le schéma montre une implémentation possible utilisant une bascule RS NOR comme cœur, précédée de portes ET (AND) pour le contrôle par l'entrée H et D.
                <ul>
                    <li>Si H=0, les sorties des deux portes ET sont à 0, mettant la bascule RS en mode mémorisation.</li>
                    <li>Si H=1, les sorties des portes ET transmettent \( \bar{D} \) à R et \( D \) à S, forçant Q à prendre la valeur de D.</li>
                </ul>
            </li>
             <li>Ce type de bascule est dit "sensible au niveau" (level-sensitive).</li>
        </ul>
    </div>

    <!-- Page 148: Gated D Latch Timing Diagram -->
    <div class="slide" id="page148">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur niveau</h2>
        <p>Chronogramme illustrant le comportement de la bascule D active sur niveau :</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_d_latch_timing.png" alt="Chronogramme d'une bascule D active sur niveau" style="max-width: 600px;">
            <p style="color: #666;">[Placeholder for Level-Triggered D Latch Timing Diagram]</p>
        </div>
        <ul>
            <li>H : Signal de commande (Enable/Clock). Actif haut ici.</li>
            <li>D : Entrée de données.</li>
            <li>Q : Sortie de la bascule.</li>
        </ul>
        <p>Observations :</p>
        <ul>
            <li>Lorsque H est à 1 (périodes encadrées par les lignes vertes), la sortie Q suit les variations de l'entrée D (mode transparent).</li>
            <li>Lorsque H est à 0 (périodes avant la première ligne verte, entre les lignes rouges et vertes, après la dernière ligne verte), la sortie Q conserve la dernière valeur qu'elle avait lorsque H était à 1 (mode verrouillé/mémorisation), quels que soient les changements de D pendant ce temps.</li>
            <li>Les lignes rouges marquent les transitions descendantes de H où l'état est mémorisé.</li>
        </ul>
    </div>

    <!-- Page 149: Gated D Latch Symbol -->
    <div class="slide" id="page149">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur niveau</h2>
        <p>Symbole schématique pour une bascule D active sur niveau (Gated D Latch) :</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_d_latch_symbol_gated.png" alt="Symbole schématique d'une bascule D active sur niveau" style="max-width: 250px;">
            <p style="color: #666;">[Placeholder for Gated D Latch Symbol]</p>
        </div>
        <ul>
            <li>Entrée D : Donnée.</li>
             <li>Entrée CK (ou H, EN, G) : Horloge ou signal de validation (Enable). L'absence de triangle sur cette entrée indique généralement une sensibilité au niveau (par opposition à une sensibilité aux fronts).</li>
             <li>Sortie Q : Sortie principale.</li>
             <li>Sortie \( \bar{Q} \) : Sortie complémentaire.</li>
        </ul>
    </div>

    <!-- Page 150: Gated D Latch Truth Table -->
    <div class="slide" id="page150">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur niveau</h2>
        <p><strong>Table de Vérité</strong> (caractéristique) de la bascule D active sur niveau (Gated D Latch) :</p>
        <ul>
            <li>H est l'entrée de commande (Enable/Clock).</li>
            <li>D est l'entrée de donnée.</li>
             <li>Q<sub>n</sub> est l'état actuel (avant l'évaluation).</li>
             <li>Q<sub>n+1</sub> est l'état suivant (après évaluation).</li>
        </ul>
        <div style="display: flex; justify-content: space-around;">
            <div>
                <p>Table Complète :</p>
                <table border="1">
                    <thead>
                         <tr><th>D</th><th>H</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
                    </thead>
                    <tbody>
                        <!-- Cas H = 0 (Inactive / Verrouillé) -->
                        <tr><td>0</td><td>0</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
                        <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
                         <!-- Cas H = 1 (Active / Transparent) -->
                         <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Reset (suit D)</td></tr>
                         <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Set (suit D)</td></tr>
                     </tbody>
                </table>
            </div>
             <div>
                <p>Table Simplifiée :</p>
                <table border="1">
                     <thead>
                         <tr><th>D</th><th>H</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th></tr>
                     </thead>
                    <tbody>
                         <tr><td>X</td><td>0</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td></tr> <!-- H=0 -> Mémorise (D indifférent 'X') -->
                         <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td></tr> <!-- H=1 -> Q suit D -->
                         <tr><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td></tr> <!-- H=1 -> Q suit D -->
                     </tbody>
                 </table>
            </div>
         </div>
         <p>La table simplifiée montre plus clairement :</p>
         <ul>
             <li>Si H=0, l'état est mémorisé (Q<sub>n+1</sub> = Q<sub>n</sub>), quelle que soit la valeur de D (noté 'X' pour indifférent).</li>
             <li>Si H=1, l'état de sortie Q<sub>n+1</sub> prend la valeur de D.</li>
         </ul>
    </div>

    <!-- Continuing the document... -->

    <!-- Page 151: D Latch Application Example (Shift Register) -->
    <div class="slide" id="page151">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur niveau : chenillard</h2>
        <p>Exemple d'utilisation de bascules D actives sur niveau : tentative de construction d'un registre à décalage (ou "chenillard").</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_latch_shift_register.png" alt="Registre à décalage (chenillard) construit avec des bascules D actives sur niveau" style="max-width: 600px;">
            <p style="color: #666;">[Placeholder for Level-Triggered D Latch Shift Register]</p>
        </div>
        <p>Structure :</p>
        <ul>
            <li>Plusieurs bascules D (ici 4) sont connectées en chaîne : la sortie Q de l'une est connectée à l'entrée D de la suivante.</li>
            <li>Toutes les bascules partagent le même signal de commande (horloge) H (CK).</li>
            <li>L'entrée D de la première bascule reçoit la donnée à faire entrer dans le registre.</li>
            <li>Les points rouges pourraient représenter des LEDs connectées aux sorties Q pour visualiser l'état.</li>
        </ul>
        <p>Problème avec les bascules actives sur niveau (latches) :</p>
        <ul>
            <li>Lorsque l'horloge H est active (niveau haut), toutes les bascules sont transparentes.</li>
            <li>Un changement sur l'entrée D de la première bascule peut se propager très rapidement à travers toute la chaîne pendant que H est haut, au lieu de se décaler d'une seule position par cycle d'horloge.</li>
            <li>Ce comportement n'est généralement pas celui souhaité pour un registre à décalage standard. C'est pourquoi on utilise plutôt des bascules actives sur front (flip-flops).</li>
        </ul>
        <p>(Les '1' sur le schéma peuvent indiquer une condition initiale ou une valeur de donnée appliquée).</p>
    </div>

    <!-- Page 152: Edge-Triggered D Flip-Flop (Master-Slave) -->
    <div class="slide" id="page152">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur front (Edge-Triggered D Flip-Flop)</h2>
        <p>Pour résoudre le problème de transparence des latches, on utilise des <strong>bascules actives sur front</strong> (Flip-Flops), qui ne changent d'état qu'au moment précis d'une transition de l'horloge (front montant ou front descendant).</p>
        <p>Une architecture classique pour réaliser cela est l'architecture <strong>Maître-Esclave (Master-Slave)</strong> :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_d_ff_master_slave.png" alt="Schéma d'une bascule D Maître-Esclave active sur front" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for Master-Slave D Flip-Flop Schematic]</p>
        </div>
         <ul>
             <li>Elle est composée de deux latches D (ou RS modifiées) en série : le Maître et l'Esclave.</li>
             <li>L'horloge H contrôle le Maître directement.</li>
             <li>L'horloge H <strong>inversée</strong> contrôle l'Esclave.</li>
             <li>Fonctionnement (pour un flip-flop sensible au front descendant, comme semble l'indiquer la connexion de l'horloge H et son inverse) :
                <ul>
                    <li>Quand H=1 (niveau haut) : Le Maître est transparent (suit l'entrée D), mais l'Esclave est verrouillé (conserve sa valeur précédente).</li>
                    <li>Quand H passe de 1 à 0 (<strong>front descendant</strong>) :
                        <ol>
                            <li>Le Maître se verrouille, mémorisant la valeur de D juste avant le front.</li>
                            <li>L'Esclave devient transparent (car son horloge inversée passe à 1).</li>
                             <li>L'Esclave recopie alors la valeur mémorisée par le Maître sur la sortie finale Q.</li>
                        </ol>
                    </li>
                     <li>Quand H=0 (niveau bas) : Le Maître reste verrouillé, l'Esclave reste transparent mais sa sortie ne change plus car l'entrée (venant du Maître verrouillé) est stable.</li>
                 </ul>
             </li>
            <li>Résultat : La sortie Q ne change qu'au moment du front actif de l'horloge (ici, descendant), et elle prend la valeur qu'avait D juste avant ce front.</li>
         </ul>
    </div>

    <!-- Page 153: Edge-Triggered D Flip-Flop Symbol -->
    <div class="slide" id="page153">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur front</h2>
        <p>Symbole schématique pour une bascule D <strong>active sur front</strong> (Edge-Triggered D Flip-Flop) :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_d_ff_symbol.png" alt="Symbole schématique d'une bascule D active sur front" style="max-width: 250px;">
             <p style="color: #666;">[Placeholder for Edge-Triggered D Flip-Flop Symbol]</p>
        </div>
        <ul>
             <li>Entrée D : Donnée.</li>
             <li>Entrée CK (ou CLK) : Horloge. La présence d'un <strong>triangle (>)</strong> sur l'entrée d'horloge indique qu'elle est sensible à un <strong>front</strong> (transition) et non à un niveau.
                 <ul>
                     <li>Un triangle seul indique généralement une sensibilité au front montant (↑).</li>
                     <li>Un triangle précédé d'un cercle d'inversion (comme >o) indique une sensibilité au front descendant (↓). (Le symbole ici montre un front montant).</li>
                 </ul>
             </li>
             <li>Sortie Q : Sortie principale.</li>
             <li>Sortie \( \bar{Q} \) : Sortie complémentaire.</li>
        </ul>
    </div>

    <!-- Page 154: Edge-Triggered D Flip-Flop Truth Table -->
    <div class="slide" id="page154">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur front</h2>
        <p><strong>Table de Vérité</strong> (caractéristique) de la bascule D active sur front (Edge-Triggered D Flip-Flop) :</p>
        <p>La sortie Q<sub>n+1</sub> ne change que sur le front actif de l'horloge (H ou CK). On utilise des symboles pour représenter les fronts :</p>
        <ul>
            <li>\( \uparrow \) : Front montant (transition 0 -> 1)</li>
            <li>\( \downarrow \) : Front descendant (transition 1 -> 0)</li>
            <li>X : Indifférent (0 ou 1)</li>
            <li>0, 1 : Niveaux stables de l'horloge</li>
        </ul>

        <p>Exemple pour une bascule sensible au <strong>front descendant</strong> ( \( \downarrow \) ) :</p>
        <table border="1">
             <thead>
                <tr><th>D</th><th>H (Horloge)</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
             </thead>
             <tbody>
                 <!-- Pas de front descendant -->
                 <tr><td>X</td><td>0 (stable)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
                 <tr><td>X</td><td>1 (stable)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
                 <tr><td>X</td><td>\( \uparrow \) (front montant)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
                 <!-- Front descendant actif -->
                 <tr><td>0</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Reset (capture D=0)</td></tr>
                 <tr><td>1</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Set (capture D=1)</td></tr>
             </tbody>
        </table>
         <p><em>(Note: La diapositive originale présente une table mixte étrange. La table ci-dessus est plus standard pour décrire le comportement sur front descendant. Pour un front montant, on remplacerait \( \downarrow \) par \( \uparrow \)).</em></p>
         <p>En résumé : Sur le front actif de l'horloge, la sortie Q prend la valeur de l'entrée D. À tous les autres moments (niveaux stables, front inactif), la sortie Q conserve sa valeur précédente.</p>
    </div>

    <!-- Page 155: Edge-Triggered D Flip-Flop Shift Register -->
    <div class="slide" id="page155">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur front : chenillar</h2>
        <p>Utilisation de bascules D <strong>actives sur front</strong> (flip-flops) pour construire un registre à décalage ("chenillard") fonctionnel :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_ff_shift_register.png" alt="Registre à décalage (chenillard) construit avec des bascules D actives sur front" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for Edge-Triggered D Flip-Flop Shift Register]</p>
        </div>
        <ul>
            <li>Structure : Identique à celle vue avec les latches (page 151), mais en utilisant des flip-flops (symbolisés par le triangle sur l'entrée CK).</li>
            <li>Fonctionnement :
                 <ul>
                     <li>Sur chaque <strong>front actif</strong> de l'horloge CK (par exemple, front montant si indiqué par >) :</li>
                     <li>Chaque flip-flop capture la valeur présente sur son entrée D (qui est la sortie Q du flip-flop précédent).</li>
                     <li>La donnée présente sur l'entrée D du premier flip-flop entre dans le registre.</li>
                    <li>Les données se décalent ainsi d'une position vers la droite à chaque coup d'horloge.</li>
                </ul>
             </li>
             <li>Les flip-flops n'étant pas transparents entre les fronts d'horloge, la donnée ne "traverse" pas toute la chaîne en un seul cycle, mais progresse d'un étage par cycle.</li>
             <li>Les cercles rouges et blancs pourraient indiquer l'état des sorties (par exemple, '1' pour rouge, '0' pour blanc) à un instant donné, montrant le décalage d'un motif.</li>
             <li>L'annotation "1 -> 0" sur l'entrée du premier flip-flop pourrait indiquer la donnée entrant dans le registre à cet instant. Les chiffres "1" et "0" sur les sorties Q indiquent l'état mémorisé après le front d'horloge.</li>
         </ul>
    </div>

    <!-- Page 156: Setup and Hold Times -->
    <div class="slide" id="page156">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule D active sur front : Considérations Temporelles</h2>
        <p>Pour qu'une bascule active sur front (flip-flop) fonctionne correctement, les signaux d'entrée (en particulier l'entrée de donnée D) doivent respecter des contraintes temporelles par rapport au front actif de l'horloge CK.</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_setup_hold_timing.png" alt="Diagramme illustrant les temps de setup et de hold" style="max-width: 600px;">
             <p style="color: #666;">[Placeholder for Setup/Hold Timing Diagram]</p>
        </div>
        <ul>
             <li><strong>Temps de prépositionnement (Setup Time, \( t_s \)) :</strong>
                <ul>
                    <li>C'est la durée minimale pendant laquelle l'entrée de donnée D doit être <strong>stable</strong> (maintenue à une valeur constante 0 ou 1) <strong>avant</strong> l'arrivée du front actif de l'horloge CK.</li>
                    <li>Si D change pendant l'intervalle \( t_s \) avant le front, la valeur capturée par le flip-flop est incertaine (état métastable possible).</li>
                </ul>
            </li>
            <li><strong>Temps de maintien (Hold Time, \( t_h \)) :</strong>
                <ul>
                    <li>C'est la durée minimale pendant laquelle l'entrée de donnée D doit rester <strong>stable</strong> <strong>après</strong> le front actif de l'horloge CK.</li>
                     <li>Si D change pendant l'intervalle \( t_h \) après le front, la valeur capturée peut être corrompue.</li>
                 </ul>
             </li>
             <li>La période entre \( t_s \) avant le front et \( t_h \) après le front est la "fenêtre de capture" pendant laquelle D doit être stable.</li>
             <li>Le non-respect des temps de setup et de hold est une cause fréquente de dysfonctionnements dans les circuits synchrones. Les outils d'analyse temporelle vérifient ces contraintes.</li>
        </ul>
    </div>

    <!-- Page 157: Edge-Triggered D Flip-Flop VHDL -->
    <div class="slide" id="page157">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Vhdl : Bascule D active sur front</h2>
        <p>Code VHDL pour une bascule D active sur <strong>front montant</strong> de l'horloge.</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all; -- Non requis pour ce code simple

entity bascule is -- Nom générique pour flip-flop
    port (
        d   : in  std_logic;     -- Entrée de donnée
        clk : in  std_logic;     -- Entrée d'horloge
        q   : out std_logic      -- Sortie
    );
end entity bascule;

architecture comport of bascule is
begin
    -- Process sensible aux changements sur clk
    -- (La sensibilité à 'd' est redondante ici mais pas fausse)
    stockage : process(clk) is -- Sensibilité à clk est suffisante
    begin
        -- Vérifie si un événement s'est produit sur clk ET si clk est maintenant à '1'
        -- C'est la détection standard d'un front montant
        if clk = '1' and clk'event then
        -- Alternative standard: if rising_edge(clk) then
            -- Si front montant, la sortie q prend la valeur de l'entrée d
            q <= d;
        end if;
        -- Si pas de front montant, la sortie q conserve sa valeur (comportement implicite de mémorisation)
    end process stockage;
end architecture comport;
        </code></pre>
        <ul>
            <li>Un <strong>`process`</strong> en VHDL contient des instructions qui s'exécutent séquentiellement lorsque l'un des signaux dans sa liste de sensibilité change (ici, `clk`).</li>
            <li><code>clk'event</code> est un attribut qui est vrai si un événement (changement de valeur) vient de se produire sur `clk`.</li>
            <li><code>clk = '1' and clk'event</code> détecte une transition de 0 à 1 (front montant). La fonction standard `rising_edge(clk)` (du package `std_logic_1164`) est généralement préférée pour cela.</li>
            <li>L'affectation `q <= d;` n'est effectuée <strong>que</strong> sur le front montant de `clk`.</li>
            <li>En dehors du front montant, le `process` se termine sans affecter `q`, ce qui, pour un signal dans un process, implique la mémorisation de sa valeur précédente (comportement d'une bascule).</li>
            <li>Ce style de code est la manière standard de décrire des éléments synchrones (flip-flops, registres) en VHDL et est bien compris par les outils de synthèse.</li>
        </ul>
    </div>

    <!-- Page 158: JK Flip-Flop Truth Table -->
    <div class="slide" id="page158">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule JK</h2>
        <p>La bascule JK est une bascule synchrone polyvalente, similaire à la RS, mais sans état interdit et avec un mode supplémentaire "basculement" (toggle).</p>
        <p>Table de Vérité caractéristique (Q<sub>n</sub> = état avant le front, Q<sub>n+1</sub> = état après le front) :</p>

        <p><strong>Activation sur Front Montant ( \( \uparrow \) ) :</strong></p>
        <table border="1">
            <thead>
                <tr><th>J</th><th>K</th><th>H (Horloge)</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
            </thead>
            <tbody>
                <tr><td>0</td><td>0</td><td>\( \uparrow \)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation (Hold)</td></tr>
                <tr><td>0</td><td>1</td><td>\( \uparrow \)</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Mise à 0 (Reset)</td></tr>
                <tr><td>1</td><td>0</td><td>\( \uparrow \)</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Mise à 1 (Set)</td></tr>
                <tr><td>1</td><td>1</td><td>\( \uparrow \)</td><td style="border-left: 2px solid black;">\( \overline{Q}_n \)</td><td>Q<sub>n</sub></td><td>Basculement (Toggle)</td></tr>
                 <!-- Comportement hors front actif -->
                 <tr><td>X</td><td>X</td><td>autres (\(0, 1, \downarrow\))</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
            </tbody>
         </table>

        <p><strong>Activation sur Front Descendant ( \( \downarrow \) ) :</strong> (Même logique, mais déclenchée par \( \downarrow \) )</p>
         <table border="1">
            <thead>
                 <tr><th>J</th><th>K</th><th>H (Horloge)</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
             </thead>
             <tbody>
                <tr><td>0</td><td>0</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation (Hold)</td></tr>
                <tr><td>0</td><td>1</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Mise à 0 (Reset)</td></tr>
                <tr><td>1</td><td>0</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Mise à 1 (Set)</td></tr>
                <tr><td>1</td><td>1</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">\( \overline{Q}_n \)</td><td>Q<sub>n</sub></td><td>Basculement (Toggle)</td></tr>
                 <!-- Comportement hors front actif -->
                 <tr><td>X</td><td>X</td><td>autres (\(0, 1, \uparrow\))</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
             </tbody>
         </table>
        <p>Le mode "Toggle" (J=1, K=1) fait que la sortie Q inverse sa valeur à chaque front actif de l'horloge, ce qui est utile pour construire des compteurs.</p>
    </div>

    <!-- Page 159: JK Flip-Flop Symbol -->
    <div class="slide" id="page159">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Symbole Bascule JK</h2>
        <p>Symbole schématique pour une bascule JK active sur front :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_jk_ff_symbol.png" alt="Symbole schématique d'une bascule JK active sur front" style="max-width: 250px;">
             <p style="color: #666;">[Placeholder for JK Flip-Flop Symbol]</p>
        </div>
         <ul>
            <li>Entrée J (Set conditionnel).</li>
            <li>Entrée K (Reset conditionnel).</li>
            <li>Entrée CK (Horloge, avec triangle pour sensibilité au front).</li>
            <li>Sortie Q.</li>
            <li>Sortie \( \bar{Q} \).</li>
        </ul>
    </div>

    <!-- Page 160: T Flip-Flop Truth Table -->
    <div class="slide" id="page160">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">La bascule T (Toggle)</h2>
        <p>La bascule T est une bascule synchrone qui a une seule entrée de commande T. Elle peut être vue comme une bascule JK dont les entrées J et K sont reliées ensemble à T.</p>
        <p>Table de Vérité caractéristique :</p>

        <p><strong>Activation sur Front Montant ( \( \uparrow \) ) :</strong></p>
        <table border="1">
             <thead>
                 <tr><th>T</th><th>H (Horloge)</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
             </thead>
             <tbody>
                <tr><td>0</td><td>\( \uparrow \)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation (Hold)</td></tr>
                <tr><td>1</td><td>\( \uparrow \)</td><td style="border-left: 2px solid black;">\( \overline{Q}_n \)</td><td>Q<sub>n</sub></td><td>Basculement (Toggle)</td></tr>
                 <tr><td>X</td><td>autres</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
            </tbody>
         </table>

        <p><strong>Activation sur Front Descendant ( \( \downarrow \) ) :</strong></p>
        <table border="1">
             <thead>
                 <tr><th>T</th><th>H (Horloge)</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
             </thead>
             <tbody>
                 <tr><td>0</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation (Hold)</td></tr>
                 <tr><td>1</td><td>\( \downarrow \)</td><td style="border-left: 2px solid black;">\( \overline{Q}_n \)</td><td>Q<sub>n</sub></td><td>Basculement (Toggle)</td></tr>
                 <tr><td>X</td><td>autres</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
             </tbody>
         </table>
        <p>Si T=0, la sortie est mémorisée. Si T=1, la sortie inverse sa valeur (bascule) à chaque front actif de l'horloge. C'est très utile pour construire des diviseurs de fréquence et des compteurs binaires.</p>
    </div>

    <!-- Continuing the document... -->

    <!-- Page 161: T Flip-Flop Symbol -->
    <div class="slide" id="page161">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <!-- Le titre de la diapositive originale est "Symbole Bascule JK", mais l'image montre un symbole de bascule T. Correction du titre et du contenu. -->
        <h2 class="slide-title">Symbole Bascule T</h2>
        <p>Symbole schématique pour une bascule T (Toggle) active sur front :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_t_ff_symbol.png" alt="Symbole schématique d'une bascule T active sur front" style="max-width: 250px;">
             <p style="color: #666;">[Placeholder for T Flip-Flop Symbol]</p>
        </div>
         <ul>
             <li>Entrée T (Toggle).</li>
             <li>Entrée CK (Horloge, avec triangle pour sensibilité au front).</li>
             <li>Sortie Q.</li>
             <li>Sortie \( \bar{Q} \).</li>
         </ul>
         <p>Rappel : Si T=0, Q mémorise. Si T=1, Q bascule (inverse son état) sur le front actif de CK.</p>
    </div>

    <!-- Page 162: Asynchronous Inputs Introduction -->
    <div class="slide" id="page162">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Entrées Asynchrones</h2>
        <p>En plus des entrées synchrones (comme D, J, K, T contrôlées par l'horloge), les bascules possèdent souvent des entrées asynchrones.</p>
        <ul>
            <li><strong>Nécessité de forcer les sorties :</strong> Il est souvent utile de pouvoir placer une bascule dans un état connu (0 ou 1) indépendamment de l'horloge et des entrées synchrones, par exemple lors de l'initialisation (reset) ou pour gérer des conditions d'erreur.</li>
            <li><strong>Ajout d'entrées asynchrones :</strong> Ces entrées agissent immédiatement sur l'état de la bascule, sans attendre de front d'horloge. Elles ont généralement priorité sur les entrées synchrones.</li>
            <li>Terminologie courante :
                <ul>
                    <li><strong>RAU : Remise à Un</strong> (force Q à 1). Également appelée <strong>Preset</strong> ou entrée <strong>Set</strong> asynchrone en anglais.</li>
                    <li><strong>RAZ : Remise à Zéro</strong> (force Q à 0). Également appelée <strong>Clear</strong> ou entrée <strong>Reset</strong> asynchrone en anglais.</li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Page 163: Asynchronous Inputs D Flip-Flop -->
    <div class="slide" id="page163">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Entrées Asynchrones</h2>
        <p>Exemple : Bascule D active sur front avec entrées asynchrones Preset (RAU) et Clear (RAZ).</p>
        <div style="display: flex; align-items: center; justify-content: space-around; flex-wrap: wrap;">
            <div>
                <p>Symbole :</p>
                <img src="placeholder_dff_async_symbol.png" alt="Symbole d'une bascule D avec entrées asynchrones RAU/Preset et RAZ/Clear" style="max-width: 200px;">
                <p style="color: #666;">[Placeholder: D-FF Async Symbol]</p>
            </div>
            <div>
                <p>Table de vérité (simplifiée, H=\(\uparrow\) = Front montant) :</p>
                <table border="1">
                    <thead>
                         <tr><th>D</th><th>H</th><th>RAU</th><th>RAZ</th><th style="border-left: 2px solid black;">Q<sub>n+1</sub></th><th>\( \overline{Q}_{n+1} \)</th><th>Mode</th></tr>
                    </thead>
                    <tbody>
                        <!-- Cas Asynchrones prioritaires -->
                        <tr style="background-color: #fff3cd;"><td>X</td><td>X</td><td>1</td><td>0</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Preset Asynchrone</td></tr>
                        <tr style="background-color: #fff3cd;"><td>X</td><td>X</td><td>0</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Clear Asynchrone</td></tr>
                        <tr style="background-color: #ffdddd;"><td>X</td><td>X</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">?</td><td>?</td><td>Interdit / Indéfini</td></tr>
                         <!-- Cas Synchrone (si RAU=0, RAZ=0) -->
                        <tr><td>0</td><td>\( \uparrow \)</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>Synchrone (capture D=0)</td></tr>
                        <tr><td>1</td><td>\( \uparrow \)</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>Synchrone (capture D=1)</td></tr>
                         <!-- Mémorisation hors front actif -->
                         <tr><td>X</td><td>autres</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">Q<sub>n</sub></td><td>\( \overline{Q}_n \)</td><td>Mémorisation</td></tr>
                     </tbody>
                 </table>
            </div>
        </div>
        <ul>
            <li>Les entrées RAU et RAZ sont prioritaires : si l'une est active (ici, à '1'), elle force la sortie indépendamment de D et CK.</li>
             <li>La combinaison <strong>RAU=1 ET RAZ=1 est interdite</strong> car elle tente de forcer Q à 1 et 0 simultanément.</li>
            <li>Souvent, les entrées asynchrones sont <strong>actives à 0</strong> (active-low), ce qui est indiqué par un cercle sur le symbole. Dans ce cas, RAU=0 force Q=1, RAZ=0 force Q=0, et RAU=1, RAZ=1 est l'état normal (non actif). La condition interdite devient RAU=0 ET RAZ=0.</li>
         </ul>
         <p><em>(Note: La table de vérité de la diapositive originale semble utiliser RAU/RAZ actifs à 1 et un front montant pour l'horloge. Elle omet le cas où l'horloge n'est pas active mais les entrées asynchrones non plus).</em></p>
    </div>

    <!-- Page 164: Asynchronous Inputs Symbol (Active Low) -->
    <div class="slide" id="page164">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Entrées Asynchrones</h2>
        <p>Symbole schématique pour une bascule D avec entrées asynchrones Preset (RAU) et Clear (RAZ) <strong>actives à l'état bas (active-low)</strong>.</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_dff_async_low_symbol.png" alt="Symbole d'une bascule D avec entrées asynchrones actives basses" style="max-width: 250px;">
            <p style="color: #666;">[Placeholder: D-FF Active-Low Async Symbol]</p>
        </div>
        <ul>
            <li>Les <strong>cercles d'inversion</strong> sur les entrées RAU (Preset) et RAZ (Clear) indiquent qu'elles sont actives lorsqu'elles sont à l'état logique 0.</li>
            <li>Fonctionnement :
                <ul>
                    <li>Si RAU=0, RAZ=1 => Q=1 (Preset)</li>
                    <li>Si RAU=1, RAZ=0 => Q=0 (Clear)</li>
                    <li>Si RAU=1, RAZ=1 => Fonctionnement synchrone normal (contrôlé par D et CK)</li>
                    <li>Si RAU=0, RAZ=0 => Etat interdit</li>
                </ul>
            </li>
            <li>C'est la convention la plus fréquente pour les entrées asynchrones dans les circuits intégrés.</li>
        </ul>
    </div>

    <!-- Page 165: What's Next? Registers Introduction -->
    <div class="slide" id="page165">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Et après ?</h2>
        <p>Après avoir vu les éléments de mémorisation de base (bascules), l'étape suivante est de les assembler pour stocker et manipuler des groupes de bits.</p>
        <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
            Les registres
        </div>
    </div>

    <!-- Page 166: Registers Definition -->
    <div class="slide" id="page166">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les registres</h2>
        <p>Un registre est un ensemble de bascules groupées pour stocker un mot binaire (plusieurs bits de données).</p>
        <ul>
             <li><strong>Taille des données :</strong> Une bascule stocke 1 bit. Les registres stockent des mots de \( N \) bits (taille typique : 8, 16, 32, 64 bits...).</li>
             <li>On peut <strong>associer des Bascules</strong> (généralement des D flip-flops synchrones) pour augmenter la taille de stockage. Un registre N bits contient N bascules.</li>
            <li>Ce sont des <strong>éléments importants dans les micro-processeurs</strong> et les systèmes numériques :
                <ul>
                    <li>Stockage temporaire de données, d'instructions, d'adresses.</li>
                    <li>Permettent de <strong>réaliser un pipeline</strong> : un registre est placé entre les étages d'un pipeline pour mémoriser le résultat d'un étage et le fournir comme entrée à l'étage suivant au cycle d'horloge suivant.</li>
                </ul>
            </li>
             <li>Ils <strong>réalisent des barrières de synchronisation :</strong> Les données ne traversent un registre que sur un front d'horloge actif, permettant de synchroniser différentes parties d'un circuit fonctionnant potentiellement à des vitesses différentes ou avec des délais variables.</li>
        </ul>
    </div>

    <!-- Page 167: Shift Register Schematic -->
    <div class="slide" id="page167">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Registre bascules D</h2>
        <p><strong>Registre à Décalage (Shift Register) :</strong></p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_dff_shift_reg_schem.png" alt="Schéma d'un registre à décalage 4 bits avec bascules D" style="max-width: 700px;">
            <p style="color: #666;">[Placeholder for D-FF Shift Register Schematic]</p>
         </div>
        <ul>
            <li>Les bascules D sont connectées en série (Q -> D suivant).</li>
            <li>Toutes les bascules partagent la même horloge (CK).</li>
            <li>Sur chaque front actif de CK, la valeur de chaque bascule est transférée à la suivante.</li>
            <li>Permet de décaler un mot binaire vers la droite (ou vers la gauche selon les connexions) à chaque coup d'horloge.</li>
             <li>Utilisé pour la conversion série/parallèle, parallèle/série, les délais, certains types de compteurs (compteur en anneau).</li>
        </ul>
    </div>

    <!-- Page 168: Parallel Load Register Schematic -->
    <div class="slide" id="page168">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Registre bascules D</h2>
        <p><strong>Registre à chargement parallèle :</strong></p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_dff_parallel_reg_schem.png" alt="Schéma d'un registre à chargement parallèle 4 bits avec bascules D" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for D-FF Parallel Load Register Schematic]</p>
        </div>
         <ul>
            <li>Les bascules D sont indépendantes les unes des autres (pas de connexion Q->D).</li>
            <li>Chaque bascule reçoit une entrée de donnée parallèle distincte (D3, D2, D1, D0).</li>
            <li>Toutes les bascules partagent la même horloge (CK).</li>
            <li>Sur chaque front actif de CK, chaque bascule capture et mémorise la valeur présente sur son entrée D correspondante.</li>
            <li>Permet de charger et de stocker un mot de N bits en une seule fois (en parallèle).</li>
             <li>Les sorties (Q3, Q2, Q1, Q0) rendent disponible le mot mémorisé.</li>
             <li>C'est le type de registre le plus courant pour le stockage de données dans les processeurs.</li>
         </ul>
    </div>

    <!-- Page 169: Register using JK Flip-Flops -->
    <div class="slide" id="page169">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Registre bascules JK</h2>
        <p>Exemple de registre construit avec des bascules JK.</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_jk_register_schem.png" alt="Schéma d'un registre (compteur?) 4 bits avec bascules JK" style="max-width: 700px;">
            <p style="color: #666;">[Placeholder for JK-FF Register Schematic]</p>
         </div>
        <p>Analyse du schéma :</p>
        <ul>
            <li>Quatre bascules JK connectées en cascade.</li>
            <li>Les entrées J et K de chaque bascule sont reliées ensemble et connectées à un niveau logique haut (implicitement '1', ou via une entrée externe non montrée). Cela configure chaque bascule JK en mode "Toggle" (bascule T).</li>
            <li>L'horloge externe (non explicitement nommée, mais entrant sur la première bascule) déclenche la première bascule.</li>
            <li>La sortie \( \bar{Q} \) de chaque bascule est connectée à l'entrée d'horloge (CK) de la bascule suivante.</li>
        </ul>
        <p>Fonctionnement :</p>
        <ul>
            <li>Ce circuit est un <strong>compteur binaire asynchrone (Ripple Counter)</strong>.</li>
             <li>La première bascule (à gauche) bascule à chaque front actif de l'horloge d'entrée (divise la fréquence par 2).</li>
             <li>La deuxième bascule bascule à chaque fois que la sortie \( \bar{Q} \) de la première passe de 1 à 0 (ce qui correspond à un front descendant si \( \bar{Q} \) est utilisée comme horloge, ou un front montant de Q).</li>
             <li>Chaque étage divise la fréquence par 2 par rapport au précédent.</li>
            <li>Les sorties Q des bascules représentent les bits du compte binaire.</li>
            <li>"Asynchrone" car le changement d'état se propage d'un étage à l'autre, les bascules ne changent pas toutes exactement au même moment.</li>
         </ul>
    </div>

    <!-- Page 170: VHDL Generic Register -->
    <div class="slide" id="page170">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Vhdl : registre</h2>
        <p>Code VHDL pour un registre N bits générique à chargement parallèle, utilisant des bascules D implicites (créées par le style de codage synchrone).</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all; -- Non requis pour ce code

-- Entité pour un registre générique N bits
entity regNgeneric is -- Nom modifié pour refléter la généricité
    generic (
        N : natural := 8 -- Paramètre générique pour la taille (défaut=8 bits)
    );
    port (
        d   : in  std_logic_vector(N-1 downto 0); -- Entrée parallèle N bits
        clk : in  std_logic;                     -- Horloge
        q   : out std_logic_vector(N-1 downto 0)  -- Sortie parallèle N bits
    );
end entity regNgeneric;

-- Architecture comportementale synchrone
architecture comport of regNgeneric is
begin
    -- Process sensible à l'horloge
    stockage : process(clk) is -- La sensibilité à 'd' est incorrecte pour un registre synchrone standard
    -- Uniquement sensible à clk (et reset asynchrone si présent)
    -- stockage : process(clk) is -- Correction: sensibilité uniquement à clk
    begin
        -- Détection du front montant de l'horloge
        if rising_edge(clk) then -- Utilise la fonction standard
        -- if (clk = '1' and clk'event) then -- Alternative
            -- Sur front montant, la sortie q prend la valeur de l'entrée d
            q <= d;
        end if;
        -- Quand pas de front montant, q conserve sa valeur (mémorisation)
    end process stockage;
end architecture comport;
        </code></pre>
        <ul>
            <li><strong>`generic (N : natural := 8)` :</strong> Définit un paramètre `N` (la taille du registre) qui peut être spécifié lors de l'instanciation du composant. La valeur par défaut est 8.</li>
            <li><strong>`std_logic_vector(N-1 downto 0)` :</strong> Utilise le paramètre générique `N` pour définir la taille des ports de données `d` et `q`.</li>
            <li><strong>`process(clk)` :</strong> Le processus est déclenché uniquement par les changements sur `clk`. Mettre `d` dans la liste de sensibilité est généralement une erreur pour un registre synchrone simple car cela pourrait entraîner des exécutions inutiles ou une sémantique de latch non désirée dans certains simulateurs/synthétiseurs.</li>
            <li><strong>`if rising_edge(clk) then q <= d; end if;` :</strong> C'est le modèle standard pour décrire un registre synchrone simple sensible au front montant. Le signal `q` ne sera mis à jour qu'au moment du front montant de `clk`, prenant la valeur de `d` à cet instant.</li>
        </ul>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 171: Monostables Title -->
    <div class="slide" id="page171">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les monostables</h2>
        <p>Les circuits monostables sont une classe de circuits séquentiels qui possèdent un seul état stable.</p>
        <p>Ils sont souvent utilisés pour générer des impulsions de durée calibrée ou pour des fonctions de temporisation.</p>
    </div>

    <!-- Page 172: Simple Monostable Definition -->
    <div class="slide" id="page172">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Monostable simple</h2>
        <ul>
            <li>C'est un circuit ne possédant qu'<strong>un seul état stable</strong>.</li>
            <li>Typiquement, cet état stable est Q=0, \( \bar{Q} \)=1.</li>
            <li>Lorsqu'il est déclenché par une impulsion d'entrée (trigger), le circuit passe dans un <strong>état quasi stable</strong> (par exemple Q=1, \( \bar{Q} \)=0).</li>
            <li>Cet état quasi stable est <strong>momentané</strong>. Le circuit y reste pendant une durée déterminée, puis retourne spontanément à son état stable initial.</li>
            <li>La <strong>durée</strong> de l'état quasi stable est généralement fixée par un <strong>circuit RC</strong> externe (une résistance et un condensateur).</li>
        </ul>
        <p>Table d'états simplifiée :</p>
         <table border="1">
             <thead>
                 <tr><th>Q</th><th>\( \bar{Q} \)</th><th style="border-left: 2px solid black;">Etat</th></tr>
             </thead>
            <tbody>
                <tr><td>0</td><td>1</td><td style="border-left: 2px solid black;">Stable</td></tr>
                <tr><td>1</td><td>0</td><td style="border-left: 2px solid black;">Quasi Stable (temporaire)</td></tr>
            </tbody>
         </table>
        <p>Le monostable génère une impulsion de sortie de durée fixe \( \tau \) lorsqu'il est déclenché.</p>
    </div>

    <!-- Page 173: Simple Monostable Symbol -->
    <div class="slide" id="page173">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Monostable simple</h2>
        <p>Symbole schématique d'un circuit monostable (souvent intégré, comme le NE555 configuré en monostable, ou des circuits dédiés comme le 74LS121/123).</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_monostable_symbol.png" alt="Symbole d'un circuit monostable avec composants RC externes" style="max-width: 350px;">
             <p style="color: #666;">[Placeholder for Monostable Symbol with RC]</p>
        </div>
        <ul>
            <li>T : Entrée de déclenchement (Trigger).</li>
            <li>Q, \( \bar{Q} \) : Sorties.</li>
            <li>R, C : Composants externes (Résistance, Condensateur) qui déterminent la durée de l'impulsion.</li>
            <li>La durée \( \tau \) est une fonction de R et C (souvent proportionnelle au produit \( R \times C \)).</li>
        </ul>
    </div>

    <!-- Page 174: Simple Monostable Timing Diagram -->
    <div class="slide" id="page174">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Monostable simple</h2>
        <p>Chronogramme illustrant le fonctionnement d'un monostable (non-redéclenchable) :</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_monostable_timing.png" alt="Chronogramme d'un monostable simple non-redéclenchable" style="max-width: 600px;">
            <p style="color: #666;">[Placeholder for Simple Monostable Timing Diagram]</p>
         </div>
        <ul>
            <li>T : Signal de déclenchement (trigger). Le monostable réagit typiquement à un front spécifique (ici, front descendant marqué par la flèche et les lignes rouges initiales).</li>
            <li>Q : Sortie du monostable.</li>
            <li>Lorsque T présente un front actif, la sortie Q passe dans son état quasi stable (ici, niveau haut '1') pour une durée fixe \( \tau \), déterminée par RC.</li>
            <li>Après la durée \( \tau \), Q retourne automatiquement à son état stable (ici, niveau bas '0'), même si T est toujours actif ou présente d'autres fronts pendant la temporisation.</li>
            <li>Les impulsions de trigger survenant pendant que Q est déjà dans l'état quasi stable sont ignorées (comportement non-redéclenchable).</li>
        </ul>
    </div>

    <!-- Page 175: Retriggerable Monostable -->
    <div class="slide" id="page175">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Monostable redéclenchable</h2>
        <ul>
            <li><strong>Monostable Simple (Non-Redéclenchable) :</strong> La durée de l'état quasi stable est fixe (\( \tau = f(RC) \)) et n'est pas affectée par les triggers arrivant pendant cette durée.
                 <div style="text-align: center; margin: 10px 0;">
                    <img src="placeholder_monostable_timing_simple.png" alt="Chronogramme monostable simple" style="max-width: 500px;"><br>
                    <span style="color: #666;">[Placeholder: Simple Monostable Timing]</span>
                 </div>
             </li>
            <li><strong>Monostable Redéclenchable :</strong>
                <ul>
                    <li>Nécessité parfois de pouvoir <strong>prolonger l'état quasi stable</strong> si un nouveau trigger arrive avant la fin de la temporisation initiale.</li>
                    <li>Dans un monostable redéclenchable, chaque trigger actif (même s'il arrive pendant l'état quasi stable) <strong>redémarre</strong> la temporisation \( \tau \).</li>
                    <li>La sortie Q ne retournera à l'état stable que \( \tau \) secondes après le <strong>dernier</strong> trigger actif reçu.</li>
                </ul>
                 <div style="text-align: center; margin: 10px 0;">
                    <img src="placeholder_monostable_timing_retrigger.png" alt="Chronogramme monostable redéclenchable" style="max-width: 500px;"><br>
                     <span style="color: #666;">[Placeholder: Retriggerable Monostable Timing]</span>
                 </div>
                 (Le chronogramme du bas illustre que si un trigger arrive pendant la première temporisation \( \tau \), la durée totale de l'état haut est prolongée.)
             </li>
        </ul>
    </div>

    <!-- Page 176: Tri-state Logic Introduction -->
    <div class="slide" id="page176">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les portes 3 états (Tri-state Logic)</h2>
        <p>Problème fondamental en conception numérique :</p>
        <ul>
            <li>L'algèbre de Boole et la logique standard ont <strong>2 états : 0 et 1</strong> (représentés par des niveaux de tension BAS et HAUT).</li>
             <li>Que se passe-t-il si l'on essaie de <strong>connecter les sorties de 2 (ou plus) composants</strong> logiques standard <strong>sur le même fil</strong> (bus) ?
                <ul>
                    <li>Si une sortie essaie de forcer le fil à '1' (tension HAUTE) et une autre essaie de forcer le même fil à '0' (tension BASSE) en même temps...</li>
                    <li><strong>Première Solution (Réalité) : Court-Circuit !</strong> Un courant élevé circule entre les sorties, pouvant endommager les composants et produisant un niveau de tension indéterminé. -> <strong style="color: red;">PERDU</strong> (Solution inacceptable).</li>
                     <li><strong>Seconde Solution : Multiplexeur.</strong> Utiliser un multiplexeur pour sélectionner laquelle des sorties est connectée au fil commun à un instant donné. -> Fonctionne, mais peut être <strong>encombrant</strong> et ajouter des délais si beaucoup de sources doivent partager le bus.</li>
                    <li><strong>Troisième Solution : Composant d'interface spécial - La porte 3 états.</strong> Introduire un troisième état logique qui permet de déconnecter électriquement une sortie du fil. -> <strong style="color: green;">GAGNE</strong> (Solution efficace pour les bus partagés).</li>
                 </ul>
            </li>
         </ul>
    </div>

    <!-- Page 177: Tri-state Logic - Z State -->
    <div class="slide" id="page177">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les portes 3 états</h2>
        <ul>
            <li><strong>Introduction d'un Etat Z :</strong> En plus des états logiques '0' et '1', les composants "tri-state" possèdent un troisième état de sortie possible, appelé état Z.</li>
            <li><strong>Etat Haute Impédance (High-Impedance) :</strong> L'état Z correspond à une déconnexion électrique effective de la sortie du composant par rapport au fil auquel elle est connectée. La sortie présente une impédance très élevée.</li>
             <li><strong>Tout ce passe comme si le fil n'était pas connecté</strong> à cette sortie spécifique. La sortie en état Z n'influence pas (ne force pas) le niveau logique du fil.</li>
         </ul>
         <p>Symbole d'un buffer tri-state :</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_tristate_buffer_symbol.png" alt="Symbole d'un buffer tri-state" style="max-width: 250px;">
            <p style="color: #666;">[Placeholder for Tri-state Buffer Symbol]</p>
         </div>
        <ul>
            <li>Il possède une entrée de donnée (gauche) et une sortie (droite), comme un buffer normal.</li>
            <li>Il a une entrée de commande supplémentaire, souvent appelée <strong>Enable (EN)</strong> ou Output Enable (OE).</li>
            <li>Fonctionnement :
                <ul>
                     <li>Si EN est actif (par exemple EN=1) : Le buffer fonctionne normalement, la sortie recopie l'entrée (état '0' ou '1').</li>
                    <li>Si EN est inactif (par exemple EN=0) : La sortie passe en état de <strong>haute impédance (Z)</strong>, se déconnectant électriquement du fil.</li>
                 </ul>
             </li>
             <li>Des portes logiques (AND, OR, etc.) tri-state existent aussi.</li>
         </ul>
         <p>Cela permet à plusieurs sorties tri-state de partager le même fil (bus), à condition qu'une seule sortie soit activée (EN=1) à un instant donné, toutes les autres étant en état Z.</p>
    </div>

    <!-- Page 178: VHDL Register with Tri-state Output -->
    <div class="slide" id="page178">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Vhdl : registre (avec sortie tri-state)</h2>
        <p>Code VHDL pour un registre N bits générique avec une sortie tri-state contrôlée par une entrée `en` (Enable).</p>
        <pre><code class="language-vhdl">
library ieee;
use ieee.std_logic_1164.all;
-- use ieee.numeric_std.all; -- Non requis

entity regNgeneric_tristate is -- Nom modifié
    generic (
        N : natural := 8
    );
    port (
        d   : in  std_logic_vector(N-1 downto 0); -- Donnée d'entrée
        en  : in  std_logic;                     -- Enable (contrôle sortie tri-state)
        clk : in  std_logic;                     -- Horloge
        q   : out std_logic_vector(N-1 downto 0)  -- Sortie (peut être Z)
    );
end entity regNgeneric_tristate;

architecture comport of regNgeneric_tristate is
    -- Signal interne pour stocker la valeur du registre
    signal q_internal : std_logic_vector(N-1 downto 0);
begin
    -- Process pour la mémorisation synchrone (comme avant)
    stockage : process(clk) is -- Sensibilité à clk uniquement
    begin
        if rising_edge(clk) then
            -- Mémorise d dans le registre interne q_internal
            -- (On suppose ici que le chargement se fait toujours,
            -- une version plus complète pourrait avoir un enable de chargement)
            q_internal <= d;
        end if;
    end process stockage;

    -- Affectation concurrente pour contrôler la sortie tri-state
    -- Si en='1', la sortie q prend la valeur mémorisée q_internal
    -- Si en='0', la sortie q est mise en haute impédance (Z)
    q <= q_internal when en = '1' else (others => 'Z');

    -- Note: Le process dans la diapo originale était différent et
    -- combinait stockage et contrôle tri-state, ce qui est moins
    -- clair et potentiellement problématique (sensibilité à d, en).
    -- La version ci-dessus sépare la mémorisation (synchrone)
    -- du contrôle de la sortie (combinatoire/tri-state).

end architecture comport;
        </code></pre>
        <ul>
            <li>Une entrée `en` est ajoutée pour contrôler l'activation de la sortie.</li>
            <li>Un signal interne `q_internal` est utilisé pour mémoriser la valeur du registre de manière synchrone.</li>
            <li>Une affectation concurrente (`<= ... when ... else ...`) contrôle le port de sortie `q`.</li>
            <li>Si `en = '1'`, `q` est connecté à la valeur interne `q_internal`.</li>
            <li>Si `en = '0'`, `q` est mis en haute impédance. L'expression `(others => 'Z')` est une notation VHDL pour affecter 'Z' à tous les bits du vecteur `q`.</li>
        </ul>
    </div>

    <!-- Page 179: Complex Sequential Systems Title -->
    <div class="slide" id="page179">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Systèmes Séquentiels Complexes</h2>
         <div style="text-align: center; font-size: 1.5em; margin-top: 50px;">
             Systèmes Séquentiels
        </div>
        <p style="text-align: center; margin-top: 20px;">Cette section aborde la conception et l'analyse de systèmes numériques plus larges qui combinent logique combinatoire et éléments séquentiels (mémoire).</p>
    </div>

    <!-- Page 180: Complex Sequential Systems Overview -->
    <div class="slide" id="page180">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Systèmes Séquentiels</h2>
        <p>Composants et concepts clés des systèmes séquentiels complexes :</p>
        <ul>
            <li><strong>Les registres</strong> (Déjà vus) : Stockage de mots binaires.</li>
            <li><strong>Les mémoires</strong> : Stockage de grandes quantités de données (RAM, ROM), organisées par adresses.</li>
            <li><strong>Les compteurs</strong> : Circuits séquentiels qui suivent une séquence prédéfinie d'états (généralement pour compter des événements ou générer des séquences temporelles).</li>
             <li><strong>Le contrôle (les pipelines)</strong> : Organisation du traitement des données en étapes successives (pipeline) pour augmenter le débit, nécessitant des registres pour séparer les étages et une logique de contrôle pour gérer le flux.</li>
            <li><strong>Les Machines à Etats Finis (FSM - Finite State Machines)</strong> : Modèle mathématique et structure de conception pour les circuits dont le comportement dépend de l'état actuel et des entrées, et qui transitent entre un nombre fini d'états (très utilisées pour le contrôle). <em>(Sujet abordé dans le "Cours Synthèse des Systèmes Numériques" ou un cours similaire).</em></li>
             <li><strong>What Else ?</strong> (Quoi d'autre ?) : Bus de communication, interfaces, unités arithmétiques plus complexes, etc.</li>
        </ul>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 181: Memories Introduction -->
    <div class="slide" id="page181">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les mémoires</h2>
        <p>Les mémoires sont des circuits séquentiels conçus pour stocker de grandes quantités d'informations (données ou instructions).</p>
        <ul>
            <li>Elles peuvent être vues comme une <strong>association de plusieurs Registres</strong>, organisés de manière structurée.</li>
            <li><strong>Utilisation de Bascules D souvent :</strong> Les cellules de mémoire individuelles (stockant 1 bit) sont souvent basées sur des variations de bascules D (ou des structures SRAM/DRAM plus spécifiques).</li>
             <li><strong>Mémoires Asynchrones ⇒ Bascules Asynchrones :</strong> Les mémoires dont la lecture ou l'écriture ne dépend pas d'une horloge (plus rares pour les mémoires principales) seraient basées sur des concepts de bascules asynchrones.</li>
             <li><strong>Mémoires Synchrones ⇒ Bascules Synchrones :</strong> La grande majorité des mémoires (RAM, registres de processeur) sont synchrones, utilisant des bascules ou cellules synchronisées par une horloge pour l'écriture et parfois la lecture.</li>
             <li><strong>Ajout d'une entrée de sélection (Adresse) :</strong> Pour accéder à un mot spécifique parmi les nombreux mots stockés, les mémoires nécessitent une entrée d'adresse qui sélectionne l'emplacement (le registre) à lire ou à écrire. Un décodeur est typiquement utilisé en interne pour activer l'emplacement choisi par l'adresse.</li>
        </ul>
    </div>

    <!-- Page 182: Memory Cell with Tri-state Output -->
    <div class="slide" id="page182">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les mémoires</h2>
        <p>Pour lire la donnée stockée dans une cellule mémoire spécifique (une bascule) et la placer sur un bus de données partagé par de nombreuses autres cellules, on utilise des sorties 3 états :</p>
        <ul>
            <li><strong>Sélection ⇒ sortie 3 états :</strong> La lecture d'une cellule mémoire implique d'activer sa sortie pour qu'elle pilote le bus de données. Les sorties des cellules non sélectionnées doivent être en haute impédance (Z) pour ne pas interférer.</li>
        </ul>
        <p>Schéma conceptuel d'une cellule mémoire (1 bit) avec sortie tri-state :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_memory_cell_tristate.png" alt="Cellule mémoire (bascule D) avec sortie tri-state contrôlée par Enable" style="max-width: 450px;">
             <p style="color: #666;">[Placeholder for Memory Cell with Tri-state Output]</p>
        </div>
        <ul>
             <li>Une bascule D (ou un autre type de cellule mémoire) stocke le bit.</li>
             <li>La sortie Q est connectée à un buffer tri-state (et \( \bar{Q} \) à un autre si nécessaire).</li>
             <li>Une ligne de sélection (<strong>Enable</strong>, souvent issue du décodeur d'adresse et combinée avec un signal de lecture) contrôle les buffers tri-state.</li>
             <li>Si Enable est actif, la valeur stockée (Q ou \( \bar{Q} \)) est placée sur le bus de sortie.</li>
             <li>Si Enable est inactif, la sortie est en haute impédance (Z).</li>
         </ul>
    </div>

    <!-- Page 183: 2-word x 2-bit Memory Schematic -->
    <div class="slide" id="page183">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les mémoires</h2>
        <p>Exemple : Schéma simplifié d'une <strong>Mémoire 2 mots de 2 bits</strong>.</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_memory_2x2.png" alt="Schéma d'une mémoire 2 mots de 2 bits" style="max-width: 600px;">
             <p style="color: #666;">[Placeholder for 2-word x 2-bit Memory Schematic]</p>
         </div>
         <p>Composants et signaux :</p>
         <ul>
             <li>4 bascules D (avec entrée Enable 'E'), organisées en 2 mots de 2 bits.</li>
             <li><strong>Adresse :</strong> 1 bit d'adresse (car 2 mots, \( 2^1 = 2 \)). Sélectionne le mot 0 (haut) ou le mot 1 (bas). L'adresse et son inverse (générée par l'inverseur) contrôlent les entrées E des bascules.</li>
             <li><strong>Donnée Entrante (Data In) :</strong> Bus de 2 bits pour écrire dans la mémoire.</li>
             <li><strong>Horloge :</strong> Signal d'horloge commun à toutes les bascules (pour l'écriture synchrone).</li>
             <li><strong>Donnée Sortante (Data Out) :</strong> Bus de 2 bits pour lire la mémoire (nécessiterait des buffers tri-state non montrés ici, contrôlés par l'adresse et un signal de lecture).</li>
             <li><strong>Fonctionnement (écriture) :</strong> Lorsque l'horloge est active, si l'adresse sélectionne le mot 0, les bascules du haut (E=1) capturent la Donnée Entrante. Si l'adresse sélectionne le mot 1, ce sont les bascules du bas (E=1) qui capturent la donnée. Les bascules non sélectionnées (E=0) conservent leur état.</li>
             <li><strong>Fonctionnement (lecture) :</strong> L'adresse sélectionnerait les buffers tri-state appropriés pour connecter les sorties Q du mot choisi au bus de Donnée Sortante.</li>
         </ul>
         <p>(Le schéma est simplifié, il manque la gestion de la lecture et le contrôle écriture/lecture).</p>
    </div>

    <!-- Page 184: Counters Introduction -->
    <div class="slide" id="page184">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les Compteurs</h2>
        <p>Un compteur est un <strong>système séquentiel dont les sorties</strong> (représentant l'état du compteur) suivent une <strong>suite pré-déterminée d'états</strong> à chaque coup d'horloge (ou événement à compter).</p>
        <ul>
            <li>Généralement construits à partir de <strong>Bascules D ou JK</strong> (ou T).</li>
            <li>Peuvent être <strong>Plus ou Moins Complexes</strong> :
                 <ul>
                     <li><strong>Simple ("Bête") :</strong> Compte de 0 à \( N-1 \) en boucle (compteur binaire naturel). Nécessite \( \lceil \log_2(N) \rceil \) bascules. Par exemple, un compteur modulo 16 (0 à 15) nécessite 4 bascules.</li>
                     <li><strong>Complexes :</strong> Possèdent des fonctionnalités supplémentaires :
                         <ul>
                             <li><strong>Initialisation :</strong> Possibilité de charger une valeur initiale (Preset/Load).</li>
                             <li><strong>Arrêt - Reprise :</strong> Entrée pour activer/désactiver le comptage (Enable/Count).</li>
                            <li><strong>Compteur - Décompteur :</strong> Peut compter dans les deux sens (Up/Down).</li>
                             <li><strong>Fonctions nécessaires à l'application :</strong> Comptage par pas différent de 1, détection de valeurs spécifiques, etc.</li>
                         </ul>
                     </li>
                 </ul>
             </li>
             <li>Les compteurs sont des blocs fondamentaux dans les systèmes numériques pour le séquencement, la division de fréquence, la mesure du temps, etc.</li>
         </ul>
    </div>

    <!-- Page 185: Control and Pipelining -->
    <div class="slide" id="page185">
         <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Le contrôle</h2>
        <p>Les éléments séquentiels (registres) sont essentiels pour le <strong>contrôle du flux des données</strong> dans les systèmes complexes.</p>
        <ul>
            <li><strong>Un registre entre 2 opérateurs :</strong> Placer un registre entre deux blocs de logique combinatoire (opérateurs) permet de synchroniser le transfert de données. Le résultat du premier opérateur est mémorisé dans le registre sur un coup d'horloge, et est présenté comme entrée stable au second opérateur au cycle suivant.</li>
            <li><strong>Réalisation d'un pipeline :</strong> C'est la base du pipelining. En découpant une opération complexe en plusieurs étapes (étages) séparées par des registres, on peut traiter plusieurs données simultanément, une à chaque étage.</li>
         </ul>
         <p>Exemple :</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_pipeline_example.png" alt="Exemple de pipeline simple avec additionneur, registre, multiplieur" style="max-width: 700px;">
            <p style="color: #666;">[Placeholder for Simple Pipeline Example]</p>
         </div>
        <ul>
            <li>Un additionneur calcule \(A+B\).</li>
            <li>Un registre mémorise le résultat de l'addition et l'entrée B originale.</li>
             <li>Un multiplieur utilise les valeurs mémorisées pour calculer \( (A_{n-1} + B_{n-1}) \times B_n \). (L'indice 'n' réfère probablement au cycle d'horloge).</li>
            <li>La formule \( S_n = (A_{n-1} + B_{n-1}) \times B_n \) décrit le calcul effectué, montrant la dépendance temporelle introduite par le registre. Le résultat S au cycle n dépend des valeurs de A et B du cycle n-1 (pour la somme) et de B au cycle n (pour la multiplication ? - la formule semble un peu étrange, B devrait peut-être aussi venir du registre).</li>
            <li>Un second registre capture la sortie S du multiplieur.</li>
         </ul>
         <p>Le pipeline permet à l'additionneur de commencer un nouveau calcul (pour \( A_n, B_n \)) pendant que le multiplieur travaille sur le résultat précédent (\( A_{n-1}, B_{n-1} \)).</p>
    </div>

    <!-- Page 186: Hazards (Sequential) -->
    <div class="slide" id="page186">
        <div class="header-small">Cours d'électronique numérique - Logique Séquentielle</div>
        <h2 class="slide-title">Les Aléas</h2>
        <p>Les aléas temporels peuvent également se manifester dans les circuits séquentiels ou à l'interface entre logique combinatoire et séquentielle.</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_seq_hazard_example.png" alt="Exemple de circuit sujet aux aléas séquentiels" style="max-width: 400px;">
             <p style="color: #666;">[Placeholder for Sequential Hazard Example]</p>
        </div>
        <p>Analyse du circuit :</p>
        <ul>
            <li>Une bascule D reçoit une entrée D et une horloge CK.</li>
            <li>Les sorties Q et \( \bar{Q} \) de la bascule sont connectées aux entrées d'une porte ET (AND).</li>
            <li>La sortie S de la porte ET est donc \( S = Q \cdot \bar{Q} \).</li>
        </ul>
        <p>Problème potentiel :</p>
        <ul>
            <li>Théoriquement, \( Q \cdot \bar{Q} \) devrait toujours être 0.</li>
            <li>Cependant, après un front d'horloge qui fait basculer la sortie Q (par exemple de 0 à 1), la sortie \( \bar{Q} \) passera de 1 à 0.</li>
             <li>En raison des délais de propagation différents à l'intérieur de la bascule pour générer Q et \( \bar{Q} \), il peut y avoir un court instant où Q est déjà passée à 1 mais \( \bar{Q} \) n'est pas encore passée à 0 (elle est encore à 1).</li>
             <li>Pendant ce très court instant, les deux entrées de la porte ET sont à 1, provoquant une <strong>impulsion parasite (glitch)</strong> à 1 sur la sortie S, alors qu'elle devrait rester à 0.</li>
             <li>C'est un exemple d'aléa fonctionnel (dû à la logique \( Q \cdot \bar{Q} \)) exacerbé par les délais réels.</li>
         </ul>
         <p>Ces glitches peuvent causer des erreurs s'ils sont interprétés comme des signaux valides par d'autres parties du circuit.</p>
    </div>

    <!-- Page 187: Pipeline Diagram -->
    <div class="slide" id="page187">
        <div class="header-small">Cours d'électronique numérique - Le pipeline</div>
        <h2 class="slide-title">Pipeline</h2>
        <p>Diagramme illustrant une structure pipeline plus détaillée, par exemple un additionneur pipeliné sur 4 étages.</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_pipeline_detailed.png" alt="Diagramme détaillé d'une structure pipeline (ex: additionneur 4 étages)" style="max-width: 800px;">
            <p style="color: #666;">[Placeholder for Detailed Pipeline Diagram]</p>
         </div>
        <p>Structure :</p>
        <ul>
            <li>Le calcul complet (ici, une addition, symbolisée par '+') est découpé en <strong>4 étages (ETAGE 1 à ETAGE 4)</strong>. Chaque étage réalise une partie du calcul (par exemple, l'addition de quelques bits).</li>
            <li>Des <strong>registres pipeline</strong> (constitués de bascules, en bleu/vert dans le schéma) sont insérés entre chaque étage.</li>
            <li>Ces registres mémorisent les résultats intermédiaires de chaque étage et les transmettent à l'étage suivant au prochain coup d'horloge (signal d'horloge non montré mais implicite pour les registres).</li>
            <li>Les entrées (X0, Y0, C0) entrent dans l'étage 1. Le résultat de l'étage 1 est mémorisé. Au cycle suivant, l'étage 2 traite ce résultat pendant que l'étage 1 traite de nouvelles entrées (X1, Y1, C1), et ainsi de suite.</li>
            <li>Le résultat final (S3, C4) sort après 4 cycles d'horloge (latence), mais un nouveau résultat peut être produit à chaque cycle d'horloge (débit = 1 résultat/cycle) une fois le pipeline rempli.</li>
        </ul>
    </div>

    <!-- Page 188: Pipeline Principle and Latency -->
    <div class="slide" id="page188">
        <div class="header-small">Cours d'électronique numérique - Le pipeline</div>
        <h2 class="slide-title">Pipeline</h2>

        <div style="background-color: #e9ecef; padding: 15px; margin-bottom: 20px; border-radius: 5px;">
            <h3>Principe :</h3>
            <p>Découper l'opérateur (circuit combinatoire réalisant une fonction complexe) en plusieurs <strong>étages</strong> isolés les uns des autres par des registres.</p>
            <p>C'est le <strong>signal d'horloge</strong> qui autorise le transfert des données d'un étage à l'autre via les registres.</p>
            <p>Cette technique permet d'<strong>accélérer la cadence</strong> (le débit, throughput) de production des résultats : au lieu d'attendre que la donnée traverse tout l'opérateur (long délai), on peut faire entrer une nouvelle donnée dans le premier étage à chaque cycle d'horloge (cycle plus court).</p>
        </div>

        <div style="background-color: #ffdddd; padding: 15px; border-radius: 5px;">
            <h3>Latence</h3>
            <p>La <strong>latence</strong> (durée d'exécution totale pour une donnée) de l'opérateur pipeliné est <strong>supérieure</strong> (d'au moins un petit temps \( \epsilon \) dû aux registres) à celle d'un opérateur non pipeliné équivalent.</p>
            <p>Si :</p>
             <ul>
                <li>La durée maximale (délai critique) d'un étage de l'opérateur pipeliné est de \( t_{max} \).</li>
                <li>Il y a \( n \) étages.</li>
                <li>La période d'horloge \( t_{clk} \) doit être suffisamment longue pour permettre le calcul dans un étage ET la traversée du registre (setup + hold + délai interne du registre). <br> Condition : \( t_{clk} > t_{max} + t_{reg} \), où \( t_{reg} \) inclut le délai de la bascule et les temps de setup/hold. La diapositive simplifie en \( t_{clk} > t_{max} + t_h + t_s \).</li>
            </ul>
            <p>Alors la <strong>latence</strong> totale de l'opérateur pipeliné (temps entre l'entrée de la donnée et la sortie du résultat correspondant) est :</p>
            <div class="formula">
                 \( T = n \times t_{clk} \)
            </div>
            <p>Le gain du pipeline n'est pas sur la latence d'une opération unique, mais sur le <strong>débit</strong> : une fois le pipeline rempli, un résultat sort à chaque cycle d'horloge \( t_{clk} \), alors que l'opérateur non pipeliné aurait un débit lié à son délai total (beaucoup plus long que \( t_{clk} \)).</p>
        </div>
    </div>

    <!-- Page 189: References (Technology) -->
    <div class="slide" id="page189">
         <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Références</h2>
        <p>Quelques références pour la partie technologie des circuits numériques :</p>
        <ul>
            <li><strong>Conception des ASICS</strong> - P. Naish et P. Bishop - Masson.
                 <br><em>(Ouvrage sur la conception de circuits intégrés spécifiques).</em>
             </li>
             <li><strong>Logic Reference Guide 4Q2001</strong> - Texas Instrument (TI).
                <br><a href="http://www.ti.com" target="_blank">http://www.ti.com</a>
                <br><em>(Guide de référence sur les familles logiques de TI, probablement daté mais illustre les concepts).</em>
            </li>
             <li><strong>Des Liens Utiles pour tous les Electroniciens</strong> - Site personnel de X. Cotton.
                 <br><a href="http://perso.wanadoo.fr/xcotton/electron/index.htm" target="_blank">http://perso.wanadoo.fr/xcotton/electron/index.htm</a>
                 <br><em>(Lien potentiellement obsolète car Wanadoo n'existe plus sous ce nom, mais le contenu a pu être migré).</em>
            </li>
        </ul>
    </div>

    <!-- Page 190: Vocabulary (Technology) -->
    <div class="slide" id="page190">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Vocabulaire</h2>
        <p>Quelques grandeurs caractéristiques importantes en technologie des circuits numériques :</p>
        <ul>
            <li><strong>F - Fréquence de Fonctionnement :</strong> La fréquence maximale (souvent liée à la fréquence d'horloge) à laquelle un circuit peut opérer correctement. Exprimée en Hertz (Hz), Mégahertz (MHz), Gigahertz (GHz).</li>
            <li><strong>P - Puissance Dissipée :</strong> L'énergie consommée par le circuit par unité de temps, transformée en chaleur. Un facteur critique pour l'autonomie (batteries) et le refroidissement. Exprimée en Watts (W), milliwatts (mW), microwatts (µW).</li>
            <li><strong>\( T_p \) - Temps de Propagation (Propagation Delay) :</strong> Le temps nécessaire à un changement sur l'entrée d'une porte ou d'un circuit pour se propager et provoquer un changement sur sa sortie. Exprimé en nanosecondes (ns), picosecondes (ps).</li>
            <li><strong>Sortance (Fan-out) :</strong> Le <strong>nombre maximal d'entrées</strong> de portes logiques (de la même famille technologique) qui peuvent être <strong>pilotées par une unique sortie</strong> de porte logique, tout en garantissant des niveaux logiques corrects et des performances temporelles adéquates. Lié à la capacité de la sortie à fournir ou absorber du courant.</li>
        </ul>
    </div>
    <!-- Continuing the document... -->

    <!-- Section Transition: Digital Circuit Technology -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Technologie de circuits numériques</h2>

    <!-- Page 191: Integration Levels -->
    <div class="slide" id="page191">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Intégration ?</h2>
        <p>La complexité des circuits intégrés (CI, ou "puces") est souvent caractérisée par leur niveau d'intégration, historiquement défini par le nombre approximatif de portes logiques équivalentes qu'ils contiennent :</p>
        <ul>
            <li><strong>SSI : Small Scale Integration</strong> (Petite échelle d'intégration)
                <ul><li>Moins de 12 portes logiques.</li><li>Exemples : Circuits contenant quelques portes logiques simples (ET, OU, NON), bascules.</li></ul>
            </li>
            <li><strong>MSI : Medium Scale Integration</strong> (Moyenne échelle d'intégration)
                 <ul><li>De 12 à 99 portes logiques.</li><li>Exemples : Compteurs, registres, multiplexeurs, décodeurs simples.</li></ul>
            </li>
            <li><strong>LSI : Large Scale Integration</strong> (Grande échelle d'intégration)
                 <ul><li>De 100 à 9999 portes logiques.</li><li>Exemples : Premiers microprocesseurs (4 bits, 8 bits), petites mémoires, contrôleurs périphériques.</li></ul>
            </li>
            <li><strong>VLSI : Very Large Scale Integration</strong> (Très grande échelle d'intégration)
                 <ul><li>De 10 000 à 99 999 portes logiques (les définitions évoluent, souvent on parle de 100 000 et plus maintenant).</li><li>Exemples : Microprocesseurs 16/32 bits, processeurs de signal numérique (DSP), grands FPGA.</li></ul>
            </li>
            <li><strong>ULSI : Ultra Large Scale Integration</strong> (Ultra grande échelle d'intégration)
                 <ul><li>100 000 portes logiques et plus (souvent des millions voire des milliards aujourd'hui).</li><li>Exemples : Microprocesseurs modernes, System-on-Chip (SoC), grands FPGA, mémoires de grande capacité.</li></ul>
            </li>
        </ul>
        <p>Ces termes sont moins strictement utilisés aujourd'hui, où l'on parle plus souvent directement du nombre de transistors ou de caractéristiques fonctionnelles, mais ils donnent une idée de l'évolution historique.</p>
    </div>

    <!-- Page 192: Technology Basics (Diodes, Transistors) -->
    <div class="slide" id="page192">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Technologie - 1</h2>
        <ul>
            <li><strong>Comment réaliser des fonctions logiques ?</strong> Il faut des composants électroniques qui peuvent agir comme des interrupteurs commandés.</li>
            <li><strong>Nécessité de composants commandés électriquement :</strong> Contrairement aux interrupteurs mécaniques, ces composants doivent pouvoir changer d'état (conducteur/bloqué) en réponse à un signal électrique (tension ou courant).</li>
            <li>Premières approches :
                 <ul>
                    <li><strong>Les Diodes (Famille DTL - Diode-Transistor Logic) :</strong> Les diodes peuvent être utilisées pour réaliser des fonctions logiques simples (comme ET ou OU), souvent en combinaison avec des résistances et un transistor pour l'amplification et l'inversion.</li>
                    <div style="text-align: center; margin: 20px;">
                        <img src="placeholder_dtl_gate.png" alt="Schéma simple d'une porte logique utilisant des diodes (DTL)" style="max-width: 250px;">
                         <p style="color: #666;">[Placeholder for Diode Logic Gate (DTL concept)]</p>
                         <p style="font-size: 0.9em;">(Le schéma montre une porte DTL NAND simplifiée : si A=0 OU B=0, la diode correspondante conduit, tirant S vers Vss. Si A=1 ET B=1, les diodes sont bloquées, S est tiré vers Vdd via la résistance).</p>
                    </div>
                     <li>La logique à diodes seule manque d'amplification et de capacité à reconstituer les niveaux logiques, d'où l'ajout de transistors (DTL).</li>
                 </ul>
            </li>
            <li>La solution dominante : <strong>Les Transistors</strong>. Ils agissent comme des interrupteurs commandés efficaces, avec amplification, et sont la base de toutes les familles logiques modernes.</li>
         </ul>
    </div>

    <!-- Page 193: Bipolar Logic Introduction -->
    <div class="slide" id="page193">
         <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Technologie - 2</h2>
        <p><strong>La logique Bi-polaire :</strong></p>
        <ul>
            <li>Basée sur l'utilisation de <strong>transistors bipolaires</strong> (BJT - Bipolar Junction Transistor).</li>
            <li>C'est la <strong>famille originelle des transistors</strong> utilisés pour la logique intégrée.</li>
            <li>Caractéristiques générales :
                <ul>
                     <li><strong>Bipolaire = Rapidité :</strong> Les technologies bipolaires (comme TTL, ECL) étaient historiquement plus rapides que les premières technologies MOS.</li>
                     <li><strong>Bipolaire = Consommation :</strong> Elles tendent à consommer plus de puissance, notamment au repos (consommation statique), comparées aux technologies CMOS modernes.</li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Page 194: TTL Family Schematic -->
    <div class="slide" id="page194">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Bipolaire</h2>
        <p><strong>La Famille TTL : Transistor - Transistor - Logic</strong></p>
        <ul>
             <li>Une des familles logiques bipolaires les plus répandues et standardisées.</li>
             <li>Caractérisée par un étage d'entrée utilisant un transistor multi-émetteurs (ou des diodes dans des variantes) et un étage de sortie "totem-pole" pour une bonne capacité de pilotage.</li>
        </ul>
        <p>Exemple : Schéma d'une porte NAND TTL standard :</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_ttl_nand_gate.png" alt="Schéma d'une porte NAND TTL standard" style="max-width: 350px;">
             <p style="color: #666;">[Placeholder for Standard TTL NAND Gate Schematic]</p>
        </div>
        <ul>
             <li>Le transistor d'entrée (à gauche, avec émetteurs A et B) réalise la fonction ET inversée sur sa base.</li>
            <li>Les transistors suivants forment un inverseur de phase et l'étage de sortie push-pull (totem-pole).</li>
            <li>Fonctionnement : Si A=1 ET B=1, la sortie S est BASSE ('0'). Sinon (A=0 OU B=0), la sortie S est HAUTE ('1'). C'est une porte NAND.</li>
         </ul>
    </div>

    <!-- Page 195: TTL Characteristics 1 -->
    <div class="slide" id="page195">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">T.T.L 1</h2>
        <p>Caractéristiques de la famille TTL standard :</p>
        <ul>
             <li><strong>Historique :</strong> Première famille largement commercialisée vers <strong>1964</strong> par <strong>Texas Instruments</strong>.</li>
            <li><strong>Famille 54/74 :</strong> Introduite sous deux séries :
                <ul>
                    <li>Série 54 : Gamme de température militaire (-55°C à +125°C).</li>
                    <li>Série 74 : Gamme de température commerciale/industrielle (0°C à +70°C).</li>
                 </ul>
                La numérotation (ex: 7400 pour 4 portes NAND 2 entrées) est devenue un standard de facto.
            </li>
             <li><strong>Famille 74 : Famille de référence.</strong> Les spécifications de la série 74 sont devenues la référence pour la logique TTL.</li>
             <li><strong>Tous les fabricants utilisent cette référence :</strong> De nombreux fabricants ont produit des circuits compatibles TTL 74xx.</li>
            <li><strong>Compatibilité des circuits entre eux :</strong> Les circuits de la même famille (ex: TTL standard) sont conçus pour être directement interconnectables (niveaux logiques et caractéristiques d'entrée/sortie compatibles).</li>
            <li><strong>Tension d'alimentation :</strong> Fonctionne typiquement avec une alimentation unique de <strong>5V</strong> (±5% ou ±10% selon les séries). Vdd = 5V, Vss = 0V (masse).</li>
            <li><strong>Niveaux logiques (typique pour TTL standard) :</strong>
                 <ul>
                     <li><strong>1 logique (HAUT) :</strong> Tension de sortie garantie > 2.4V. Tension d'entrée reconnue comme HAUT (<strong>V<sub>ih</sub></strong> - Voltage input high) doit être <strong>> 2.0V</strong>.</li>
                     <li><strong>0 logique (BAS) :</strong> Tension de sortie garantie < 0.4V. Tension d'entrée reconnue comme BAS (<strong>V<sub>il</sub></strong> - Voltage input low) doit être <strong>< 0.8V</strong>.</li>
                     <li>La zone entre 0.8V et 2.0V est une zone de transition indéterminée pour les entrées.</li>
                 </ul>
             </li>
        </ul>
    </div>

    <!-- Page 196: TTL Characteristics 2 (Variants) -->
    <div class="slide" id="page196">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">T.T.L 2</h2>
        <p><strong>Plusieurs Variantes</strong> de la famille TTL 74xx ont été développées pour optimiser certaines caractéristiques (vitesse, consommation) :</p>
        <ul>
             <li><strong>74L (Low power) :</strong> Famille à faible consommation, mais plus lente que la standard.</li>
             <li><strong>74H (High speed) :</strong> Famille plus rapide, mais consommant plus.</li>
             <li><strong>74S (Schottky) :</strong> Famille rapide basée sur l'utilisation de transistors et diodes <strong>Schottky</strong> pour éviter la saturation profonde des transistors bipolaires, réduisant ainsi le temps de commutation. Consomme plus que la standard.</li>
             <li><strong>74LS (Low power Schottky) :</strong> Compromis très populaire offrant une vitesse comparable à la TTL standard (voire meilleure) mais avec une consommation nettement réduite (comparable à la 74L). Probablement la série TTL la plus utilisée.</li>
             <li><strong>74AS (Advanced Schottky)</strong> et <strong>74ALS (Advanced Low power Schottky) :</strong> Familles améliorées (plus rapides et/ou moins consommatrices) par rapport aux séries S et LS.</li>
             <li>D'autres séries existent également (F - Fast, etc.).</li>
        </ul>
    </div>

    <!-- Page 197: TTL Characteristics 3 (Comparison Table) -->
    <div class="slide" id="page197">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">T.T.L 3</h2>
        <p>Comparaison des performances typiques de quelques variantes TTL (par porte) :</p>
         <table border="1">
             <thead>
                 <tr>
                     <th>Paramètre</th>
                     <th>Unité</th>
                     <th>74 (Std)</th>
                     <th>74L</th>
                     <th>74S</th>
                     <th>74LS</th>
                     <th>74ALS</th>
                 </tr>
             </thead>
            <tbody>
                 <tr><td>\( t_p \) (Temps Propag.)</td><td>ns</td><td>9</td><td>33</td><td>3</td><td>9,5</td><td>4</td></tr>
                 <tr><td>P (Puiss. Dissip.)</td><td>mW</td><td>10</td><td>1</td><td>20</td><td>2</td><td>1,2</td></tr>
                 <tr><td>\( F_{max} \) (Fréq. Max)</td><td>MHz</td><td>35</td><td>3</td><td>125</td><td>45</td><td>70 (200 pour AS)</td></tr>
                 <tr><td>Sortance (Fan-out)</td><td>(unités)</td><td>10</td><td>20</td><td>20</td><td>20</td><td>20 (40 pour AS)</td></tr>
             </tbody>
         </table>
         <p>Interprétation :</p>
         <ul>
             <li>On voit les compromis : la 74L est très basse consommation mais lente. La 74S est très rapide mais consomme beaucoup.</li>
             <li>La 74LS offre un bon équilibre, similaire en vitesse à la 74 standard mais consommant 5 fois moins.</li>
             <li>Les familles ALS et AS améliorent encore la vitesse (AS) ou le compromis vitesse/consommation (ALS).</li>
             <li>La sortance indique combien d'entrées TTL standard une sortie peut piloter (souvent 10 pour la standard, 20 pour les autres).</li>
         </ul>
         <p><em>(Note : Les valeurs sont typiques et peuvent varier légèrement selon le fabricant et la fonction logique spécifique).</em></p>
    </div>

    <!-- Page 198: Other Bipolar Families -->
    <div class="slide" id="page198">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Bipolaire</h2>
        <p>Il existe d'autres technologies bipolaires pour le numérique, moins courantes que TTL mais notables :</p>
        <ul>
             <li><strong>ECL : Emitter Coupled Logic</strong> (Logique à Emetteurs Couplés)
                 <ul>
                     <li>Conçue pour être <strong>extrêmement rapide</strong>. Les transistors ne saturent jamais, ce qui élimine le délai de stockage.</li>
                    <li>Fonctionne sur des différentiels de tension plus faibles.</li>
                    <li>Inconvénients : <strong>Plus chère</strong> et <strong>consomme beaucoup</strong> de puissance en permanence. Niveaux logiques non compatibles directement avec TTL/CMOS.</li>
                    <li>Utilisée historiquement dans les supercalculateurs et les équipements de télécommunication très haute vitesse.</li>
                 </ul>
             </li>
             <li><strong>I<sup>2</sup>L (ou IIL) : Integrated Injection Logic</strong>
                <ul>
                    <li>Permet une très haute densité d'intégration pour une technologie bipolaire et une faible consommation à basse vitesse.</li>
                    <li><strong>Utilisée</strong> dans certains <strong>circuits logiques complexes</strong> spécifiques (où la densité et la puissance étaient critiques) mais largement supplantée par CMOS.</li>
                 </ul>
             </li>
        </ul>
    </div>

    <!-- Page 199: Technology Trends -->
    <div class="slide" id="page199">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Maintenant et Demain</h2>
        <ul>
            <li><strong>Quelle technologie aujourd'hui et demain ?</strong> Le paysage technologique évolue constamment.</li>
            <li>Il est <strong>hasardeux de prédire l'avenir</strong> avec certitude.</li>
            <li><strong>Mais ...</strong> on peut observer des tendances et s'appuyer sur les feuilles de route des fabricants.</li>
            <li><strong>Prévisions Texas Instruments (Exemple) :</strong> Les fabricants publient souvent des diagrammes de cycle de vie pour leurs familles de produits.</li>
        </ul>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_ti_lifecycle.png" alt="Diagramme de cycle de vie des familles logiques (Exemple TI)" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for TI Product Life Cycle Chart]</p>
        </div>
        <p>Interprétation du graphique (générique) :</p>
        <ul>
             <li><strong>Axes :</strong> Le temps ou l'évolution technologique en abscisse, le volume de production ou la pertinence sur le marché en ordonnée (implicite).</li>
             <li><strong>Phases :</strong> Introduction -> Croissance (Growth) -> Maturité (Maturity) -> Déclin (Decline) -> Obsolescence.</li>
             <li><strong>Familles Logiques :</strong> Diverses familles (TTL, LS, S, AS, ALS, HC, AC, AHC, LVC, AUC, etc.) sont positionnées sur ce cycle.</li>
            <li><strong>Technologie (Légende) :</strong> Indique si la famille est Bipolaire (TTL), CMOS ou BiCMOS (mélange).</li>
             <li><strong>Tendance générale :</strong> On observe un déclin des anciennes familles bipolaires (TTL, S, LS...) au profit des familles CMOS (HC, AC, AHC, ALVC, LVC, AUC...) et BiCMOS (ABT, LVT...) qui offrent de meilleures performances (vitesse, consommation, tension d'alimentation réduite - LV = Low Voltage). Les familles les plus récentes sont en phase d'introduction ou de croissance.</li>
        </ul>
    </div>

    <!-- Page 200: CMOS Advantages -->
    <div class="slide" id="page200">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">CMOS</h2>
        <p>La technologie <strong>CMOS (Complementary Metal-Oxide-Semiconductor)</strong> est devenue dominante pour la plupart des circuits numériques, des microprocesseurs aux logiques standards.</p>
        <p><strong>Avantages du CMOS :</strong></p>
        <ul>
             <li><strong>Faible Coût :</strong> Processus de fabrication bien maîtrisé et adapté à la production de masse.</li>
            <li><strong>Facilité de fabrication :</strong> Bien que complexe, la fabrication CMOS est très optimisée.</li>
            <li><strong>Petite Dimension / Haute Densité :</strong> Les transistors CMOS (MOSFETs) peuvent être rendus extrêmement petits, permettant une très haute densité d'intégration (des milliards de transistors sur une puce). Le rapport de densité par rapport aux technologies bipolaires peut être très élevé (le chiffre "50" est indicatif et dépend des générations comparées).</li>
             <li><strong>Pas d'élément résistif (ou presque) :</strong> Les portes CMOS de base n'utilisent pas de résistances de charge comme en TTL ou NMOS, ce qui contribue à la densité et à la faible consommation statique. (Des résistances peuvent être utilisées pour d'autres fonctions, mais pas dans l'inverseur CMOS de base).</li>
            <li><strong>Faible consommation originale (Statique) :</strong> Idéalement, une porte CMOS statique ne consomme quasiment pas de courant lorsqu'elle n'est pas en train de commuter (état stable 0 ou 1). La consommation principale ("dynamique") se produit lors des transitions (charge/décharge des capacités parasites). C'est un avantage majeur par rapport aux technologies bipolaires comme TTL ou ECL.</li>
         </ul>
        <p>Le CMOS est basé sur l'utilisation de paires complémentaires de transistors MOSFET (un type N et un type P) pour construire les portes logiques.</p>
    </div>

    <!-- Continuing the document... -->

    <!-- Section Transition: CMOS Technology Details -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Technologie CMOS</h2>

    <!-- Page 201: CMOS Basics - Transistor Types -->
    <div class="slide" id="page201">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Principe de Base du CMOS - 1</h2>
        <p>La technologie CMOS (Complementary Metal-Oxide-Semiconductor) utilise deux types de transistors à effet de champ (MOSFETs) :</p>
        <ul>
            <li><strong>Il existe deux types de transistors dans le CMOS :</strong>
                <div style="display: flex; justify-content: space-around; align-items: center; margin: 15px 0;">
                     <div>
                         <img src="placeholder_pmos_symbol.png" alt="Symbole transistor PMOS" style="max-height: 100px;">
                         <p style="text-align: center;">le PMOS</p>
                     </div>
                     <div>
                         <img src="placeholder_nmos_symbol.png" alt="Symbole transistor NMOS" style="max-height: 100px;">
                         <p style="text-align: center;">le NMOS</p>
                     </div>
                 </div>
                 <ul>
                    <li><strong>PMOS (P-channel MOS):</strong> Conduit lorsque sa tension de grille (\( V_g \)) est suffisamment <em>inférieure</em> à sa tension de source (\( V_s \)). Le cercle sur la grille du symbole indique un type P (souvent omis dans les schémas simplifiés). Laisse passer les niveaux HAUTS ('1', Vdd) efficacement.</li>
                    <li><strong>NMOS (N-channel MOS):</strong> Conduit lorsque sa tension de grille (\( V_g \)) est suffisamment <em>supérieure</em> à sa tension de source (\( V_s \)). Laisse passer les niveaux BAS ('0', Vss) efficacement.</li>
                </ul>
            </li>
            <li><strong>Mise en oeuvre de charges mobiles de polarité complémentaire :</strong> Les PMOS utilisent des "trous" (charge positive) comme porteurs majoritaires, les NMOS utilisent des électrons (charge négative). Ils fonctionnent de manière complémentaire.
                <br>⇒ D'où le nom <strong>Complementary MOS</strong> (CMOS).
            </li>
             <li>Conditions de conduction (simplifiées) :
                 <ul>
                     <li><strong>NMOS conduit si \( V_g > V_s \) de plus de \( V_T \)</strong> (où \( V_T \) est la tension de seuil, positive pour un NMOS standard). Plus précisément, si \( V_{gs} = V_g - V_s > V_{T,nmos} \).</li>
                     <li><strong>PMOS conduit si \( V_g < V_s \) de plus de \( |V_T| \)</strong> (où \( V_T \) est négative pour un PMOS standard). Plus précisément, si \( V_{sg} = V_s - V_g > |V_{T,pmos}| \). La formulation de la diapo est un peu ambiguë.</li>
                 </ul>
            </li>
         </ul>
         <p><em>\( V_g \)=Tension Grille, \( V_s \)=Tension Source, \( V_T \)=Tension de Seuil.</em></p>
    </div>

    <!-- Page 202: CMOS Basics - Switch Model -->
    <div class="slide" id="page202">
         <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Principe de Base du CMOS - 2</h2>
        <p>En logique <strong>Numérique</strong>, les transistors CMOS sont utilisés principalement comme des interrupteurs commandés par la tension de grille (\( V_g \)). On considère généralement la source (\( V_s \)) du NMOS connectée à Vss (0V) et la source du PMOS connectée à Vdd.</p>
        <ul>
             <li><strong>Numérique ⇒ Fonctionnement en mode interrupteur :</strong>
                <ul>
                    <li><strong>NMOS :</strong>
                         <ul>
                             <li>\( V_g = 0 \) (par rapport à \( V_s = 0 \)) ⇒ \( V_{gs} < V_T \) ⇒ Transistor <strong>bloqué</strong> (OFF), équivalent à un <strong>interrupteur ouvert</strong>.</li>
                             <li>\( V_g = V_{dd} \) (par rapport à \( V_s = 0 \)) ⇒ \( V_{gs} > V_T \) ⇒ Transistor <strong>passant</strong> (ON), équivalent à un <strong>interrupteur fermé</strong> (connecte à Vss).</li>
                         </ul>
                     </li>
                     <li><strong>PMOS :</strong>
                         <ul>
                             <li>\( V_g = 0 \) (par rapport à \( V_s = V_{dd} \)) ⇒ \( V_{sg} = V_{dd} > |V_T| \) ⇒ Transistor <strong>passant</strong> (ON), équivalent à un <strong>interrupteur fermé</strong> (connecte à Vdd).</li>
                             <li>\( V_g = V_{dd} \) (par rapport à \( V_s = V_{dd} \)) ⇒ \( V_{sg} = 0 < |V_T| \) ⇒ Transistor <strong>bloqué</strong> (OFF), équivalent à un <strong>interrupteur ouvert</strong>.</li>
                        </ul>
                     </li>
                 </ul>
             </li>
        </ul>
        <p>Comportement complémentaire : Pour une même tension de grille (0 ou Vdd), l'un des transistors (NMOS ou PMOS) est passant et l'autre est bloqué.</p>
    </div>

    <!-- Page 203: CMOS Inverter Schematic -->
    <div class="slide" id="page203">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Utilisation du CMOS - l'Inverseur</h2>
        <p><strong>Réalisation</strong> de l'inverseur logique (porte NON), le composant de base de la logique CMOS :</p>
        <div style="display: flex; justify-content: space-around; align-items: center; margin: 15px 0;">
            <div>
                 <p>Symboles logiques :</p>
                 <img src="placeholder_inverter_symbols.png" alt="Symboles ANSI et IEC pour un inverseur" style="max-height: 60px;">
                 <p style="color: #666;">[Placeholder: Inverter Symbols ANSI/IEC]</p>
             </div>
             <div>
                 <p>Schéma Transistor CMOS :</p>
                 <img src="placeholder_cmos_inverter_schematic.png" alt="Schéma transistor d'un inverseur CMOS" style="max-height: 180px;">
                 <p style="color: #666;">[Placeholder: CMOS Inverter Schematic]</p>
             </div>
        </div>
        <ul>
             <li>Il est constitué d'un transistor <strong>PMOS</strong> (en haut, connecté à Vdd) et d'un transistor <strong>NMOS</strong> (en bas, connecté à Vss).</li>
             <li>Les <strong>grilles</strong> des deux transistors sont connectées ensemble et forment l'entrée de l'inverseur (A).</li>
             <li>Les <strong>drains</strong> des deux transistors sont connectés ensemble et forment la sortie de l'inverseur.</li>
        </ul>
        <p>Fonctionnement :</p>
        <ul>
             <li>Si Entrée A = 0 (Vss) :
                 <ul>
                     <li>PMOS : \( V_g=0, V_s=V_{dd} \Rightarrow \) PMOS est ON (passant).</li>
                     <li>NMOS : \( V_g=0, V_s=0 \Rightarrow \) NMOS est OFF (bloqué).</li>
                     <li>La sortie est connectée à Vdd via le PMOS passant. => Sortie = 1 (Vdd).</li>
                 </ul>
             </li>
            <li>Si Entrée A = 1 (Vdd) :
                <ul>
                    <li>PMOS : \( V_g=V_{dd}, V_s=V_{dd} \Rightarrow \) PMOS est OFF (bloqué).</li>
                    <li>NMOS : \( V_g=V_{dd}, V_s=0 \Rightarrow \) NMOS est ON (passant).</li>
                    <li>La sortie est connectée à Vss via le NMOS passant. => Sortie = 0 (Vss).</li>
                 </ul>
            </li>
        </ul>
        <p>Le circuit réalise bien la fonction d'inversion : Sortie = \( \overline{A} \).</p>
    </div>

    <!-- Page 204: CMOS Inverter Model -->
    <div class="slide" id="page204">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Utilisation du CMOS - l'Inverseur</h2>
        <p><strong>Modélisation</strong> du fonctionnement de l'inverseur CMOS comme un jeu d'interrupteurs commandés :</p>
        <div style="display: flex; justify-content: space-around; align-items: center; margin: 15px 0; flex-wrap: wrap;">
             <div>
                 <p>Entrée A = 1 (Vdd) :</p>
                 <img src="placeholder_cmos_inv_model_A1.png" alt="Modèle interrupteur inverseur CMOS, Entrée=1" style="max-height: 180px;">
                 <p style="color: #666;">[Placeholder: CMOS Inv Model A=1]</p>
                 <p>PMOS ouvert, NMOS fermé. Sortie connectée à Vss (0).</p>
             </div>
             <div>
                 <p>Entrée A = 0 (Vss) :</p>
                 <img src="placeholder_cmos_inv_model_A0.png" alt="Modèle interrupteur inverseur CMOS, Entrée=0" style="max-height: 180px;">
                 <p style="color: #666;">[Placeholder: CMOS Inv Model A=0]</p>
                 <p>PMOS fermé, NMOS ouvert. Sortie connectée à Vdd (1).</p>
            </div>
         </div>
        <p>Ce modèle illustre pourquoi la consommation statique est (idéalement) nulle : dans les deux états stables (entrée à 0 ou à 1), il n'y a jamais de chemin direct entre Vdd et Vss à travers les transistors ON. L'un est toujours ouvert.</p>
    </div>

    <!-- Page 205: CMOS Inverter Transfer Curve -->
    <div class="slide" id="page205">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Caractéristique d'un inverseur CMOS</h2>
        <p><strong>Courbe de Transfert (VTC - Voltage Transfer Characteristic) :</strong></p>
        <p>Trace la tension de sortie (Vout) en fonction de la tension d'entrée (Vin) variant de 0 à Vdd.</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_cmos_inv_vtc.png" alt="Courbe de transfert d'un inverseur CMOS" style="max-width: 400px;">
             <p style="color: #666;">[Placeholder: CMOS Inverter VTC]</p>
         </div>
         <ul>
            <li>Pour Vin proche de 0, Vout est proche de Vdd.</li>
            <li>Pour Vin proche de Vdd, Vout est proche de 0 (Vss).</li>
            <li>Il existe une zone de transition très abrupte (forte pente) autour du point de commutation (idéalement à Vdd/2).</li>
            <li>Cette forte pente est avantageuse : elle assure une bonne régénération des signaux et une bonne immunité au bruit (marge de bruit). Une petite variation de Vin autour du point de commutation provoque une grande variation de Vout, ramenant rapidement la sortie vers Vdd ou Vss.</li>
         </ul>
    </div>

    <!-- Page 206: CMOS Inverter Current Consumption -->
    <div class="slide" id="page206">
         <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Caractéristique d'un inverseur CMOS</h2>
        <p><strong>Courant Consommé (Ic) :</strong></p>
         <p>Trace le courant tiré de l'alimentation (Idd) en fonction de la tension d'entrée (Vin).</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_cmos_inv_icc.png" alt="Courant consommé par un inverseur CMOS en fonction de Vin" style="max-width: 400px;">
            <p style="color: #666;">[Placeholder: CMOS Inverter Current Consumption]</p>
         </div>
         <ul>
             <li>Lorsque Vin = 0 ou Vin = Vdd (états stables), le courant consommé (courant statique) est idéalement <strong>nul</strong> (très faible en pratique, dû aux courants de fuite).</li>
            <li>Pendant la <strong>transition</strong> de Vin (autour du point de commutation), il y a un court instant où le transistor PMOS et le transistor NMOS sont <strong>simultanément partiellement conducteurs</strong>.</li>
            <li>Cela crée un chemin de courant direct (mais résistif) entre Vdd et Vss, provoquant un pic de courant appelé <strong>courant de court-circuit</strong> (ou "shoot-through current").</li>
            <li>Ce courant de court-circuit contribue à la consommation dynamique (liée aux commutations). L'autre composante majeure de la consommation dynamique est due à la charge et décharge des capacités parasites (internes et de charge).</li>
            <li>La consommation moyenne augmente avec la fréquence de commutation.</li>
        </ul>
    </div>

    <!-- Page 207: CMOS Inverter Equivalent Circuit -->
    <div class="slide" id="page207">
         <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Schéma Equivalent d'un inverseur CMOS</h2>
        <p>Modèle simplifié pour l'analyse de base :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_cmos_inv_equiv.png" alt="Schéma équivalent simplifié d'un inverseur CMOS" style="max-width: 400px;">
             <p style="color: #666;">[Placeholder: CMOS Inverter Equivalent Circuit]</p>
        </div>
        <ul>
            <li>L'entrée ('in') présente une capacité (due aux grilles des transistors MOS, qui sont isolées).</li>
            <li>La sortie ('out') est modélisée par un interrupteur commandé qui connecte la sortie soit à Vdd, soit à Vss.</li>
            <li>Une résistance de sortie équivalente (boîte noire) représente la résistance des transistors passants.</li>
            <li>Une capacité de charge (non montrée explicitement, mais connectée à 'out') représente la capacité des entrées des portes suivantes et la capacité des fils.</li>
         </ul>
        <p>Limites et applications du modèle :</p>
        <ul>
             <li>Ce type de modèle simplifié peut être <strong>cohérent jusqu'à une certaine fréquence</strong> (ex: 20 MHz mentionné, très dépendant de la technologie réelle). Au-delà, des effets plus complexes dominent.</li>
            <li>Il <strong>permet de modéliser</strong> grossièrement la <strong>sortance</strong> (fan-out) d'une porte : la capacité de la sortie à charger/décharger la capacité totale des entrées connectées dans un temps donné dépend de la résistance de sortie équivalente et des capacités.</li>
        </ul>
    </div>

    <!-- Page 208: CMOS Complementarity - NAND Gate Intro -->
    <div class="slide" id="page208">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">La complémentarité - La porte Non-ET (NAND)</h2>
        <p>Construction de portes logiques plus complexes en CMOS, en respectant le principe de complémentarité.</p>
        <p>Porte NON-ET (NAND) à 2 entrées :</p>
        <div style="display: flex; justify-content: space-around; align-items: center; margin: 15px 0;">
             <img src="placeholder_nand_symbols.png" alt="Symboles ANSI et IEC pour une porte NAND" style="max-height: 70px;">
             <p style="color: #666;">[Placeholder: NAND gate Symbols ANSI/IEC]</p>
         </div>
         <p>Fonction logique : Sortie = \( \overline{A \cdot B} \)</p>
    </div>

    <!-- Page 209: CMOS NAND Gate Schematic -->
    <div class="slide" id="page209">
         <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">La complémentarité - La porte Non-ET</h2>
        <p>Schéma transistor d'une porte NAND CMOS à 2 entrées (A, B) et sortie S :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_cmos_nand_schematic.png" alt="Schéma transistor d'une porte NAND CMOS" style="max-width: 350px;">
             <p style="color: #666;">[Placeholder: CMOS NAND Gate Schematic]</p>
         </div>
        <p>Structure :</p>
         <ul>
             <li><strong>Réseau "Pull-Up" (vers Vdd) :</strong> Deux transistors <strong>PMOS en parallèle</strong>. Commandés par A et B. Ce réseau connecte S à Vdd si A=0 OU B=0.</li>
             <li><strong>Réseau "Pull-Down" (vers Vss) :</strong> Deux transistors <strong>NMOS en série</strong>. Commandés par A et B. Ce réseau connecte S à Vss si A=1 ET B=1.</li>
        </ul>
        <p>Fonctionnement :</p>
         <ul>
             <li>Si A=0 OU B=0 : Au moins un PMOS est ON, connectant S à Vdd. Au moins un NMOS est OFF, coupant le chemin vers Vss. => Sortie S = 1.</li>
            <li>Si A=1 ET B=1 : Les deux PMOS sont OFF. Les deux NMOS sont ON, connectant S à Vss. => Sortie S = 0.</li>
         </ul>
         <p>Le circuit réalise bien la fonction NAND (\( \overline{A \cdot B} \)). Notez la structure complémentaire : où les PMOS sont en parallèle, les NMOS sont en série.</p>
    </div>

    <!-- Page 210: CMOS Complementarity - NOR Gate Intro -->
    <div class="slide" id="page210">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">La complémentarité - La porte Non-OU (NOR)</h2>
        <p>Porte NON-OU (NOR) à 2 entrées :</p>
         <div style="display: flex; justify-content: space-around; align-items: center; margin: 15px 0;">
            <img src="placeholder_nor_symbols.png" alt="Symboles ANSI et IEC pour une porte NOR" style="max-height: 70px;">
            <p style="color: #666;">[Placeholder: NOR gate Symbols ANSI/IEC]</p>
         </div>
        <p>Fonction logique : Sortie = \( \overline{A + B} \)</p>
        <p>(Le schéma transistor sera probablement sur la page suivante, montrant la structure complémentaire inverse de la NAND : PMOS en série, NMOS en parallèle).</p>
    </div>

    <!-- Continuing the document... -->

    <!-- Page 211: CMOS NOR Gate Schematic -->
    <div class="slide" id="page211">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">La complémentarité - La porte Non-OU (NOR)</h2>
        <p>Schéma transistor d'une porte NOR CMOS à 2 entrées (A, B) et sortie S :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_cmos_nor_schematic.png" alt="Schéma transistor d'une porte NOR CMOS" style="max-width: 350px;">
             <p style="color: #666;">[Placeholder: CMOS NOR Gate Schematic]</p>
        </div>
         <p>Structure (complémentaire de la NAND) :</p>
        <ul>
            <li><strong>Réseau "Pull-Up" (vers Vdd) :</strong> Deux transistors <strong>PMOS en série</strong>. Commandés par A et B. Ce réseau connecte S à Vdd si A=0 ET B=0.</li>
             <li><strong>Réseau "Pull-Down" (vers Vss) :</strong> Deux transistors <strong>NMOS en parallèle</strong>. Commandés par A et B. Ce réseau connecte S à Vss si A=1 OU B=1.</li>
        </ul>
         <p>Fonctionnement :</p>
        <ul>
            <li>Si A=1 OU B=1 : Au moins un NMOS est ON, connectant S à Vss. Au moins un PMOS est OFF, coupant le chemin vers Vdd. => Sortie S = 0.</li>
            <li>Si A=0 ET B=0 : Les deux NMOS sont OFF. Les deux PMOS sont ON, connectant S à Vdd. => Sortie S = 1.</li>
        </ul>
         <p>Le circuit réalise bien la fonction NOR (\( \overline{A + B} \)).</p>
    </div>

    <!-- Page 212: CMOS Limits -->
    <div class="slide" id="page212">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">CMOS - limites ?</h2>
        <p>Bien que dominante, la technologie CMOS a aussi ses limites, notamment en termes de consommation à haute fréquence.</p>
        <ul>
            <li><strong>Consommation dynamique :</strong> La principale source de consommation dans les circuits CMOS rapides est due à la commutation (charge/décharge des capacités). Elle est approximativement proportionnelle à :
                <div class="formula">
                     \( P \approx \alpha \times C \times V_{dd}^2 \times F \)
                 </div>
                 Où :
                 <ul>
                     <li>\( P \) est la puissance dynamique dissipée.</li>
                     <li>\( \alpha \) est le facteur d'activité (probabilité qu'une sortie commute à chaque cycle d'horloge, \(0 \le \alpha \le 1\)).</li>
                    <li>\( C \) est la <strong>capacité totale</strong> commutée (capacités internes des portes + capacités des interconnexions + capacités d'entrée des portes pilotées).</li>
                    <li>\( V_{dd} \) est la tension d'alimentation.</li>
                    <li>\( F \) est la <strong>fréquence</strong> de fonctionnement (fréquence d'horloge ou de commutation).</li>
                </ul>
                 <em>(La formule sur la diapositive \( P \equiv V_{dd}^2 \times C \times F \) omet le facteur d'activité \( \alpha \), mais capture les dépendances principales).</em>
             </li>
             <li>La consommation est donc <strong>due à la commutation</strong>.</li>
             <li><strong>Comparaison avec Bipolaire à haute fréquence/complexité :</strong> A technologie constante (Vdd, taille des transistors), si la fréquence \( F \) ou la capacité totale \( C \) (liée à la complexité du circuit) augmente significativement, la consommation dynamique du CMOS peut finir par devenir importante, voire dépasser celle de certaines technologies bipolaires optimisées pour la vitesse dans des niches spécifiques (bien que ce soit rare en pratique générale aujourd'hui).</li>
             <li>Stratégies pour réduire la consommation CMOS :
                 <ul>
                     <li><strong>Baisser la tension d'alimentation \( V_{dd} \) :</strong> Très efficace car la puissance dépend du carré de \( V_{dd} \). C'est la tendance majeure (5V -> 3.3V -> 1.8V -> 1.2V -> <1V).</li>
                     <li><strong>Modifier les procédés technologiques de fabrication de CI :</strong> Réduire la taille des transistors (diminue C), utiliser de nouveaux matériaux (réduit les fuites), optimiser l'architecture pour réduire l'activité (\( \alpha \)) et la capacité commutée (gestion d'horloge, clock gating).</li>
                 </ul>
            </li>
        </ul>
    </div>

    <!-- Page 213: CMOS Families Chart 1 -->
    <div class="slide" id="page213">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Famille CMOS</h2>
        <ul>
            <li>Il existe <strong>plusieurs familles</strong> logiques basées sur la technologie CMOS, optimisées pour différentes tensions d'alimentation, vitesses, et capacités de sortie.</li>
             <li><strong>74HC (High-speed CMOS) :</strong> Une des premières familles CMOS populaires, conçue pour être rapide (comparable à 74LS TTL) et avoir des niveaux logiques d'entrée compatibles avec la TTL (<strong>Compatibilité TTL</strong>), facilitant l'interfaçage dans des systèmes mixtes. Alimentation typique 2V-6V.</li>
        </ul>
        <p>Graphique "Family Performance Positioning" (Exemple TI) :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_cmos_families_perf.png" alt="Graphique de positionnement des performances des familles logiques CMOS et BiCMOS" style="max-width: 800px;">
             <p style="color: #666;">[Placeholder for CMOS/BiCMOS Families Performance Positioning Chart]</p>
         </div>
         <p>Interprétation du graphique :</p>
         <ul>
             <li>Positionne différentes familles logiques (CMOS en bleu/vert, BiCMOS en marron) selon leur capacité de courant de sortie (\(I_{OL}\) Drive) et probablement leur vitesse (implicite sur l'axe horizontal ou par le positionnement général).</li>
            <li>Montre l'évolution vers des tensions d'alimentation plus basses (5V, 3.3V, 2.5V, 1.8V, 1.2V, 0.8V).</li>
             <li>Les familles plus récentes (LVC, ALVC, AUC, GTLP...) offrent des performances plus élevées (vitesse, courant de sortie) à des tensions plus faibles.</li>
         </ul>
    </div>

    <!-- Page 214: CMOS Families Chart 2 (Low Voltage Market) -->
    <div class="slide" id="page214">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Famille CMOS</h2>
        <p>Graphique "Low-Voltage Market - Coverage and Standardization" (Exemple TI) :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_cmos_families_lv.png" alt="Graphique des familles logiques CMOS basse tension" style="max-width: 800px;">
             <p style="color: #666;">[Placeholder for Low-Voltage CMOS Families Chart]</p>
         </div>
         <p>Interprétation du graphique :</p>
         <ul>
             <li>Cartographie différentes familles logiques (HC, LS, LV, AHC, LVC, LVT, ALVC, ALVT, AUC...) en fonction de leur <strong>tension d'alimentation</strong> (axe vertical, de 5V à 0.8V) et de leur <strong>performance en vitesse</strong> (axe horizontal).</li>
            <li>Met en évidence la couverture du marché "basse tension".</li>
            <li>Liste les caractéristiques clés de chaque famille (vitesse - \(t_{pd}\), courant de sortie - \(I_{OL}\), consommation statique, tolérance 5V, etc.).</li>
             <li>Montre une tendance claire vers des tensions plus basses et des vitesses plus élevées (coins inférieur droit et milieu droit).</li>
         </ul>
    </div>

    <!-- Page 215: CMOS Families Chart 3 (Little Logic) -->
    <div class="slide" id="page215">
        <div class="header-small">Cours d'électronique numérique - Technologie de circuits numériques</div>
        <h2 class="slide-title">Famille CMOS</h2>
        <p>Concept "Little Logic" (Exemple TI) :</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_cmos_little_logic.png" alt="Présentation du concept Little Logic de TI" style="max-width: 800px;">
            <p style="color: #666;">[Placeholder for Little Logic Concept Slide]</p>
        </div>
         <p>Interprétation :</p>
        <ul>
             <li><strong>Principe :</strong> Fournir des fonctions logiques très simples (une seule porte, deux portes, bascules simples, buffers...) dans des boîtiers (packages) extrêmement petits.</li>
             <li><strong>Objectif :</strong> Permettre aux concepteurs d'ajouter facilement de petites fonctions logiques ("glue logic") là où c'est nécessaire sur une carte, sans utiliser un composant programmable plus complexe ou un ASIC. Utile pour l'interfaçage, la conversion de niveau, la génération de signaux de contrôle simples.</li>
             <li><strong>Avantages :</strong> Simplification du routage, gain de place, flexibilité.</li>
             <li><strong>Exemples :</strong> Montre des fonctions simples (Single Gate, Dual Gate, Triple Gate) dans des boîtiers miniatures.</li>
             <li><strong>Nomenclature :</strong> Explique le système de nommage utilisé par TI pour ces composants (ex: SN74 LVC 1G 00 YEAR R).</li>
             <li><strong>Types de boîtiers :</strong> Liste différents types de boîtiers très petits (YEA=NanoStar, YZA=NanoFree, DCK=SC-70, DBV=SOT-23, etc.).</li>
        </ul>
    </div>

    <!-- Section Transition: Analog-Digital Conversion -->
    <h2 style="text-align:center; margin-top: 40px; color: #003399;">Conversion Analogique-Numérique / Numérique-Analogique</h2>

    <!-- Page 216: ADC/DAC References -->
    <div class="slide" id="page216">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">Références</h2>
        <p>Références pour la partie Conversion Analogique/Numérique :</p>
        <ul>
            <li><strong>Michel Hubin</strong> - Site personnel (physique/électronique).
                <br><a href="http://perso.wanadoo.fr/michel.hubin/physique/elec/chap_can" target="_blank">http://perso.wanadoo.fr/michel.hubin/physique/elec/chap_can...</a> (le lien est tronqué)
                <br><em>(Note : Lien potentiellement obsolète car Wanadoo n'existe plus sous ce nom. Recherche "Michel Hubin physique elec" pourrait mener au contenu s'il a été migré).</em>
            </li>
            <li>Autres références utiles (non listées) : Livres d'électronique analogique et numérique, fiches techniques (datasheets) de convertisseurs (ADC/DAC) de fabricants comme Texas Instruments, Analog Devices, Maxim Integrated, Microchip.</li>
        </ul>
    </div>

    <!-- Page 217: Communication Analog/Digital Worlds -->
    <div class="slide" id="page217">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">Communication</h2>
        <p>Rappel des natures différentes des mondes réel et numérique :</p>
        <ul>
             <li>Le <strong>monde numérique</strong> est un monde <strong>discrétisé</strong> (valeurs distinctes, souvent binaires).</li>
             <li>Le <strong>monde réel</strong> (grandeurs physiques : température, pression, son, lumière...) est un monde <strong>continu</strong> (peut prendre une infinité de valeurs dans un intervalle).</li>
             <li>Le monde (réel) <strong>n'est pas</strong> nativement numérique.</li>
            <li><strong>Comment Interfacer les 2 mondes ?</strong> Comment un système numérique peut-il mesurer ou interagir avec le monde réel ?</li>
            <li><strong>A travers des Capteurs</strong> (pour mesurer le monde réel) et des <strong>Actionneurs</strong> (pour agir sur le monde réel).</li>
        </ul>
    </div>

    <!-- Page 218: Sensors, ADC, DAC -->
    <div class="slide" id="page218">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">Communication</h2>
        <p>Rôle des composants d'interface :</p>
        <ul>
             <li><strong>Capteur = Fonction de conversion du <i>Monde</i> en grandeur électrique</strong>.
                 <ul><li>Transforme une grandeur physique (température, lumière, force...) en un signal électrique (tension, courant, résistance...).</li></ul>
             </li>
             <li>Le <strong>Capteur renvoie</strong> typiquement une <strong>Valeur Analogique</strong> (un signal électrique continu, proportionnel à la grandeur physique mesurée).</li>
            <li><strong>Nécessité d'une fonction de conversion Analogique - Numérique</strong> pour que le système numérique puisse traiter cette information.</li>
             <li>Cette fonction est réalisée par un <strong>Convertisseur Analogique Numérique : CAN</strong> (ou ADC : Analog-to-Digital Converter).</li>
             <li>Inversement, pour agir sur le monde réel, le système numérique doit générer un signal de commande, souvent analogique.</li>
            <li>La fonction de conversion Numérique - Analogique est réalisée par un <strong>Convertisseur Numérique Analogique : CNA</strong> (ou DAC : Digital-to-Analog Converter).</li>
        </ul>
    </div>

    <!-- Page 219: Interface Block Diagram -->
    <div class="slide" id="page219">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">Communication</h2>
        <p>Diagramme bloc de l'interface entre le monde physique et un système de traitement numérique :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_dac_interface.png" alt="Diagramme bloc interface Monde Réel / Système Numérique via Capteur/CAN et CNA/Actionneur" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for Analog/Digital Interface Block Diagram]</p>
         </div>
        <p>Flux d'information :</p>
        <ol>
             <li><strong>Monde Réel -> Capteur :</strong> Une grandeur physique est mesurée.</li>
             <li><strong>Capteur -> CAN :</strong> Le capteur produit une grandeur électrique analogique.</li>
             <li><strong>CAN -> Système Numérique :</strong> Le CAN convertit le signal analogique en une valeur numérique codée sur N bits.</li>
             <li><strong>Système Numérique :</strong> Traite l'information numérique.</li>
            <li><strong>Système Numérique -> CNA :</strong> Le système génère une commande numérique sur M bits.</li>
            <li><strong>CNA -> Actionneur :</strong> Le CNA convertit la valeur numérique en une grandeur électrique analogique.</li>
            <li><strong>Actionneur -> Monde Réel :</strong> L'actionneur utilise le signal analogique pour agir sur le monde physique (moteur, vanne, affichage...).</li>
         </ol>
    </div>

    <!-- Page 220: ADC Definitions -->
    <div class="slide" id="page220">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CAN : Définitions</h2>
        <p>
            La <strong>conversion analogique numérique (CAN / ADC)</strong> consiste à transformer une grandeur électrique (analogique, continue en valeur et en temps) représentée par un signal en une grandeur numérique (discrète en valeur et souvent en temps) exprimée sur N bits.
        </p>
        <p>Ce processus implique typiquement deux étapes clés :</p>
        <ul>
            <li><strong>Échantillonnage (Sampling) :</strong>
                 <ul><li>Consiste à prélever la valeur du signal analogique à des instants discrets et réguliers dans le temps (dictés par une fréquence d'échantillonnage).</li><li>Transforme un signal continu en temps en un signal discret en temps.</li></ul>
            </li>
             <li><strong>Quantification :</strong>
                <ul><li>Consiste à approximer la valeur de chaque échantillon (qui est encore une valeur analogique continue) par la valeur discrète la plus proche parmi un ensemble fini de niveaux de quantification.</li><li>Le nombre de niveaux est déterminé par le nombre de bits N du convertisseur (\( 2^N \) niveaux).</li><li>Introduit une erreur inhérente appelée "erreur de quantification".</li></ul>
            </li>
            <li><strong>Codage :</strong>
                 <ul><li>Attribuer un code binaire unique (sur N bits) à chaque niveau de quantification.</li></ul>
            </li>
        </ul>
        <p>
            Le résultat final est une <strong>valeur codée</strong> (un nombre binaire de N bits) représentant une approximation de la grandeur électrique à un instant donné, souvent proportionnelle à cette grandeur.
        </p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 221: ADC Definitions (Sampling, Quantization, Coding) -->
    <div class="slide" id="page221">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CAN : Définitions</h2>
        <p>Détail des étapes de la conversion Analogique-Numérique :</p>
        <ul>
            <li><strong>Échantillonnage (Sampling) :</strong>
                <ul>
                    <li>Prise périodique de la valeur instantanée du signal analogique.</li>
                    <li>La fréquence d'échantillonnage \( F_e \) doit être suffisamment élevée pour capturer les variations du signal.</li>
                    <li><strong>Attention à Shannon (Théorème de Nyquist-Shannon) :</strong> Pour pouvoir reconstruire (théoriquement) le signal original à partir des échantillons sans perte d'information (aliasing), la fréquence d'échantillonnage \( F_e \) doit être strictement supérieure à deux fois la fréquence maximale \( F_{signal} \) contenue dans le signal analogique.
                         <div class="formula">\( F_e > 2 \times F_{signal} \)</div>
                     </li>
                 </ul>
             </li>
            <li><strong>Quantification :</strong>
                 <ul>
                    <li>Association d'une mesure (l'échantillon analogique) à une valeur discrète parmi un nombre fini de niveaux.</li>
                    <li>La valeur échantillonnée est arrondie au niveau de quantification le plus proche.</li>
                    <li>C'est une fonction qui introduit une forme de "mémorisation" ou plutôt d'approximation : on perd l'information précise de la valeur analogique entre deux niveaux.</li>
                 </ul>
             </li>
             <li><strong>Échantillonneur-bloqueur (Sample and Hold) :</strong>
                 <ul>
                     <li>Pour le traitement pratique de l'Échantillonnage/Quantification, on parle souvent d'<strong>échantillonnage-blocage</strong> (Sample-and-Hold) ou d'<strong>échantillonnage-mémorisation</strong>.</li>
                    <li>Un circuit "Sample-and-Hold" (S/H) capture la valeur de l'échantillon et la maintient constante (la bloque) pendant que le quantificateur/codeur détermine la valeur numérique correspondante. Cela donne au convertisseur le temps d'opérer sur une valeur stable.</li>
                 </ul>
            </li>
            <li><strong>Codage :</strong>
                <ul>
                    <li>Représentation de la valeur quantifiée (le niveau choisi) dans un <strong>alphabet interprétable par un circuit numérique</strong>, typiquement un code binaire (binaire naturel, complément à deux, code Gray...) sur N bits.</li>
                </ul>
             </li>
        </ul>
    </div>

    <!-- Page 222: ADC Signal Representation -->
    <div class="slide" id="page222">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CAN : Définitions</h2>
        <p>Illustration des étapes de la conversion :</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_sampling_quantization.png" alt="Graphique montrant un signal continu, échantillonné et quantifié" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for ADC Sampling/Quantization Diagram]</p>
         </div>
         <ul>
             <li><strong>Signal continu (rose) :</strong> Le signal analogique original, variant continûment en temps et en amplitude.</li>
             <li><strong>Signal échantillonné (traits rouges verticaux) :</strong> Les valeurs du signal prises à des instants discrets (les "échantillons"). L'amplitude est encore continue à ce stade.</li>
            <li><strong>Signal quantifié (marches d'escalier bleues) :</strong> Chaque échantillon est arrondi au niveau de quantification le plus proche. Le signal devient discret en amplitude (et reste discret en temps). La différence entre le signal quantifié et le signal échantillonné représente l'erreur de quantification.</li>
        </ul>
    </div>

    <!-- Page 223: ADC Characteristics -->
    <div class="slide" id="page223">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CAN : Caractéristiques</h2>
        <p>Paramètres clés caractérisant un Convertisseur Analogique-Numérique (CAN / ADC) :</p>
        <ul>
            <li><strong>Résolution :</strong>
                <ul>
                    <li>Souvent exprimée en nombre de bits (N). Un CAN N bits a \( 2^N \) niveaux de quantification.</li>
                     <li>Peut aussi désigner l'amplitude de la plus petite variation détectable en entrée, qui correspond au pas de quantification (quantum).</li>
                    <li>Le pas de quantification (q) est souvent défini comme \( q = \frac{\text{Pleine Échelle}}{2^N} \).</li>
                    <li>Correspond à la valeur analogique représentée par le <strong>LSB (Least Significant Bit)</strong> du code numérique de sortie.</li>
                </ul>
            </li>
             <li><strong>Temps de conversion :</strong>
                <ul>
                    <li>Le temps total nécessaire au CAN pour effectuer une conversion complète (échantillonnage, quantification, codage) et fournir une donnée numérique stable en sortie après l'application de l'échantillon.</li>
                    <li>Détermine la fréquence d'échantillonnage maximale possible pour ce convertisseur.</li>
                </ul>
             </li>
            <li><strong>Erreur de Quantification :</strong>
                 <ul>
                     <li>L'incertitude (erreur) inhérente au processus de quantification, due à l'arrondi de la valeur analogique au niveau discret le plus proche.</li>
                     <li>Elle est typiquement comprise entre \( -q/2 \) et \( +q/2 \), où q est le pas de quantification.</li>
                 </ul>
             </li>
             <li><strong>Pleine Échelle (Full Scale Range, FSR) :</strong>
                <ul>
                    <li>L'étendue (la gamme) de la grandeur analogique d'entrée que le convertisseur peut traiter. Par exemple, 0V à 5V, -10V à +10V.</li>
                 </ul>
            </li>
            <li>D'autres caractéristiques existent : linéarité (INL, DNL), rapport signal/bruit (SNR), etc.</li>
        </ul>
    </div>

    <!-- Page 224: ADC Types -->
    <div class="slide" id="page224">
         <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CAN : Types</h2>
        <p>Il existe différents types (architectures) de convertisseurs Analogique-Numérique, chacun avec ses avantages et inconvénients en termes de vitesse, résolution, coût, consommation.</p>
        <p>Principaux types de conversion :</p>
        <ul>
            <li>La conversion <strong>à rampe</strong> (simple ou numérique) : Simple mais lente, dépendante de la précision de la rampe.</li>
            <li>La conversion <strong>à double rampe</strong> : Plus lente mais très précise et bonne réjection du bruit, souvent utilisée dans les multimètres.</li>
             <li>La conversion <strong>à approximations successives (SAR - Successive Approximation Register)</strong> : Très répandue, bon compromis vitesse/résolution/coût.</li>
             <li>La conversion <strong>Flash</strong> : Extrêmement rapide mais coûteuse et consommatrice, résolution limitée. Utilise un grand nombre de comparateurs en parallèle.</li>
             <li>La conversion <strong>Sigma-Delta ( \( \Sigma\Delta \) )</strong> : Permet d'atteindre de très hautes résolutions (audio, mesures de précision) en utilisant le sur-échantillonnage et la mise en forme du bruit de quantification. Vitesse de sortie des données plus faible que SAR ou Flash.</li>
             <li>D'autres types existent (pipeliné, temps-entrelacé...).</li>
        </ul>
    </div>

    <!-- Page 225: Single-Slope Ramp ADC Schematic -->
    <div class="slide" id="page225">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion à rampe (simple)</h2>
        <p>Principe du CAN à rampe simple (version analogique) :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_ramp_analog.png" alt="Schéma de principe d'un CAN à rampe simple (analogique)" style="max-width: 550px;">
             <p style="color: #666;">[Placeholder for Single-Slope Ramp ADC Schematic]</p>
        </div>
        <p>Composants :</p>
        <ul>
            <li><strong>Générateur de rampe :</strong> Produit une tension (Vc) qui augmente linéairement avec le temps (ici, réalisé par un intégrateur : source de courant constant chargeant un condensateur C).</li>
            <li><strong>Comparateur :</strong> Compare la tension d'entrée analogique (Vin) avec la tension de la rampe (Vc).</li>
            <li><strong>Compteur :</strong> Compte les impulsions d'horloge.</li>
            <li><strong>Logique de Contrôle :</strong> Gère le démarrage, l'arrêt du comptage et la remise à zéro (Raz).</li>
            <li><strong>Porte ET :</strong> Laisse passer les impulsions d'horloge vers le compteur tant que la sortie du comparateur est HAUTE.</li>
        </ul>
    </div>

    <!-- Page 226: Single-Slope Ramp ADC Operation -->
    <div class="slide" id="page226">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion à rampe</h2>
        <p>Fonctionnement du CAN à rampe simple (analogique) :</p>
        <ul>
             <li><strong>Phase 1 (Initialisation) :</strong> La logique de contrôle remet à zéro (Raz) le compteur (N=0) et décharge le condensateur C (Vc=0).</li>
             <li><strong>Phase 2 (Conversion) :</strong>
                 <ul>
                     <li>La logique de contrôle démarre la charge du condensateur C par la source de courant constant (I). La tension Vc commence à augmenter linéairement : \( V_c(t) = \frac{1}{C} \int I dt = \frac{I}{C} t \) (si Vc(0)=0). C'est la rampe.</li>
                    <li>Simultanément, la logique de contrôle autorise le comptage (via la porte ET).</li>
                     <li>Tant que \( V_{in} > V_c \), la sortie du comparateur est HAUTE (par exemple '1'), la porte ET est ouverte, et le compteur est incrémenté par les impulsions d'horloge.</li>
                    <li>Lorsque la tension de la rampe \( V_c \) atteint (et dépasse légèrement) la tension d'entrée \( V_{in} \), la sortie du comparateur passe à BAS ('0').</li>
                     <li>La porte ET se ferme, bloquant les impulsions d'horloge et arrêtant le compteur.</li>
                     <li>La valeur N atteinte par le compteur est proportionnelle au temps écoulé \(t\) pendant lequel \( V_{in} > V_c \). Comme \( V_c \) est proportionnelle à \(t\) et que \( V_c \approx V_{in} \) à la fin, la valeur N du compteur est proportionnelle à \( V_{in} \).</li>
                     <li>La valeur N finale est le résultat numérique de la conversion.</li>
                 </ul>
            </li>
        </ul>
        <p>Inconvénients : La précision dépend fortement de la linéarité et de la stabilité de la rampe (I, C) et de la fréquence d'horloge. Le temps de conversion dépend de la valeur de Vin (plus Vin est grand, plus la conversion est longue).</p>
    </div>

    <!-- Page 227: Digital Ramp ADC Schematic -->
    <div class="slide" id="page227">
         <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion à rampe numérique</h2>
        <p>Variante : Utilisation d'un <strong>CNA (DAC)</strong> pour générer une <strong>rampe numérique</strong> (en escalier) au lieu d'une rampe analogique linéaire.</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_ramp_digital.png" alt="Schéma de principe d'un CAN à rampe numérique" style="max-width: 550px;">
             <p style="color: #666;">[Placeholder for Digital Ramp ADC Schematic]</p>
         </div>
        <p>Fonctionnement :</p>
        <ul>
            <li>Le compteur démarre à 0.</li>
            <li>La sortie N du compteur est envoyée à un CNA, qui génère une tension analogique \( V_{CNA} \) proportionnelle à N.</li>
            <li>Le comparateur compare \( V_{in} \) à \( V_{CNA} \).</li>
             <li>Tant que \( V_{in} > V_{CNA} \), le compteur est incrémenté à chaque coup d'horloge. \( V_{CNA} \) augmente par paliers (rampe en escalier).</li>
            <li>Lorsque \( V_{CNA} \) atteint (et dépasse) \( V_{in} \), le comparateur bascule, arrêtant le compteur.</li>
            <li>La valeur N finale du compteur est le résultat numérique.</li>
        </ul>
         <p>Avantages/Inconvénients : Similaire à la rampe analogique en termes de principe et de vitesse (dépendante de Vin). Utilise des composants numériques (compteur, CNA) plus standards.</p>
    </div>

    <!-- Page 228: Dual-Slope ADC Schematic -->
    <div class="slide" id="page228">
         <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion double rampe</h2>
        <p>Principe du CAN à double rampe (Dual-Slope ADC) :</p>
         <div style="text-align: center; margin: 20px;">
            <img src="placeholder_adc_dual_slope.png" alt="Schéma de principe d'un CAN à double rampe" style="max-width: 600px;">
            <p style="color: #666;">[Placeholder for Dual-Slope ADC Schematic]</p>
         </div>
         <p>Composants clés :</p>
         <ul>
             <li><strong>Intégrateur analogique :</strong> (Amplificateur opérationnel avec R et C en rétroaction).</li>
             <li><strong>Comparateur :</strong> Détecte le passage par zéro de la sortie de l'intégrateur.</li>
             <li><strong>Compteur :</strong> Compte les impulsions d'horloge.</li>
             <li><strong>Logique de Contrôle :</strong> Gère les phases et les commutations.</li>
             <li><strong>Source de tension de référence (Vref) :</strong> Tension stable et précise, de polarité opposée à Vin.</li>
             <li><strong>Commutateur :</strong> Permet de connecter l'entrée de l'intégrateur soit à Vin, soit à Vref.</li>
         </ul>
    </div>

    <!-- Page 229: Dual-Slope ADC Operation -->
    <div class="slide" id="page229">
         <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion double rampe</h2>
        <p>Fonctionnement en deux phases :</p>
        <ul>
             <li><strong>Phase 1 (Intégration de Vin) :</strong>
                 <ul>
                     <li>Le commutateur connecte l'entrée de l'intégrateur à \( V_{in} \) (supposée positive ici).</li>
                     <li>L'intégrateur charge le condensateur C pendant une <strong>durée fixe \( T_0 \)</strong> (déterminée par le compteur atteignant sa pleine échelle, \( 2^N \) coups d'horloge).</li>
                    <li>À la fin de T0, la tension en sortie de l'intégrateur est proportionnelle à \( V_{in} \) et \( T_0 \) ( \( V_{int} = -\frac{V_{in}}{RC} T_0 \) ).</li>
                    <li>Le compteur est remis à zéro.</li>
                 </ul>
             </li>
             <li><strong>Phase 2 (Désintégration avec Vref) :</strong>
                <ul>
                    <li>Le commutateur connecte l'entrée de l'intégrateur à \( -V_{ref} \) (tension de référence de polarité inverse).</li>
                     <li>L'intégrateur commence à décharger C avec une pente constante et opposée, proportionnelle à \( V_{ref} \).</li>
                     <li>Simultanément, le compteur commence à compter à partir de 0.</li>
                     <li>On mesure le temps \( t_x \) (nombre de coups d'horloge N comptés) nécessaire pour que la sortie de l'intégrateur revienne à 0 (détecté par le comparateur).</li>
                     <li>La décharge est \( \Delta V = \frac{V_{ref}}{RC} t_x \). Comme \( \Delta V \) doit être égale à la charge \( |V_{int}| \), on a \( \frac{V_{ref}}{RC} t_x = \frac{V_{in}}{RC} T_0 \).</li>
                     <li>On obtient \( t_x = T_0 \frac{V_{in}}{V_{ref}} \). Comme \( t_x \) est mesuré par le nombre N de coups d'horloge (\( t_x = N \times T_{clk} \)) et \( T_0 \) est fixe (\( T_0 = 2^N \times T_{clk} \)), on a \( N \times T_{clk} = (2^N \times T_{clk}) \frac{V_{in}}{V_{ref}} \).</li>
                     <li>Finalement : \( N = 2^N \frac{V_{in}}{V_{ref}} \). La valeur finale N du compteur est directement proportionnelle à \( V_{in} \).</li>
                 </ul>
             </li>
         </ul>
         <p>Avantages : La précision ne dépend que de la stabilité de Vref et de l'horloge (les valeurs de R et C s'annulent). Très bonne immunité au bruit (grâce à l'intégration). Inconvénient : Temps de conversion relativement long (fixe + variable).</p>
    </div>

    <!-- Page 230: Successive Approximation (SAR) ADC Schematic -->
    <div class="slide" id="page230">
         <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion à approximations successives (SAR)</h2>
        <p>Principe du CAN SAR (Successive Approximation Register) :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_sar.png" alt="Schéma de principe d'un CAN SAR" style="max-width: 550px;">
             <p style="color: #666;">[Placeholder for SAR ADC Schematic]</p>
         </div>
        <p>Composants clés :</p>
        <ul>
             <li><strong>Comparateur :</strong> Compare la tension d'entrée Vin à la sortie d'un CNA.</li>
             <li><strong>CNA (DAC) :</strong> Convertit une valeur numérique en une tension analogique.</li>
             <li><strong>Registre à Approximations Successives (SAR) :</strong> C'est le cœur de la logique de contrôle. Il contient le résultat numérique en cours de construction.</li>
             <li><strong>Horloge :</strong> Synchronise le processus.</li>
             <li><strong>Logique de Contrôle :</strong> Gère le SAR et le déroulement de la conversion.</li>
             <li><em>(Le bloc "Registre" sur le schéma représente le SAR).</em></li>
         </ul>
        <p>Fonctionnement (recherche dichotomique) :</p>
        <ol>
            <li>Commence par tester le bit le plus significatif (MSB). Le SAR met le MSB à 1 et les autres bits à 0 (\( 100...0 \)).</li>
            <li>Le CNA convertit cette valeur en une tension analogique \( V_{CNA} \) (correspondant à la moitié de la pleine échelle).</li>
            <li>Le comparateur compare Vin à \( V_{CNA} \).</li>
            <li>Si \( V_{in} \ge V_{CNA} \), le MSB est conservé à 1. Sinon (\( V_{in} < V_{CNA} \)), le MSB est remis à 0.</li>
            <li>Le SAR passe au bit suivant (MSB-1). Il le met à 1.</li>
            <li>Le CNA convertit la nouvelle valeur du SAR.</li>
            <li>Le comparateur compare Vin à cette nouvelle \( V_{CNA} \).</li>
            <li>Si \( V_{in} \ge V_{CNA} \), le bit testé est conservé à 1. Sinon, il est remis à 0.</li>
            <li>Le processus se répète pour tous les bits, du MSB au LSB.</li>
        </ol>
        <p>Après N étapes (pour un CAN N bits), le registre SAR contient la valeur numérique N bits qui approxime le mieux Vin. Temps de conversion fixe (environ N cycles d'horloge). Très bon compromis performance/coût.</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 231: SAR ADC Operation Details -->
    <div class="slide" id="page231">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion à approximations successives</h2>
        <p>Algorithme de fonctionnement du CAN SAR (pour un convertisseur N bits) :</p>
        <ol>
            <li><strong>Détermination des valeurs de bits de N</strong> (le code numérique de sortie) les unes après les autres, en commençant par le <strong>bit de poids fort</strong> (MSB).</li>
            <li><strong>Test du MSB :</strong> On fixe (dans le registre SAR) le bit de poids fort à 1 et les autres bits à 0 (valeur test = \( 100...0 \)). On effectue une Conversion Numérique-Analogique (CNA) de cette valeur test pour obtenir une tension \( V_{test} \). On compare \( V_{in} \) à \( V_{test} \).</li>
            <li><strong>Décision pour le MSB :</strong> Si \( V_{in} \ge V_{test} \), alors le bit MSB reste à 1. Sinon (si \( V_{in} < V_{test} \)), le bit MSB est remis à 0.</li>
            <li><strong>Test du bit suivant :</strong> On garde la valeur déterminée pour le bit de poids fort et on passe au bit suivant (MSB-1). On fixe ce bit à 1 (en conservant la valeur du/des bits précédents).</li>
            <li><strong>Répétition :</strong> On répète le même traitement (Conversion NA de la nouvelle valeur du registre, comparaison à Vin, décision de garder le bit à 1 ou le mettre à 0) pour ce bit, et ainsi de suite, jusqu'au <strong>bit de poids faible (LSB)</strong>.</li>
        </ol>
        <p>Après N étapes, le registre SAR contient le code binaire N bits qui représente la meilleure approximation de \( V_{in} \).</p>
    </div>

    <!-- Page 232: SAR ADC Example -->
    <div class="slide" id="page232">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion à approximations successives</h2>
        <p><strong>Exemple :</strong> Convertisseur <strong>8 bits</strong>, Plage de référence (implicite 0V à Vref) <strong>\( V_{ref} = 10 \text{ V} \)</strong>.</p>
        <p><strong>Tension à convertir \( V_{in} = 6,92 \text{ V} \)</strong>.</p>
        <p><em>(Le pas de quantification est \( q = V_{ref} / 2^N = 10V / 256 \approx 0.039 \text{ V} \))</em></p>
        <ol>
            <li><strong>Test B7 (MSB):</strong> Essai \( 10000000_2 \). \( V_{CNA} = \frac{128}{256} \times 10\text{V} = 5\text{V} \).
                <br>Comparaison : \( 5\text{V} < 6,92\text{V} \). <strong>Donc, B7 = 1</strong>. Valeur SAR = \( 1??????? \).</li>
            <li><strong>Test B6:</strong> Essai \( 11000000_2 \). \( V_{CNA} = \frac{128+64}{256} \times 10\text{V} = 7,5\text{V} \).
                <br>Comparaison : \( 7,5\text{V} > 6,92\text{V} \). <strong>Donc, B6 = 0</strong>. Valeur SAR = \( 10?????? \).</li>
            <li><strong>Test B5:</strong> Essai \( 10100000_2 \). \( V_{CNA} = \frac{128+32}{256} \times 10\text{V} = 6,25\text{V} \).
                <br>Comparaison : \( 6,25\text{V} < 6,92\text{V} \). <strong>Donc, B5 = 1</strong>. Valeur SAR = \( 101????? \).</li>
            <li><strong>Test B4:</strong> Essai \( 10110000_2 \). \( V_{CNA} = \frac{128+32+16}{256} \times 10\text{V} = 6,875\text{V} \).
                <br><em>(Note: la diapo indique 6,675V, ce qui semble être une erreur de calcul).</em>
                <br>Comparaison (avec 6.875V) : \( 6,875\text{V} < 6,92\text{V} \). <strong>Donc, B4 = 1</strong>. Valeur SAR = \( 1011???? \).</li>
            <li><strong>Test B3:</strong> Essai \( 10111000_2 \). \( V_{CNA} = \frac{176+8}{256} \times 10\text{V} = 7,1875\text{V} \).
                <br>Comparaison : \( 7,1875\text{V} > 6,92\text{V} \). <strong>Donc, B3 = 0</strong>. Valeur SAR = \( 10110??? \).</li>
            <li><strong>Test B2:</strong> Essai \( 10110100_2 \). \( V_{CNA} = \frac{176+4}{256} \times 10\text{V} = 7,03125\text{V} \).
                <br>Comparaison : \( 7,03125\text{V} > 6,92\text{V} \). <strong>Donc, B2 = 0</strong>. Valeur SAR = \( 101100?? \).</li>
            <li><strong>Test B1:</strong> Essai \( 10110010_2 \). \( V_{CNA} = \frac{176+2}{256} \times 10\text{V} = 6,953125\text{V} \).
                <br>Comparaison : \( 6,953125\text{V} > 6,92\text{V} \). <strong>Donc, B1 = 0</strong>. Valeur SAR = \( 1011000? \).</li>
            <li><strong>Test B0 (LSB):</strong> Essai \( 10110001_2 \). \( V_{CNA} = \frac{176+1}{256} \times 10\text{V} \approx 6,91406\text{V} \).
                <br>Comparaison : \( 6,91406\text{V} < 6,92\text{V} \). <strong>Donc, B0 = 1</strong>. Valeur SAR = \( 10110001 \).</li>
        </ol>
        <p><strong>Valeur Numérique finale : \( 10110001_2 \)</strong>.</p>
    </div>

    <!-- Page 233: Flash ADC Schematic -->
    <div class="slide" id="page233">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion Flash</h2>
        <p>Le CAN Flash (ou parallèle) est le type de convertisseur le plus rapide.</p>
        <p>Schéma de principe (Exemple 3 bits) :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_flash.png" alt="Schéma de principe d'un CAN Flash 3 bits" style="max-width: 500px;">
             <p style="color: #666;">[Placeholder for Flash ADC Schematic]</p>
        </div>
        <p>Composants :</p>
        <ul>
            <li><strong>Pont diviseur de résistances :</strong> Une chaîne de résistances identiques (sauf éventuellement les extrêmes R1, R4) connectée entre une tension de référence (Vref) et la masse (ou une autre référence). Crée \( 2^N - 1 \) tensions de référence intermédiaires équidistantes.</li>
            <li><strong>Banc de \( 2^N - 1 \) comparateurs :</strong> Chaque comparateur compare la tension d'entrée analogique (Vin) à l'une des tensions de référence issues du pont diviseur.</li>
            <li><strong>Codeur (Encoder) :</strong> Typiquement un encodeur de priorité. Reçoit les sorties des \( 2^N - 1 \) comparateurs (formant un "code thermomètre") et génère le code binaire de sortie N bits correspondant au comparateur le plus élevé dont la sortie est active (ou la plage dans laquelle Vin se situe).</li>
        </ul>
        <p>Pour un CAN N bits, il faut \( 2^N - 1 \) comparateurs.</p>
    </div>

    <!-- Page 234: Flash ADC Principle -->
    <div class="slide" id="page234">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion Flash</h2>
        <ul>
            <li><strong>Flash = Parallèle :</strong> Le nom "Flash" vient du fait que la conversion est quasi instantanée (limitée seulement par le délai des comparateurs et de l'encodeur), car toutes les comparaisons sont effectuées <strong>en parallèle</strong> simultanément.</li>
            <li><strong>Principe : Comparer \( V_{in} \) à un ensemble de tensions prédéfinies</strong> (les \( 2^N - 1 \) niveaux de référence générés par le pont diviseur).</li>
            <li><strong>Utiliser un codeur pour générer le nombre binaire</strong> à partir des sorties des comparateurs.
                 <ul><li>Si \( V_{in} \) est comprise entre \( V_{ref, k} \) et \( V_{ref, k+1} \), alors les comparateurs 1 à k auront leur sortie active (par exemple, '1'), et les comparateurs k+1 à \( 2^N-1 \) auront leur sortie inactive ('0').</li><li>L'encodeur transforme ce motif (code thermomètre) en la valeur binaire \( k \).</li></ul>
            </li>
        </ul>
        <p>Avantage : Très haute vitesse de conversion. Inconvénients : Nombre exponentiel de comparateurs (coût, surface, consommation élevés), résolution généralement limitée (difficile de réaliser précisément un grand nombre de comparateurs identiques).</p>
    </div>

    <!-- Page 235: Flash ADC Example Schematic Details -->
    <div class="slide" id="page235">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion Flash : Exemple</h2>
        <p>Exemple détaillé d'un CAN Flash 3 bits (\( N=3 \), \( 2^N-1=7 \) comparateurs).</p>
        <div style="text-align: center; margin: 20px;">
            <img src="placeholder_adc_flash_example.png" alt="Schéma détaillé d'un CAN Flash 3 bits exemple" style="max-width: 500px;">
            <p style="color: #666;">[Placeholder for Flash ADC Example Schematic]</p>
        </div>
        <ul>
            <li>Tension de référence (implicite, entre 0V et Vref) générant les seuils via le pont diviseur. La diapo marque "10V" en haut, peut-être la valeur de Vref?</li>
            <li>Les résistances (1k, 3k) définissent les seuils de comparaison. Avec R=1k pour les 7 résistances intermédiaires et R_ext = 1.5k (pour avoir des pas de 1V si Vref=8V?), les seuils sont à 0.5*q, 1.5*q, ... 6.5*q où q est le quantum. Si Vref=10V et on vise 8 niveaux (3 bits), q=10/8=1.25V. Les seuils seraient 0.625V, 1.875V, ..., 8.125V.
                <br><em>Alternativement, si les résistances créent des seuils à 1V, 2V, ..., 7V comme indiqué sur les entrées des comparateurs, cela suppose une Vref de 8V et des résistances adaptées (par exemple, 8 résistances de 1k). L'indication Vref=10V et R=3k en haut est peut-être une simplification ou une erreur. Supposons les seuils 1V..7V corrects.</em></li>
            <li>Vin est comparé à chaque seuil (1V à 7V).</li>
            <li>Sorties des comparateurs : C1 à C7.</li>
            <li>Codeur (Encoder) : Convertit les 7 sorties C1-C7 en 3 bits binaires S2, S1, S0.</li>
        </ul>
    </div>

    <!-- Page 236: Flash ADC Example Truth Table -->
    <div class="slide" id="page236">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion Flash : Exemple</h2>
        <p>Table de vérité pour l'exemple du CAN Flash 3 bits (avec seuils à 1V, 2V, ..., 7V) :</p>
        <table border="1">
            <thead>
                <tr><th>\( V_{in} \) (V)</th><th style="border-left: 2px solid black;">C1 (1V)</th><th>C2 (2V)</th><th>C3 (3V)</th><th>C4 (4V)</th><th>C5 (5V)</th><th>C6 (6V)</th><th>C7 (7V)</th><th style="border-left: 2px solid black;">S2</th><th>S1</th><th>S0</th><th>Code Déc.</th></tr>
            </thead>
            <tbody>
                <!-- Note: Sortie comparateur = 1 si Vin < Vseuil, 0 si Vin >= Vseuil (selon schéma) -->
                <tr><td>< 1</td><td style="border-left: 2px solid black;">1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>0</td></tr>
                <tr><td>>1, <2</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>1</td><td>1</td></tr>
                <tr><td>>2, <3</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>0</td><td>2</td></tr>
                <tr><td>>3, <4</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">0</td><td>1</td><td>1</td><td>3</td></tr>
                <tr><td>>4, <5</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>0</td><td>4</td></tr>
                <tr><td>>5, <6</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>0</td><td>1</td><td>5</td></tr>
                <tr><td>>6, <7</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td style="border-left: 2px solid black;">1</td><td>1</td><td>0</td><td>6</td></tr>
                <tr><td>>7</td><td style="border-left: 2px solid black;">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td style="border-left: 2px solid black;">1</td><td>1</td><td>1</td><td>7</td></tr>
            </tbody>
        </table>
        <p>Le codeur (généralement un encodeur de priorité) transforme le "code thermomètre" des sorties des comparateurs (nombre de '0' en partant du bas) en code binaire de sortie \( S_2 S_1 S_0 \).</p>
    </div>
    <!-- Continuing the document... -->

    <!-- Page 237: Sigma-Delta ADC -->
    <div class="slide" id="page237">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">La conversion Sigma-Delta (\( \Sigma\Delta \))</h2>
        <p>
            Le principe du <strong>Convertisseur Sigma-Delta</strong> est plus complexe et repose sur des techniques de sur-échantillonnage et de mise en forme du bruit.
        </p>
        <p>
            Intuitivement, il peut être vu comme une évolution du concept de la double rampe, mais fonctionnant en boucle fermée et avec une <strong>commutation continue</strong> pour essayer de <strong>maintenir la charge intégrée nulle en moyenne</strong>.
        </p>
         <ul>
             <li>Le signal d'entrée est fortement sur-échantillonné (fréquence d'échantillonnage \( F_e \) beaucoup plus élevée que 2 * \( F_{signal} \)).</li>
            <li>Un modulateur \( \Sigma\Delta \) (comprenant un intégrateur et un comparateur/quantificateur simple, souvent 1 bit) génère un flux de bits série (Bitstream) à haute fréquence. La densité moyenne de '1' dans ce flux est proportionnelle au signal d'entrée.</li>
            <li>Ce modulateur a la propriété de "pousser" le bruit de quantification vers les hautes fréquences ("noise shaping").</li>
            <li>Un filtre numérique décimateur est ensuite utilisé pour :
                <ul>
                    <li>Filtrer le bruit de quantification à haute fréquence.</li>
                    <li>Réduire la fréquence d'échantillonnage (décimation) pour obtenir le mot de sortie N bits à la fréquence désirée.</li>
                 </ul>
             </li>
         </ul>
         <p>Cette technique permet d'atteindre de très hautes résolutions (par exemple 16, 20, 24 bits ou plus) au détriment d'une vitesse de conversion de sortie plus faible comparée aux architectures Flash ou SAR, mais elle est très utilisée en audio et instrumentation.</p>
         <div style="text-align: center; margin: 20px;">
             <img src="placeholder_adc_sigma_delta.png" alt="Schéma de principe simplifié d'un modulateur Sigma-Delta" style="max-width: 500px;">
             <p style="color: #666;">[Placeholder for Sigma-Delta Modulator Principle]</p>
         </div>
    </div>

    <!-- Page 238: ADC Comparison -->
    <div class="slide" id="page238">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CAN : Comparaison</h2>
        <p>Tableau comparatif simplifié des principales architectures ADC :</p>
        <table border="1">
            <thead>
                <tr><th>Type</th><th>Vitesse</th><th>Erreur (Quantification + autres)</th><th>Résolution Typique</th></tr>
            </thead>
            <tbody>
                <tr>
                    <td>Rampe Simple</td>
                    <td>Faible (ms)</td>
                    <td>Élevée (dépend rampe/horloge)</td>
                    <td>Moyenne (ex: 7 à 14 bits)</td>
                 </tr>
                <tr>
                    <td>Double Rampe</td>
                    <td>Faible (ms)</td>
                    <td>Faible (bonne précision)</td>
                    <td>Élevée (ex: 10 à 18 bits+)</td>
                 </tr>
                <tr>
                    <td>Approximations Successives (SAR)</td>
                     <td>Moyenne (µs, ex: ~10µs, mais peut être >> plus rapide)</td>
                    <td>Moyenne</td>
                    <td>Moyenne à Élevée (ex: 8 à 16 bits, voire plus)</td>
                    <!-- Note: La diapo indique "8 à 6 bits", probablement une typo pour "8 à 16 bits". -->
                 </tr>
                <tr>
                    <td>Flash</td>
                    <td>Élevée (ns, µs)</td>
                    <td>Moyenne (erreurs de comparateur)</td>
                     <td>Faible à Moyenne (ex: 4 à 10 bits, typ. <=8-10)</td>
                 </tr>
                 <tr>
                    <td>Sigma-Delta (\( \Sigma\Delta \))</td>
                    <td>Faible (débit sortie)</td>
                    <td>Faible (haute précision)</td>
                    <td>Très Élevée (ex: 16 à 24 bits+)</td>
                 </tr>
             </tbody>
         </table>
         <p><em>Note : Ce tableau date potentiellement (mention 10µs pour SAR). Les performances des différentes architectures ont beaucoup évolué. La vitesse des SAR modernes peut atteindre des Méga-échantillons/seconde (MSPS), rivalisant parfois avec des Flash de résolution moyenne. L'erreur dépend de nombreux facteurs au-delà de l'architecture de base. Les plages de résolution sont indicatives.</em></p>
    </div>

    <!-- Page 239: DAC Types -->
    <div class="slide" id="page239">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CNA : Types</h2>
        <p>Le <strong>Convertisseur Numérique Analogique (CNA / DAC)</strong> réalise l'opération inverse du CAN : il convertit un nombre binaire N bits en une grandeur analogique (tension ou courant) proportionnelle.</p>
        <p>Il existe différents types (architectures) de CNA :</p>
        <ul>
            <li>CNA à <strong>Résistances à Poids Proportionnels (Weighted Resistor)</strong> : Utilise des résistances dont les valeurs sont pondérées selon les puissances de 2.</li>
            <li>CNA à <strong>Réseau R-2R (R-2R Ladder)</strong> : Utilise un réseau répétitif de seulement deux valeurs de résistances (R et 2R), plus facile à fabriquer avec précision. C'est l'architecture la plus courante pour les CNA parallèles.</li>
            <li>Autres types : Sigma-Delta (pour l'audio haute fidélité), à modulation de largeur d'impulsion (PWM filtré), etc.</li>
        </ul>
        <p>Nous allons examiner les deux premiers types.</p>
    </div>

    <!-- Page 240: Weighted Resistor DAC -->
    <div class="slide" id="page240">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CNA : Résistances Poids Proportionnels</h2>
        <p>Principe du CNA à résistances pondérées :</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_dac_weighted_resistor.png" alt="Schéma de principe d'un CNA à résistances pondérées" style="max-width: 600px;">
             <p style="color: #666;">[Placeholder for Weighted Resistor DAC Schematic]</p>
        </div>
        <ul>
             <li>Chaque bit \( a_i \) du mot numérique d'entrée contrôle un interrupteur.</li>
             <li>Si le bit \( a_i = 1 \), l'interrupteur connecte une résistance de poids \( 2^{N-i} R \) (ou \( R/2^i \) selon la configuration) à une tension de référence \( V_{ref} \). Si \( a_i = 0 \), la résistance est connectée à la masse.
                <em>(Le schéma montre une configuration sommateur inverseur avec AOP : si \(a_i=1\), l'interrupteur connecte la résistance à \(V_{ref}\) via l'entrée sommateur).</em></li>
             <li>Les résistances sont pondérées selon la puissance de 2 correspondant au bit : R pour le MSB, 2R, 4R, 8R... \( 2^{N-1}R \) pour le LSB (dans la configuration du schéma).</li>
            <li>Un amplificateur opérationnel (AOP) monté en sommateur inverseur additionne les courants venant des résistances connectées à Vref.</li>
            <li>Le courant total est proportionnel à la valeur numérique d'entrée. La tension de sortie de l'AOP est \( V_{out} = - R_f \times I_{total} \), où \( R_f \) est la résistance de contre-réaction (non montrée explicitement sur le schéma simplifié, mais présente dans le bloc AOP). La tension de sortie est proportionnelle au nombre binaire d'entrée.</li>
        </ul>
        <p>Inconvénient majeur : Nécessite une large gamme de valeurs de résistances (\( 2^N R \)), difficiles à fabriquer avec une grande précision relative, surtout pour un grand nombre de bits (N élevé).</p>
    </div>

    <!-- Page 241: R-2R Ladder DAC -->
    <div class="slide" id="page241">
         <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CNA : Résistances R2R</h2>
        <p>Le CNA à réseau R-2R utilise uniquement deux valeurs de résistances (R et 2R), ce qui est beaucoup plus facile à réaliser avec précision en circuit intégré.</p>
        <div style="text-align: center; margin: 20px;">
             <img src="placeholder_dac_r2r.png" alt="Schéma de principe d'un CNA à réseau R-2R" style="max-width: 700px;">
             <p style="color: #666;">[Placeholder for R-2R Ladder DAC Schematic]</p>
        </div>
        <ul>
             <li>Le réseau forme un diviseur de courant ou de tension.</li>
             <li>Chaque bit \( a_i \) du mot numérique d'entrée contrôle un interrupteur qui connecte une branche du réseau soit à la masse (si \( a_i=0 \)), soit à un point de sommation (si \( a_i=1 \)).</li>
             <li>Le courant total \( i \) arrivant au point de sommation est proportionnel à la valeur numérique d'entrée.</li>
             <li>Propriété clé du réseau R-2R : L'impédance vue depuis n'importe quel nœud vers la droite ou vers la gauche (terminaison appropriée) est constante (égale à R ou 2R selon le point), ce qui permet une division précise des courants/tensions à chaque étage.</li>
             <li>Le courant \( i_1 \) injecté par la source Vref est divisé par 2 à chaque nœud. Le courant total \( i \) est la somme des courants \( i_1/2^k \) correspondant aux bits \( a'_k \) qui sont à 1. (\( i_1 = V_{ref} / R_{eq} \)).</li>
             <li>Souvent utilisé avec un AOP en sommateur inverseur pour convertir le courant de sortie \( i \) en tension.</li>
        </ul>
         <p>C'est l'architecture la plus courante pour les CNA parallèles de résolution moyenne à élevée.</p>
    </div>

    <!-- Page 242: DAC Comparison -->
    <div class="slide" id="page242">
        <div class="header-small">Cours d'électronique numérique - Conversion Analogique-Numérique - Numérique-Analogique</div>
        <h2 class="slide-title">CNA : Comparaison</h2>
        <p>Comparaison simplifiée des deux types de CNA parallèles :</p>
        <table border="1">
            <thead>
                <tr><th>Type</th><th>Vitesse</th><th>Erreur (Précision)</th><th>Résolution Atteignable</th></tr>
            </thead>
            <tbody>
                 <tr>
                    <td>Résistances Poids Pondérés</td>
                    <td>Élevée (µs)</td>
                    <td>Élevée (difficile d'avoir R précises sur large gamme)</td>
                    <td>Faible (limitée par précision des R)</td>
                 </tr>
                <tr>
                    <td>Réseau R-2R</td>
                    <td>Élevée (µs)</td>
                     <td>Faible (seulement 2 valeurs de R, bon matching)</td>
                    <td>Élevée (limitée par matching R/2R et autres effets)</td>
                 </tr>
             </tbody>
         </table>
         <ul>
            <li>Les deux types sont relativement rapides (la vitesse dépend surtout de l'AOP de sortie et des interrupteurs).</li>
            <li>L'erreur est le facteur discriminant : le réseau R-2R permet une bien meilleure précision car il ne nécessite que deux valeurs de résistances avec un bon rapport (matching) entre elles, ce qui est réalisable en technologie CI. Les résistances pondérées deviennent très imprécises pour N grand.</li>
            <li>Par conséquent, le réseau R-2R permet d'atteindre des résolutions plus élevées (plus de bits) avec une bonne linéarité.</li>
        </ul>
    </div>


    <!-- End of document -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
        /* Specific style for KaTeX formulas if needed */
       .formula {
            /* font-family: monospace; */ /* Keep KaTeX default */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
            text-align: center; /* Center formulas */
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
        /* Specific style for KaTeX formulas if needed */
       .formula {
            /* font-family: monospace; */ /* Keep KaTeX default */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
            text-align: center; /* Center formulas */
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
        /* Specific style for KaTeX formulas if needed */
       .formula {
            /* font-family: monospace; */ /* Keep KaTeX default */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
            text-align: center; /* Center formulas */
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
        /* Specific style for KaTeX formulas if needed */
       .formula {
            /* font-family: monospace; */ /* Keep KaTeX default */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
            text-align: center; /* Center formulas */
       }
    </style>

</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
        /* Specific style for KaTeX formulas if needed */
       .formula {
            font-family: monospace; /* Or keep default if KaTeX handles it */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
            text-align: center; /* Center formulas */
       }
    </style>

</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
        /* Specific style for KaTeX formulas if needed */
       .formula {
            font-family: monospace; /* Or keep default if KaTeX handles it */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: block; /* Ensure it takes its own line */
            text-align: center; /* Center formulas */
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: block; /* Changed to block for centering */
            vertical-align: middle;
            margin: 15px auto; /* Center images */
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>
    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: inline-block; /* Or block depending on context */
            vertical-align: middle;
            margin: 5px;
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: inline-block; /* Or block depending on context */
            vertical-align: middle;
            margin: 5px;
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>
    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
     <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
     <style>
         /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
         pre code.hljs {
             display: block;
             overflow-x: auto;
             padding: 1em;
             background: #f3f3f3; /* Light grey background for code blocks */
             border-radius: 4px;
         }
         /* Basic styles for image placeholders if needed */
        img[src^="placeholder_"] {
             border: 1px dashed #ccc;
             min-height: 50px;
             /* min-width: 100px; */ /* Removed to allow smaller icons */
             display: inline-block; /* Or block depending on context */
             vertical-align: middle;
             margin: 5px;
             padding: 5px;
             background-color: #f8f8f8;
        }
        table {
            border-collapse: collapse;
            margin: 15px auto;
            text-align: center;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
        }
        th {
            background-color: #e9ecef;
        }
     </style>

</body>
</html>
    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: inline-block; /* Or block depending on context */
            vertical-align: middle;
            margin: 5px;
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
        /* Basic styles for image placeholders if needed */
       img[src^="placeholder_"] {
            border: 1px dashed #ccc;
            min-height: 50px;
            /* min-width: 100px; */ /* Removed to allow smaller icons */
            display: inline-block; /* Or block depending on context */
            vertical-align: middle;
            margin: 5px;
            padding: 5px;
            background-color: #f8f8f8;
       }
       table {
           border-collapse: collapse;
           margin: 15px auto;
           text-align: center;
       }
       th, td {
           border: 1px solid #ccc;
           padding: 8px;
       }
       th {
           background-color: #e9ecef;
       }
    </style>

</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
            // Ensure highlight.js runs if not already done globally
            if (typeof hljs !== 'undefined') {
                hljs.highlightAll();
            }
        });
    </script>
     <!-- Add highlight.js for VHDL syntax highlighting if not already included -->
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
     <style>
         /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
         pre code.hljs {
             display: block;
             overflow-x: auto;
             padding: 1em;
             background: #f3f3f3; /* Light grey background for code blocks */
             border-radius: 4px;
         }
         /* Basic styles for image placeholders if needed */
        img[src^="placeholder_"] {
             border: 1px dashed #ccc;
             min-height: 50px;
             min-width: 100px;
             display: inline-block; /* Or block depending on context */
             vertical-align: middle;
             margin: 5px;
        }
     </style>

</body>
</html>

    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
        });
    </script>
    <!-- Add highlight.js for VHDL syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/vhdl.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        /* Ensure pre/code blocks handle wrapping and scrolling for long lines */
        pre code.hljs {
            display: block;
            overflow-x: auto;
            padding: 1em;
            background: #f3f3f3; /* Light grey background for code blocks */
            border-radius: 4px;
        }
    </style>
</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
        });
    </script>
</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
        });
    </script>
</body>
</html>
    <!-- End of added content -->

    <script>
        // Ensure KaTeX renders everything correctly
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ]
            });
        });
    </script>
</body>
</html>



