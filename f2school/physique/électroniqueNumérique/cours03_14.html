<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitres VI, VIII, X et Annexes: Circuits combinatoires, Bascules, Compteurs</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3, h4, h5 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }
        h1 { font-size: 2em; border-bottom: 2px solid black; padding-bottom: 5px; }
        h2 { font-size: 1.7em; border-bottom: 1px solid gray; padding-bottom: 3px;}
        h3 { font-size: 1.4em; }
        h4 { font-size: 1.2em; }
        h5 { font-size: 1.1em; font-weight: bold; }
        p, li, dd {
            margin-bottom: 0.8em;
        }
        dt {
            font-weight: bold;
        }
        .definition {
            border-left: 3px solid #add8e6; /* Light blue */
            padding-left: 15px;
            margin-left: 10px;
            background-color: #f0f8ff; /* Alice blue */
        }
        .remark {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 10px;
            margin: 10px 0;
        }
        .example {
            border: 1px dashed #aaa;
            padding: 10px;
            margin: 10px 0;
        }
        .exercise {
            border: 1px solid #ccaa00;
            background-color: #fff8dc; /* Cornsilk */
            padding: 10px;
            margin: 10px 0;
        }
         .quote {
            font-style: italic;
            margin: 15px 40px;
            padding: 10px;
            border-left: 3px solid #ccc;
            background-color: #f9f9f9;
        }
        figure {
            text-align: center;
            margin: 20px 0;
        }
        figcaption {
            font-style: italic;
            font-size: 0.9em;
            margin-top: 5px;
        }
        table {
            border-collapse: collapse;
            margin: 15px auto; /* Center table */
            width: auto;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
        .placeholder {
            border: 1px dashed #ccc;
            padding: 20px;
            text-align: center;
            background-color: #fafafa;
            min-height: 100px;
            display: inline-block;
            margin: 10px;
            min-width: 150px;
            box-sizing: border-box;
        }
        .page-footer {
            margin-top: 30px;
            border-top: 1px solid #ccc;
            padding-top: 10px;
            font-size: 0.8em;
            color: gray;
            display: flex;
            justify-content: space-between;
        }
        .katex-display { /* Ensure display math is centered */
             margin: 1em 0;
             text-align: center;
        }
        .vertical-placeholder {
            border: 1px dashed #aaa;
            width: 20px; /* Adjust width as needed */
            min-height: 150px; /* Adjust height as needed */
            display: inline-block;
            margin: 10px 5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            text-align: center;
            padding: 5px;
            background-color: #fafafa;
        }
        .annex-title-page {
            text-align: center;
            margin: 50px 0;
            border: 1px solid #eee;
            padding: 30px;
            position: relative; /* Needed for overlay */
            min-height: 300px; /* Ensure space for background */
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='); /* Placeholder transparent pixel */
        }
        .annex-title-page .background-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15; /* Make background faint */
            z-index: -1; /* Place behind text */
            border: 1px dashed #ccc;
            padding: 20px;
            text-align: center;
            background-color: #fafafa;
            display: flex;
            align-items: center;
            justify-content: center;
            font-style: italic;
            color: gray;
        }
        .index-section {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        .index-entry {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            border-bottom: 1px dotted #eee;
            padding-bottom: 2px;
        }
        .index-entry span:first-child {
            margin-right: 10px;
        }
        .index-entry span:last-child {
            text-align: right;
            font-family: monospace;
            white-space: nowrap; /* Prevent page numbers from wrapping */
        }
        .index-letter {
            font-size: 1.5em;
            font-weight: bold;
            margin-top: 1em;
            margin-bottom: 0.5em;
            border-bottom: 1px solid #ccc;
            padding-bottom: 3px;
        }
        .blank-page {
             min-height: 300px; /* Give some visual space */
             border: 1px dashed #eee;
             margin: 20px 0;
             display: flex;
             align-items: center;
             justify-content: center;
             color: #ccc;
             font-style: italic;
        }

    </style>
</head>

<body>

    <!-- Page 1 (Chapitre VI) -->
    <h1>Chapitre VI <br> Les circuits combinatoires</h1>
    <figure style="float: right; margin-left: 20px;">
         <div class="placeholder">[Placeholder: Image of Augustus De Morgan]</div>
         <figcaption>Augustus De Morgan<br> * 27 juin 1806, Madura, Indes<br> † 18 mars 1871, Londres, R.-U.</figcaption>
    </figure>
    <p><strong>Lois de De Morgan (appliquées aux ensembles) :</strong></p>
    <ul>
        <li>`\text{comp}(\bigcap_j A_j) = \bigcup_j \text{comp}(A_j)`<br> i.e., le complément de l'intersection d'un nombre quelconque d'ensembles est égal à l'union de leurs compléments.<br><em>(En algèbre booléenne, cela correspond à `\overline{(A \cdot B \cdot ...)} = \overline{A} + \overline{B} + ...`)</em></li>
        <li>`\text{comp}(\bigcup_j A_j) = \bigcap_j \text{comp}(A_j)`<br> i.e., le complément de l'union d'un nombre quelconque d'ensembles est égal à l'intersection de leurs compléments.<br><em>(En algèbre booléenne, cela correspond à `\overline{(A + B + ...)} = \overline{A} \cdot \overline{B} \cdot ...`)</em></li>
    </ul>
    <div style="clear: both;"></div>
    <h2>VI.1 Circuits logiques combinatoires usuels</h2>
    <div class="definition"><p><strong>Circuit combinatoire :</strong> circuit dont les sorties dépendent <strong>uniquement</strong> de la combinaison des états des entrées à l'instant de l'observation.</p><p>Cela signifie qu'un circuit combinatoire n'a pas de mémoire. La sortie à un instant `t` est uniquement fonction de l'entrée à ce même instant `t`.</p></div>
    <h3>VI.1.1 Circuits de transcodage (codeurs, décodeurs, convertisseurs)</h3>
    <p>Ces circuits transforment un code d'entrée en un autre code de sortie.</p>
    <h4>VI.1.1.a Codeur (encodeur)</h4>
    <div class="definition"><p>Circuit à `M` entrées et `N` sorties, où typiquement `M = 2^N`. Il code en binaire le rang (l'indice) de la <strong>seule</strong> entrée active parmi les `M` entrées.</p><p>Si plusieurs entrées sont actives simultanément, le comportement d'un codeur simple est indéfini. Les codeurs de priorité gèrent ce cas (voir Remarque 6.1).</p></div>
    <div class="page-footer"><span>Page 71</span></div>
    <hr>

    <!-- Page 2 (Chapitre VI) -->
    <h5>Schéma général d'un codeur M vers N</h5>
    <figure><div class="placeholder">[Placeholder: Diagram of a generic M-to-N encoder]</div><figcaption>Codeur générique avec M entrées (`A_0` à `A_{M-1}`) et N sorties (`S_0` à `S_{N-1}`). Une seule entrée est active à la fois. La sortie représente en binaire le numéro de l'entrée active.</figcaption></figure>
    <div class="example"><h5>▷ Exemple 6.1 : Codeur décimal-DCB</h5><p>Un exemple courant est le codeur décimal vers BCD (Binary Coded Decimal). Il a 10 entrées (correspondant aux chiffres 0 à 9) et 4 sorties (pour représenter le chiffre en binaire sur 4 bits).</p><figure><div class="placeholder">[Placeholder: Diagram of a 10-input to 4-output Decimal-to-BCD encoder]</div><figcaption>Codeur 10 entrées (0-9) vers 4 sorties (`S_0` à `S_3`). Si l'entrée '3' est active (et les autres inactives), la sortie sera `S_3S_2S_1S_0 = 0011`.</figcaption></figure></div>
    <div class="page-footer"><span>Page 72</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 3 (Chapitre VI) -->
    <h5>Table de vérité (exemple: Codeur prioritaire 10 vers 4, Actif Bas)</h5>
    <p>Le tableau suivant illustre le fonctionnement d'un <strong>codeur de priorité</strong> décimal vers BCD où les entrées sont actives à l'état bas ('0') et l'entrée de plus fort poids (ici 9) a la priorité la plus élevée. 'X' signifie "état indifférent" (peut être 0 ou 1).</p>
    <table><caption>Table de vérité simplifiée d'un codeur prioritaire 10->4 (Actif Bas)</caption><thead><tr><th>A9</th><th>A8</th><th>A7</th><th>A6</th><th>A5</th><th>A4</th><th>A3</th><th>A2</th><th>A1</th><th>A0</th><th>|</th><th>S3</th><th>S2</th><th>S1</th><th>S0</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>|</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X</td><td>|</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td><td>|</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>|</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>|</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>|</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>|</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>|</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>|</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>X</td><td>|</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table>
    <p><em>Note: La table fournie dans l'OCR original utilise des '1' là où l'on s'attendrait à des 'X' (Don't Care) pour un codeur prioritaire standard actif bas. L'interprétation la plus probable est que '0' représente l'entrée active et '1' l'entrée inactive. Si plusieurs entrées sont à '0', celle avec l'indice le plus élevé détermine la sortie.</em></p>
    <h5>Application : codeur de clavier numérique</h5>
    <figure><div class="placeholder">[Placeholder: Diagram of a numeric keypad encoder application]</div><figcaption>Un codeur (souvent prioritaire) est utilisé pour convertir l'appui sur une touche d'un clavier numérique en son code BCD correspondant.</figcaption></figure>
    <div class="remark"><p><strong>► Remarque 6.1 : Codeurs de priorité</strong></p><p>Les codeurs de priorités sont une version modifiée du codeur : quand deux entrées (ou plus) sont actives simultanément, c'est l'entrée correspondant au nombre (ou à l'indice) le plus haut qui est choisie et codée en sortie. Les autres entrées actives de rang inférieur sont ignorées.</p></div>
    <h4>VI.1.1.b Décodeur</h4>
    <div class="definition"><p>Le décodeur est un circuit qui établit la correspondance entre un code d'entrée sur `N` bits et `M` lignes de sortie, où `M \le 2^N`.</p><p>Pour chacune des `2^N` combinaisons possibles des entrées, <strong>une seule</strong> ligne de sortie est validée (activée, souvent à l'état bas).</p></div>
    <div class="example"><h5>▷ Exemple 6.2 : Décodeur DCB-décimal</h5><p>Ce circuit a 4 entrées (recevant un code BCD) et 10 sorties (numérotées de 0 à 9). Si l'entrée est `0101` (BCD pour 5), seule la sortie numéro 5 sera activée. Si l'entrée est une combinaison invalide en BCD (ex: `1100`), aucune sortie (ou parfois une sortie d'erreur dédiée) n'est activée.</p></div>
    <div class="remark"><p><strong>► Remarque 6.2 : Entrées de validation (Enable)</strong></p><p>La plupart des décodeurs sont dotés d'une ou plusieurs entrées de validation (souvent appelées 'Enable' ou 'Strobe'). Ces entrées permettent d'activer ou de désactiver le circuit : si l'entrée de validation n'est pas active, toutes les sorties sont inactives (souvent à l'état haut ou haute impédance), quelle que soit la combinaison des entrées de code. Elles sont utiles pour la mise en cascade ou la synchronisation.</p></div>
    <div class="page-footer"><span>Page 73</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 4 (Chapitre VI) -->
    <h5>Applications des décodeurs</h5><h6>1: Adressage d'une mémoire</h6><p>Les mémoires (RAM, ROM) sont organisées comme des tableaux de cellules. Pour lire ou écrire une information, il faut sélectionner une ligne spécifique (appelée "mot mémoire"). Un décodeur est utilisé pour transformer l'adresse binaire fournie par le processeur en une seule ligne de sélection active correspondant à cette adresse.</p><figure><div class="placeholder">[Placeholder: Diagram of memory addressing using a decoder]</div><figcaption>Adressage mémoire : Un décodeur `N` vers `2^N` (ici 10 vers 1024) prend l'adresse (sur 10 bits) et active une seule des 1024 lignes (lignes 0 à 1023). Une entrée 'autorisation accès mémoire' (Enable) permet d'activer le décodeur. Les données sont ensuite lues ou écrites sur les lignes de données (ici 8 bits).</figcaption></figure><ul><li>Une mémoire est un tableau d'éléments binaires (divisés en lignes et colonnes).</li><li>Pour lire un mot mémoire, il faut lui envoyer le numéro de ligne souhaité (adresse).</li><li>Souvent, le décodeur d'adresse est intégré dans le circuit mémoire lui-même.</li></ul><h6>2: Génération de fonction logique</h6><p>Toute fonction logique combinatoire peut être réalisée à partir d'un décodeur et de portes OU (ou NON-OU). Le décodeur génère tous les mintermes possibles des variables d'entrée. Il suffit ensuite de combiner (avec une porte OU) les sorties du décodeur correspondant aux mintermes pour lesquels la fonction doit être égale à 1.</p><div class="example"><h5>▷ Exemple 6.3 : Génération de fonction</h5><p>Soit la fonction `F(A,B,C) = A\overline{B}C + AB\overline{C} + A\overline{B} + C`.</p><p><em>(Note: L'expression originale `F=ABC+ABC+AB+C` manque probablement des barres de négation. Supposons `F = A\overline{B}C + AB\overline{C} + A\overline{B} + C`. Simplifiée, cette fonction est `F = A\overline{B} + C`. Si l'on voulait l'implémenter directement avec un décodeur 3 vers 8 et une porte OU, on identifierait les mintermes : `A\overline{B}C` (m5), `AB\overline{C}` (m6), `A\overline{B}` (m4, m5), `C` (m1, m3, m5, m7). La forme somme de mintermes serait `F = m1 + m3 + m4 + m5 + m6 + m7`. On relierait les sorties 1, 3, 4, 5, 6, 7 du décodeur à une porte OU.)</em></p></div><div class="remark"><p><strong>► Remarque 6.3</strong></p><p>Lorsqu'on utilise un décodeur pour générer une fonction, il n'est pas nécessaire de simplifier algébriquement la fonction (en forme minimale somme-de-produits) avant la réalisation. Il suffit de connaître sa table de vérité ou sa forme canonique (somme des mintermes).</p></div><h5>Mise en cascade des décodeurs</h5><p>Pour réaliser un décodeur avec un grand nombre de sorties, on peut cascader des décodeurs plus petits en utilisant leurs entrées de validation (Enable).</p><div class="example"><h5>▷ Exemple 6.4 : Décodeur 3 vers 8 avec des décodeurs 2 vers 4</h5><p>On veut réaliser un décodeur à 3 entrées (disons `A_2, A_1, A_0`) et 8 sorties (`S_0` à `S_7`) en utilisant deux décodeurs 2 vers 4.</p><figure><div class="placeholder">[Placeholder: Diagram of cascaded decoders: 3-to-8 using two 2-to-4]</div><figcaption>Réalisation d'un décodeur 3 vers 8. L'entrée `A_2` (bit de poids fort) est utilisée pour valider l'un des deux décodeurs 2 vers 4. Si `A_2=0`, le premier décodeur (sorties `S_0`-`S_3`) est actif et décode `A_1A_0`. Si `A_2=1`, le second décodeur (sorties `S_4`-`S_7`) est actif et décode `A_1A_0`. L'entrée `q_i` semble représenter les entrées `A_i`. `V` est l'entrée Enable.</figcaption></figure><p><strong>Exercice :</strong> Réaliser un décodeur 4 vers 16 à l'aide de décodeurs 2 vers 4 (ou de décodeurs 3 vers 8).</p></div>
    <div class="page-footer"><span>Page 74</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 5 (Chapitre VI) -->
    <h4>VI.1.1.c Transcodeurs (convertisseurs)</h4><div class="definition"><p>Circuit à `p` entrées et `k` sorties qui convertit un nombre ou une information représenté(e) dans un code C1 (en entrée) en une représentation équivalente dans un code C2 (en sortie).</p></div><div class="example"><h5>▷ Exemple 6.5 : Exemples de transcodeurs</h5><ul><li><strong>Code binaire → code Gray :</strong> Convertit un nombre binaire naturel en son équivalent en code Gray (où deux valeurs successives ne diffèrent que par un seul bit). Utile pour éviter les états transitoires erronés dans les compteurs ou les capteurs de position.</li><li><strong>Code DCB → code affichage 7 segments :</strong> Convertit un chiffre BCD (4 bits) en signaux de commande (7 bits) pour allumer les segments appropriés d'un afficheur numérique. C'est un type de décodeur, mais la sortie n'active pas une seule ligne mais une combinaison de lignes.</li></ul></div><h3>VI.1.2 Multiplexeurs-démultiplexeurs</h3><h4>VI.1.2.a Multiplexeurs (MUX)</h4><div class="definition"><p>Circuit à `2^n` entrées de données (ou d'informations), `n` entrées de sélection (ou d'adresse), et une seule sortie. Il permet l'aiguillage (la sélection) de l'une des `2^n` entrées de données vers la sortie unique, en fonction de la valeur binaire appliquée aux entrées de sélection.</p><p>Le multiplexeur agit comme un commutateur rotatif électronique.</p></div><div class="example"><h5>▷ Exemple 6.6 : MUX 2 vers 1</h5><p>Un multiplexeur simple avec 2 entrées de données (`E_0`, `E_1`), 1 entrée de sélection (`sel`), et 1 sortie (`S`).</p><figure><div class="placeholder">[Placeholder: Diagram of a 2-to-1 MUX]</div><figcaption>Multiplexeur 2 vers 1.</figcaption></figure><table><caption>Table de vérité MUX 2 vers 1</caption><thead><tr><th>sel</th><th>S (Sortie)</th></tr></thead><tbody><tr><td>0</td><td>`E_0`</td></tr><tr><td>1</td><td>`E_1`</td></tr></tbody></table><p>Équation logique : `S = \overline{\text{sel}} \cdot E_0 + \text{sel} \cdot E_1`</p></div><div class="remark"><p><strong>► Remarque 6.4</strong></p><p>La table de vérité d'un multiplexeur devient rapidement très grande à mesure que le nombre d'entrées de sélection augmente (par exemple, un MUX 16 vers 1 a 4 entrées de sélection, soit 16 lignes dans sa table de vérité de sélection, plus les `2^{16}` combinaisons possibles des entrées de données si on voulait tout lister!). On exprime alors directement la fonction de sortie en fonction des entrées de sélection et des entrées de données.</p></div><div class="example"><h5>▷ Exemple 6.7 : MUX 4 vers 1</h5><p>Un multiplexeur 4 vers 1 a 4 entrées de données (`E_0, E_1, E_2, E_3`), 2 entrées de sélection (`a_1, a_0`), et 1 sortie (`S`).</p><p>Équation logique : `S = \overline{a_1}\overline{a_0}E_0 + \overline{a_1}a_0E_1 + a_1\overline{a_0}E_2 + a_1a_0E_3`</p></div><h4>VI.1.2.b Application des MUX</h4><ol><li><p><strong>Conversion parallèle-série :</strong> Les données présentes en parallèle sur les entrées du MUX (`E_0` à `E_{2^n-1}`) peuvent être transmises en série sur la sortie unique en faisant varier séquentiellement les entrées de sélection (`a_{n-1}...a_0`). Par exemple, pour un MUX 4 vers 1, on applique successivement `00, 01, 10, 11` sur `a_1a_0` pour transmettre `E_0`, puis `E_1`, puis `E_2`, puis `E_3` sur la sortie `S`.</p></li></ol>
    <div class="page-footer"><span>Page 75</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 6 (Chapitre VI) -->
    <figure><div class="placeholder">[Placeholder: Diagram illustrating Parallel-to-Serial conversion using a MUX]</div><figcaption>Illustration de la conversion parallèle-série : Les bits `1101` sont présents sur les entrées `E_3` à `E_0`. Un compteur génère la séquence `00, 01, 10, 11` sur les entrées de sélection `a_1a_0`. La sortie `S` produit la séquence `1011` (correspondant à `E_0, E_1, E_2, E_3`).</figcaption></figure><ol start="2"><li><p><strong>Générateur de fonctions logiques :</strong> Toute fonction logique de `n` variables peut être réalisée avec un multiplexeur `2^n` vers 1. Les variables de la fonction sont connectées aux entrées de sélection (`a_{n-1}...a_0`). Chaque entrée de données (`E_i`) est connectée à '0' (niveau bas) ou '1' (niveau haut) selon la valeur de la fonction pour la combinaison correspondante des variables de sélection. C'est une alternative à l'utilisation de décodeurs et portes OU.</p><p><em>Variante (Méthode de Shannon) :</em> On peut utiliser un MUX `2^{n-1}` vers 1 pour implémenter une fonction de `n` variables. `n-1` variables sont connectées aux sélections. La `n`-ième variable (ou son complément, ou '0', ou '1') est connectée aux entrées de données `E_i` selon la décomposition de Shannon.</p></li><li><p><strong>Sélection de mots (bus) :</strong> Pour sélectionner un mot de `k` bits parmi plusieurs sources (par exemple, choisir entre les données venant du clavier ou d'un lecteur de disquettes), on utilise `k` multiplexeurs `m` vers 1 en parallèle. Ils partagent les mêmes entrées de sélection, permettant de commuter l'ensemble des `k` bits d'un mot source vers une destination commune (bus).</p><figure><div class="placeholder">[Placeholder: Diagram showing word selection using parallel MUXes]</div><figcaption>Sélection de mots : `k` MUX (ici représentés comme un seul bloc "MUX aiguillage") sélectionnent un bus de `n` bits parmi plusieurs sources (Source 1, Source 2, ...) en fonction de la commande de sélection, et le dirigent vers la destination.</figcaption></figure></li></ol><div class="remark"><p><strong>► Remarque 6.5</strong></p><p>Intérêt de l'utilisation des MUX pour la génération de fonctions : il n'est pas nécessaire de simplifier algébriquement la fonction avant de la réaliser. Il suffit de connaître sa table de vérité.</p></div><div class="example"><h5>▷ Exemple 6.8 : Implémentation de fonction avec MUX</h5><p>Soit la fonction `F(A,B,C) = \overline{A}BC + A\overline{B}C` (m3 + m5). (L'original `F ABC ABC` est ambigu).</p><p>Pour réaliser cette fonction avec un MUX 8 vers 1 :</p><ul><li>Connecter A, B, C aux entrées de sélection `a_2, a_1, a_0`.</li><li>Connecter les entrées de données `E_3` et `E_5` à '1' (Vcc).</li><li>Connecter toutes les autres entrées de données (`E_0, E_1, E_2, E_4, E_6, E_7`) à '0' (GND).</li><li>La sortie `S` du MUX réalisera la fonction F.</li></ul><p>L'expression `S = \overline{A}\overline{B}\overline{C}E_0 + \overline{A}\overline{B}C E_1 + \overline{A}B\overline{C} E_2 + \overline{A}BC E_3 + A\overline{B}\overline{C} E_4 + A\overline{B}C E_5 + AB\overline{C} E_6 + ABC E_7` représente l'équation générale d'un MUX 8 vers 1, où `A, B, C` sont les sélecteurs.</p></div>
    <div class="page-footer"><span>Page 76</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 7 (Chapitre VI) -->
    <h4>VI.1.2.c Démultiplexeurs (DEMUX)</h4><div class="definition"><p>Circuit avec 1 entrée d'information (Donnée), `n` entrées de commande (Sélection), et `2^n` sorties. Il permet d'aiguiller l'information présente sur l'entrée unique vers l'une des `2^n` sorties, choisie par les entrées de commande.</p><p>Le démultiplexeur agit comme un aiguillage qui dirige un signal entrant vers une voie de sortie parmi plusieurs.</p></div><div class="remark"><p><strong>► Remarque 6.6</strong></p><p>Le MUX et le DEMUX peuvent être vus comme des circuits programmables simples, car la relation entre une entrée de données spécifique et la sortie (pour le MUX) ou entre l'entrée et une sortie spécifique (pour le DEMUX) peut être modifiée en changeant les entrées de sélection. Cette notion de "programmabilité" est plus développée dans les circuits logiques programmables complexes (voir VI.2.2).</p></div><div class="example"><h5>▷ Exemple 6.9 : Transmission avec multiplexage/démultiplexage</h5><p>Pour transmettre plusieurs signaux (sources 0 à n) sur une seule voie de transmission, on utilise un MUX à l'émission pour sélectionner séquentiellement chaque source et l'envoyer sur la voie. À la réception, un DEMUX synchronisé avec le MUX reçoit le signal série et le distribue vers la destination appropriée (récepteur 0 à n).</p><figure><div class="placeholder">[Placeholder: Diagram of a MUX/DEMUX transmission system]</div><figcaption>Système de transmission multiplexé : Plusieurs sources sont combinées par un MUX, transmises sur une voie unique, puis séparées par un DEMUX vers les récepteurs correspondants.</figcaption></figure></div><h3>VI.1.3 Le comparateur</h3><div class="definition"><p>Il détecte la relation d'ordre entre deux nombres binaires A et B. Le circuit le plus simple détecte l'égalité (A = B). Certains circuits (comparateurs de magnitude) permettent également de détecter si A est supérieur à B (A > B) ou inférieur à B (A < B).</p></div><h4>VI.1.3.a Comparateur de 2 bits élémentaires</h4><p>Comparaison bit à bit de `a_i` et `b_i` (bits de même poids de A et B).</p><table><caption>Comparaison de 2 bits (`a_j`, `b_i`)</caption><thead><tr><th>`a_j`</th><th>`b_i`</th><th>|</th><th>`E_i` (Égalité)</th><th>`S_i` (`a_j > b_i`)</th><th>`I_i` (`a_j < b_i`)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>|</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>|</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>|</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>|</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>Équations logiques correspondantes :</p><ul><li>Égalité (`E_i`): `E_i = \overline{a_i \oplus b_i}` (XNOR) ou `E_i = \overline{a_i}\overline{b_i} + a_i b_i`</li><li>Supérieur (`S_i`): `S_i = a_i \overline{b_i}` (Note: dans le texte `a_j b_i` pourrait être une typo pour `a_i \overline{b_i}`)</li><li>Inférieur (`I_i`): `I_i = \overline{a_i} b_i` (Note: dans le texte `a_i b_i` pourrait être une typo pour `\overline{a_i} b_i`)</li><li>Différence (`D_i`): `D_i = a_i \oplus b_i` (XOR)</li></ul><h4>VI.1.3.b Comparateur de 2 nombres (multi-bits)</h4><p>Pour comparer deux nombres A et B de plusieurs bits, on compare les bits de poids fort d'abord. Si A=B, on compare les bits suivants, et ainsi de suite. La première différence rencontrée détermine la relation (A>B ou A<B). Si tous les bits sont égaux, alors A=B.</p><p>Les circuits intégrés réalisent souvent cette logique en cascade : chaque étage compare une paire de bits (`a_i, b_i`) et utilise les résultats de l'étage précédent (comparaison des bits de poids supérieurs) pour déterminer ses propres sorties (égalité locale `E_i`, supériorité `S_i`, infériorité `I_i`) et propager l'information vers l'étage suivant (comparaison des bits de poids inférieurs).</p><figure><div class="placeholder">[Placeholder: Diagram of a multi-bit comparator]</div><figcaption>Structure typique d'un comparateur multi-bits (ici 4 bits, a3b3 à a0b0). Chaque étage (Ei, Si, Ii) compare une paire de bits et reçoit des informations de l'étage de poids supérieur. Les sorties finales indiquent A<B, A=B, ou A>B.</figcaption></figure>
    <div class="page-footer"><span>Page 77</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 8 (Chapitre VI) -->
    <h3>VI.1.4 L'unité arithmétique et logique (UAL / ALU)</h3><div class="definition"><p>Utilisée dans pratiquement tous les systèmes informatiques (au cœur du processeur), l'Unité Arithmétique et Logique (UAL, ou ALU en anglais) réalise des opérations arithmétiques (addition, soustraction, incrémentation, etc.) et logiques (ET, OU, NON, XOR, etc.) sur des opérandes binaires.</p><p>C'est un circuit <strong>programmable</strong> : des entrées de commande (sélection d'opération) déterminent quelle opération est effectuée sur les données d'entrée (opérandes). Les relations entre les données en sortie et les données en entrée sont donc modifiables par ces commandes.</p></div><figure><div class="placeholder">[Placeholder: Generic block diagram of an ALU]</div><figcaption>Schéma fonctionnel simplifié d'une ALU : Prend deux opérandes A et B (ici 4 bits), une retenue entrante (`C_0` ou `C_{in}`), des signaux de sélection d'opération (`S_0` à `S_3`, `M`), et produit un résultat F (4 bits), une retenue sortante (`C_4` ou `C_{out}`), et éventuellement des signaux pour la retenue anticipée (P: Propagate, G: Generate).</figcaption></figure><figure><div class="placeholder">[Placeholder: Pinout diagram of the 74181 ALU chip]</div><figcaption><strong>74181 : Unité logique arithmétique 4 bits (générateur de fonction).</strong><br> Exemple de circuit intégré ALU classique. Le brochage montre les entrées pour les opérandes (A0-A3, B0-B3), la sélection d'opération (S0-S3, M), la retenue entrante (Cn), les sorties de résultat (F0-F3), la sortie de retenue (Cn+4), les sorties pour la retenue anticipée (P, G), et une sortie de comparaison (A=B). VCC et GND sont les alimentations.</figcaption></figure><p><strong>Mise en cascade et retenue anticipée :</strong></p><p>Pour effectuer des opérations sur des nombres plus grands (ex: 16 bits), on peut cascader plusieurs ALU 4 bits. La retenue de chaque bloc doit être propagée au bloc suivant. Pour accélérer ce processus (surtout pour l'addition), on utilise un mécanisme de <strong>retenue anticipée</strong> (Lookahead Carry). Les sorties P (Propagate) et G (Generate) de chaque ALU sont utilisées par un circuit externe (Générateur de retenue anticipée) pour calculer rapidement les retenues entrantes de chaque bloc sans attendre la propagation séquentielle.</p><ul><li>`G_i = 1` (Generate) si l'étage `i` génère une retenue indépendamment de la retenue entrante.</li><li>`P_i = 1` (Propagate) si l'étage `i` propage une retenue entrante vers sa sortie.</li></ul><figure><div class="placeholder">[Placeholder: Diagram of cascaded ALUs with a Lookahead Carry Generator]</div><figcaption>Mise en cascade d'ALUs (ici 4 x 4 bits = 16 bits) avec un Générateur de retenue anticipée. Les signaux P et G de chaque ALU alimentent le générateur, qui calcule directement les retenues `C_4`, `C_8`, `C_{12}` pour accélérer l'opération globale.</figcaption></figure>
    <div class="page-footer"><span>Page 78</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 9 (Chapitre VI) -->
    <h2>VI.2 Synthèse des circuits combinatoires</h2><p>La synthèse est le processus de conception et de réalisation d'un circuit logique pour implémenter une fonction ou un comportement spécifié.</p><h3>VI.2.1 Présentation du processus de conception</h3><p>Le processus typique de conception d'un circuit combinatoire suit plusieurs étapes :</p><div class="flowchart"><div class="flowchart-step">1. Cahier des charges</div><div class="flowchart-arrow">↓</div><div class="flowchart-step">2. Analyse du problème<br>(Définition des entrées/sorties, table de vérité, équations logiques)</div><div class="flowchart-arrow">↓</div><div class="flowchart-step">3. Choix d'une technologie et des composants</div><div class="flowchart-arrow">↓</div><div class="flowchart-step">4. Établissement du schéma logique détaillé</div><div class="flowchart-arrow">↓</div><div class="flowchart-step">5. Prototype d'essai (Simulation et/ou Réalisation physique)</div><div class="flowchart-arrow">↓</div><div class="flowchart-step">6. Réalisation finale</div></div><p><strong>Stratégies de réalisation :</strong></p><ul><li>Si le nombre de variables mises en œuvre est faible (typiquement inférieur à 10), les circuits sont réalisés directement à l'aide de la table de vérité ou des équations logiques (éventuellement après simplification) en utilisant des portes logiques de base.</li><li>Dans le cas contraire (fonctions complexes), la fonction est décomposée en différents blocs fonctionnels plus simples qui sont analysés et réalisés séparément, puis interconnectés.</li></ul><p><strong>Choix des composants :</strong></p><p>Le choix des composants utilisés est basé sur différents critères :</p><ul><li>Nombre de boîtiers (minimiser la taille et le coût)</li><li>Coût des composants</li><li>Disponibilité des composants</li><li>Possibilité d'ajouter des points de test</li><li>Complexité des connexions (routage sur le circuit imprimé)</li><li>Performances (vitesse)</li><li>Consommation d'énergie</li></ul><p><strong>Les différents choix technologiques sont :</strong></p><dl><dt>a) Utilisation de portes logiques simples</dt><dd>Utilisation de circuits intégrés contenant des portes logiques de base (OU, ET, NON, NON-OU, NON-ET, XOR). Adapté aux fonctions simples.</dd><dt>b) Développement de circuits intégrés (CI) spécialisés (ASIC)</dt><dd>Conception d'un circuit intégré sur mesure pour une application spécifiques. Coût de développement élevé, nécessite une production en très grandes séries pour être rentable.</dd><dt>c) Utilisation de circuits intégrés combinatoires standards et/ou programmables</dt><dd>Utilisation de composants logiques plus complexes et pré-conçus :<ul><li>Multiplexeurs (MUX), Démultiplexeurs (DEMUX)</li><li>Décodeurs, Codeurs</li><li>Comparateurs, Additionneurs, ALU</li><li>Circuits logiques programmables : PROM, PAL, PLA, FPGA, CPLD (voir section suivante). Offrent une grande flexibilité.</li></ul></dd></dl>
    <div class="page-footer"><span>Page 79</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 10 (Chapitre VI) -->
    <h3>VI.2.2 Circuits logiques programmables</h3><h4>VI.2.2.a Introduction</h4><p>La réalisation pratique d'un système logique dit « câblé » consiste à utiliser les composants logiques (circuits intégrés - CI) disponibles sur le marché et à les interconnecter de manière fixe. Cela oblige le concepteur à décomposer un système donné en blocs fonctionnels correspondant aux CI disponibles et à optimiser son choix parmi ces composants.</p><p>L'apparition des circuits adaptables dits « programmables » par le constructeur ou l'utilisateur apporte une solution flexible à ce problème. Ces circuits contiennent une structure logique générique qui peut être configurée (programmée) pour réaliser une fonction spécifique, remplaçant ainsi de nombreux circuits logiques standards.</p><h4>VI.2.2.b Structure des circuits logiques programmables</h4><p>Le principe de base repose sur le fait que toute fonction logique de `n` variables peut se mettre sous la forme d'une <strong>somme de produits</strong> (forme canonique disjonctive ou forme simplifiée). Cela implique que toute fonction logique peut être réalisée par l'utilisation d'une structure comportant deux ensembles fonctionnels :</p><ul><li>Un ensemble d'opérateurs <strong>ET</strong> (AND) organisés sous forme de matrice. Cet ensemble permet de générer les termes produits (mintermes ou produits simplifiés) des variables d'entrée (et/ou de leurs compléments).</li><li>Un ensemble d'opérateurs <strong>OU</strong> (OR) qui permet de sommer les termes produits sélectionnés pour former les fonctions de sortie souhaitées.</li></ul><p>La <strong>programmation</strong> de ces circuits consiste à configurer les connexions au sein de ces matrices. Historiquement, cela se faisait en "grillant" des fusibles placés à chaque point d'intersection potentiel entre les lignes d'entrée/produit et les lignes produit/somme. Griller un fusible supprime le contact entre les lignes. Aujourd'hui, des technologies reprogrammables (EPROM, EEPROM, Flash, SRAM) sont couramment utilisées.</p><p>Il existe plusieurs types de circuits logiques programmables (PLD - Programmable Logic Devices), différant par la partie programmable :</p><h5>1. PROM (Programmable Read-Only Memory) ou PLE (Programmable Logic Element)</h5><p>Dans une PROM utilisée comme circuit logique :</p><ul><li>La matrice <strong>ET</strong> est <strong>fixe</strong> (non programmable). Elle est conçue en usine pour générer <strong>tous</strong> les `2^n` mintermes possibles des `n` entrées. Cette matrice ET est fonctionnellement équivalente à un décodeur `n` vers `2^n`.</li><li>La matrice <strong>OU</strong> est <strong>programmable</strong>. L'utilisateur peut choisir quels mintermes (générés par la matrice ET fixe) sont connectés aux entrées des portes OU pour former chaque fonction de sortie.</li></ul><p>Contrairement aux FPLA (Field Programmable Logic Array) ou PAL (Programmable Array Logic) où la matrice ET est également programmable (cf. page 82 du document original - non fournie ici), la PROM a une structure ET figée.</p><p><strong>Caractéristiques :</strong></p><ul><li>Chaque sortie de la mémoire correspond à une fonction logique. Les sorties sont souvent de type "3 états" (0, 1, haute impédance) pour permettre le partage de bus.</li><li>La matrice ET fixe correspond à un décodeur `n \to 2^n` (décodeur d'adresse).</li><li>Une fonction est réalisée en programmant sa <strong>table de vérité</strong> dans la matrice OU. Pour chaque combinaison des entrées (adresse), on programme la valeur de sortie souhaitée ('0' ou '1') en connectant ou non la ligne du minterme correspondant à la porte OU de sortie.</li></ul><p><strong>Légende des interconnexions (typique pour schémas PLD) :</strong></p><ul><li>`*` ou X : Interconnexion non programmée (connexion par défaut, fusible intact).</li><li>`.` ou absence de X : Interconnexion programmée (connexion supprimée, fusible grillé).</li></ul><figure><div class="placeholder">[Placeholder: Symbols for programmed/unprogrammed fuses/connections]</div><figcaption>Symboles typiques pour représenter une connexion programmable : une croix (X) ou un astérisque (*) indique une connexion intacte (non programmée), tandis qu'un point (.) ou l'absence de symbole à une intersection indique une connexion supprimée (programmée).</figcaption></figure>
    <div class="page-footer"><span>Page 80</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 1 (Chapitre VIII) -->
    <h1>Chapitre VIII <br> Les bascules</h1>
    <figure style="float: right; margin-left: 20px;"><div class="placeholder">[Placeholder: Image of Alan Mathison Turing]</div><figcaption>Alan Mathison Turing<br> * 23 juin 1912, Londres, R.-U.<br> † 7 juin 1954, Wilmslow, R.-U.</figcaption></figure>
    <div class="quote"><p>« [A universal machine] ... which can be made to do the work of any special-purpose machine, that is to say to carry out any piece of computing, if a tape bearing suitable "instructions" is inserted into it. »</p><p style="text-align: right;">(Alan M. Turing, 1936, à propos de la « machine de Turing »)</p></div><div style="clear: both;"></div>
    <h2>VIII.1 Introduction</h2><div class="definition"><p><strong>Circuit séquentiel :</strong> circuit dont l'état des sorties dépend non seulement des entrées <strong>mais également de l'état antérieur des sorties</strong> (ou plus généralement, de l'état interne du circuit). Ces circuits doivent donc être capables de <strong>mémoriser</strong> une information sur leur état passé.</p><p>Contrairement aux circuits combinatoires dont la sortie est une fonction unique des entrées actuelles, les circuits séquentiels possèdent une "mémoire" qui influence leur comportement.</p></div><div class="example"><h5>▷ Exemple 8.1 : Illustration de la dépendance à l'état antérieur</h5><p>Considérons un système hypothétique avec des entrées M (Mode) et A (Action) et une sortie L (Lampe).</p><div class="state-example"> 1. `\{ M=0, A=0 \} \rightarrow L=0` </div><div class="state-example"> 2. `\{ M=1, A=0 \} \rightarrow L=1` </div><div class="state-example"> 3. `\{ M=0, A=0 \} \rightarrow L=1` (différent de l'état 1 !) </div><div class="state-example"> 4. `\{ M=0, A=1 \} \rightarrow L=0` </div><div class="state-example"> 5. `\{ M=0, A=0 \} \rightarrow L=0` (identique à l'état 1, différent de 3) </div><p>Dans ce système, pour une même combinaison des variables d'entrée `(M=0, A=0)`, la sortie `L` peut être différente (`L=0` en 1 et 5, `L=1` en 3). Cela montre que la sortie ne dépend pas uniquement des entrées actuelles mais aussi de l'historique des opérations précédentes (la séquence). La fonctionnalité dépend de l'ordre de déroulement de la séquence. C'est la caractéristique d'un <strong>système séquentiel</strong>.</p></div><p>Les fonctions séquentielles de base sont :</p><ul><li><strong>Mémorisation :</strong> Conserver une valeur binaire (0 ou 1).</li><li><strong>Comptage :</strong> Suivre une séquence prédéfinie d'états, typiquement pour compter des événements.</li><li><strong>Décalage :</strong> Déplacer des informations binaires d'une position à une autre.</li></ul><p>Les circuits séquentiels fondamentaux utilisés pour réaliser ces fonctions sont :</p>
    <div class="page-footer"><span>Page 91</span></div>
    <hr>

    <!-- Page 2 (Chapitre VIII) -->
    <ul><li><strong>Bascules (Flip-flops) :</strong> Les éléments de mémoire les plus élémentaires (3 types principaux: RS, D, JK, T).</li><li><strong>Compteurs (Counters) :</strong> Circuits conçus pour le comptage.</li><li><strong>Registres (Registers) :</strong> Circuits pour stocker et/ou décaler des groupes de bits (mots binaires).</li><li><strong>Mémoires RAM (Random Access Memory) :</strong> Ensembles organisés de cellules mémoire pour stocker de grandes quantités de données.</li></ul><p>Ces circuits peuvent travailler soit en mode synchrone, soit en mode asynchrone :</p><ul><li><strong>Mode asynchrone :</strong> À tout moment, un changement sur les signaux d'entrée peut provoquer un changement d'état des sorties (après un certain délai de propagation appelé « temps de réponse »). Ces systèmes peuvent être plus rapides dans certains cas, mais ils sont difficiles à concevoir, à tester et à dépanner car leur comportement dépend précisément des délais de propagation, et ils sont sensibles aux aléas (glitches).</li><li><strong>Mode synchrone :</strong> Le moment exact où les sorties peuvent changer d'état est contrôlé (synchronisé) par un signal d'horloge (clock), qui est typiquement un train d'impulsions carrées ou rectangulaires. Les changements d'état s'effectuent uniquement pendant une transition spécifique de l'horloge, appelée « front » (front montant : passage de 0 à 1, ou front descendant : passage de 1 à 0).</li></ul><p>La <strong>majorité des systèmes numériques séquentiels sont synchrones</strong>, même si certaines parties (comme une entrée de réinitialisation - reset) peuvent être asynchrones.</p><p>Les avantages principaux du mode synchrone sont :</p><ul><li>Permet de préparer les entrées sans perturber immédiatement les sorties (les changements ne sont pris en compte qu'au prochain front d'horloge).</li><li>Protège mieux contre les parasites (bruits ou glitches) survenant entre les fronts d'horloge actifs.</li></ul><p>Les <strong>bascules</strong> peuvent être considérées comme des mémoires élémentaires ; ce sont les briques de base des circuits séquentiels.</p><p>Ce sont les circuits de mémorisation les plus répandus dans les systèmes numériques en raison de :</p><ul><li>Leur rapidité de fonctionnement.</li><li>La facilité d'écriture et de lecture de l'information (bit).</li><li>La grande simplicité de leur interconnexion avec des portes logiques.</li></ul><p>On trouve deux grandes familles de bascules :</p><ul><li><strong>Bascules de mémorisation (ex: RS, D) :</strong> Elles possèdent typiquement des commandes pour forcer l'état à 0 (Reset ou Clear), forcer l'état à 1 (Set ou Preset), et mémoriser l'état actuel.</li><li><strong>Bascules de comptage (ex: JK, T) :</strong> Elles possèdent en outre une commande permettant de changer l'état (basculer ou toggle) en fonction de l'état précédent.</li></ul><h2>VIII.2 Point mémoire (Memory Point / Latch)</h2><p>La principale différence entre un système séquentiel et un système combinatoire est que lorsque l'on présente plusieurs fois de suite un même vecteur d'entrée à un système séquentiel, celui-ci – contrairement au système combinatoire – ne délivre pas nécessairement le même vecteur de sortie à chaque fois (voir Exemple 8.1).</p><p>En d'autres termes, l'état de la sortie d'un système séquentiel dépend non seulement de l'état actuel des variables d'entrée, mais également d'un paramètre lié au « temps », lequel paramètre est la plupart du temps concrétisé par « l'état antérieur » mémorisé par le système.</p><p>Soit le circuit et sa table de vérité associée suivants :</p><figure><div class="placeholder">[Placeholder: Circuit diagram showing feedback loop: A & B -> AND -> Input1 OR; F -> Input2 OR; OR output F -> connected back to Input C of AND]</div><figcaption>Circuit avec rétroaction créant un point mémoire.</figcaption><table><caption>Table de vérité du circuit avec état antérieur</caption><thead><tr><th>A</th><th>B</th><th>`C_{t-1}` (Etat Précédent)</th><th>`C_t` (Etat Actuel)</th><th>F</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>X</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>X</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>X</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p><em>Note: Le schéma fourni est ambigu et difficile à corréler directement avec la table de vérité donnée. L'élément crucial illustré par la table (ligne A=1, B=0) est la dépendance de la sortie `F_t` à un état antérieur (`C_{t-1}`), ce qui caractérise un circuit séquentiel.</em></p></figure>
    <div class="page-footer"><span>Page 92</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 3 (Chapitre VIII) -->
    <p>La sortie de la fonction F ci-dessus est dépendante d'une variable interne (que le schéma nomme C de façon ambiguë, mais qui représente l'état mémorisé). On peut constater que l'état de cette variable mémorisée dépend de l'état des entrées A et B, mais également de son état antérieur : elle mémorise donc une information liée aux entrées appliquées antérieurement au circuit.</p><p>On constate sur ce circuit (malgré son ambiguïté) que l'effet de mémorisation est dû à la <strong>boucle de rétroaction</strong> (feedback loop) présente, où la sortie (ou un état interne lié) est réinjectée en entrée d'une partie du circuit. À cette boucle est associée la variable (ou l'état) qui constitue le <strong>point mémoire</strong>.</p><div class="definition"><h5>Définition 8.1 : Circuit séquentiel</h5><p>Un circuit séquentiel est un système <strong>bouclé</strong> (contenant une ou plusieurs boucles de rétroaction) permettant la conservation d'un <strong>état</strong>, dépendant de la valeur des variables d'entrée ainsi que de l'état antérieur du système.</p></div><p>La <strong>bascule</strong> (flip-flop) constitue le système séquentiel de base et permet de mémoriser un élément d'information élémentaire appelé <strong>bit</strong>.</p><div class="exercise"><h5>► Exercice 3.1 (Référence incorrecte, devrait être 8.1)</h5><p>En se basant sur la table de vérité de la page précédente (VIII.2) et en supposant que `C_{t-1}` représente l'état de `F` avant l'application des entrées A et B :</p><p>Quel sera l'état de sortie final du système F à l'issue des deux séquences d'entrée suivantes ?</p><ol><li>Séquence 1 : (A=0, B=0) puis (A=1, B=0)</li><li>Séquence 2 : (A=0, B=1) puis (A=1, B=0)</li></ol><p><em>Solution :</em></p><ol><li>(A=0, B=0) => F=1. Ensuite (A=1, B=0) => F garde sa valeur précédente, donc F=1. État final = 1.</li><li>(A=0, B=1) => F=0. Ensuite (A=1, B=0) => F garde sa valeur précédente, donc F=0. État final = 0.</li></ol><p><em>Cet exercice illustre bien comment la sortie pour (A=1, B=0) dépend de l'état précédent.</em></p></div><p>Nous avons brièvement présenté en introduction de ce chapitre ce qu'étaient les systèmes séquentiels synchrones et asynchrones. Une autre façon de décrire ces systèmes est donnée par les définitions 8.2 et 8.3 suivantes :</p><div class="definition"><h5>Définition 8.2 : Système asynchrone</h5><p>Un système séquentiel est <strong>asynchrone</strong> si, à partir de l'instant où on applique un vecteur d'entrée, son évolution (changement d'état interne et des sorties) est incontrôlable de l'extérieur (elle dépend uniquement des délais de propagation internes).</p></div><div class="definition"><h5>Définition 8.3 : Système synchrone</h5><p>Un système séquentiel est <strong>synchrone</strong> si son évolution est contrôlable de l'extérieur par un signal d'horloge. Les changements d'état ne se produisent qu'aux instants définis par ce signal.</p></div><h2>VIII.3 Bascule RS (Reset-Set)</h2><p>La bascule RS est le circuit séquentiel le plus simple. C'est une bascule <strong>asynchrone</strong>, et toutes les autres bascules, synchrones ou asynchrones, reposent fondamentalement sur sa structure.</p><p>Son rôle consiste à mémoriser une information fugitive (une impulsion brève) sur ses entrées R (Reset) ou S (Set), selon le fonctionnement suivant :</p><ul><li>Une apparition, même fugitive, d'un niveau actif sur l'entrée <strong>S (Set)</strong> entraîne la sortie Q dans un état stable <strong>Q=1</strong> (et la sortie complémentaire `\overline{Q}=0`).</li><li>Une apparition, même fugitive, d'un niveau actif sur l'entrée <strong>R (Reset)</strong> entraîne la sortie Q dans un état stable <strong>Q=0</strong> (et `\overline{Q}=1`).</li></ul><p>(Le niveau "actif" est généralement '1' pour S et R, mais peut être '0' selon la réalisation).</p><h5>Symbole</h5><figure><div class="placeholder">[Placeholder: Symbol of an RS flip-flop with inputs R, S and outputs Q, Q_bar]</div><figcaption>Symbole logique d'une bascule RS.</figcaption><table><tbody><tr><td>R</td><td rowspan="2" style="border: none; min-width: 50px; text-align: center;">Bascule<br>RS</td><td>Q</td></tr><tr><td>S</td><td>`\overline{Q}`</td></tr></tbody></table></figure>
    <div class="page-footer"><span>Page 93</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 4 (Chapitre VIII) -->
    <h5>Tableau de Karnaugh (pour Q suivant, Q<sub>t+1</sub>, en fonction de S, R, et Q actuel, Q<sub>t</sub>)</h5><figure><div class="placeholder">[Placeholder: Karnaugh map for RS flip-flop next state Q(t+1)]</div><figcaption>Tableau de Karnaugh pour l'état suivant `Q_{t+1}` d'une bascule RS.</figcaption><table><caption>K-Map pour `Q_{t+1}`</caption><tbody><tr><td rowspan="2" colspan="2"></td><th colspan="2">S R</th></tr><tr><th>00</th><th>01</th><th>11</th><th>10</th></tr><tr><th rowspan="2">`Q_t`</th><th>0</th><td>0</td><td>0</td><td>X</td><td>1</td></tr><tr><th>1</th><td>1</td><td>0</td><td>X</td><td>1</td></tr></tbody></table><p>Équation caractéristique (simplifiée, excluant R=S=1): `Q_{t+1} = S + \overline{R} Q_t`</p><p>'X' représente l'état interdit ou indéterminé (R=S=1).</p></figure><h5>Diagramme temporel</h5><figure><div class="placeholder">[Placeholder: Timing diagram for RS flip-flop showing S, R inputs and Q output]</div><figcaption>Diagramme temporel illustrant le comportement d'une bascule RS asynchrone. Quand S passe à 1 (impulsion), Q passe à 1 et y reste même si S retombe à 0. Quand R passe à 1, Q passe à 0 et y reste.</figcaption></figure><p>Quand une impulsion est appliquée à une entrée (S ou R) pour imposer un certain état à la bascule, celle-ci demeure dans cet état, même après que l'impulsion ait disparu (tant que S=R=0). Q garde son état lorsque S passe de 1 à 0 (si R=0) et lorsque R passe de 1 à 0 (si S=0).</p><h5>Table de vérité</h5><p>Table de vérité détaillée montrant l'état suivant `Q_{t+1}` en fonction des entrées S, R et de l'état actuel `Q_t` :</p><table><caption>Table de vérité détaillée RS</caption><thead><tr><th>S</th><th>R</th><th>`Q_t`</th><th>`Q_{t+1}`</th><th>Mode</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td rowspan="2">Mémorisation</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td rowspan="2">Reset (Mise à 0)</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td rowspan="2">Set (Mise à 1)</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>X</td><td rowspan="2">Interdit / Indéterminé</td></tr><tr><td>1</td><td>1</td><td>1</td><td>X</td></tr></tbody></table><p>Table de vérité condensée (indiquant l'état stable ou l'action) :</p><table><caption>Table de vérité condensée RS</caption><thead><tr><th>S</th><th>R</th><th>`Q_{t+1}`</th><th>Mode</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>`Q_t`</td><td>Mémorisation</td></tr><tr><td>0</td><td>1</td><td>0</td><td>Reset (Mise à 0)</td></tr><tr><td>1</td><td>0</td><td>1</td><td>Set (Mise à 1)</td></tr><tr><td>1</td><td>1</td><td>X</td><td>Interdit</td></tr></tbody></table><h5>Réalisation (avec portes NAND)</h5><p>Une bascule RS peut être réalisée avec deux portes NAND interconnectées en boucle.</p><figure><div class="placeholder">[Placeholder: Circuit diagram of an RS flip-flop using two cross-coupled NAND gates]</div><figcaption>Réalisation d'une bascule RS avec des portes NAND. Note : avec cette structure, les entrées sont souvent actives à l'état bas (`\overline{S}`, `\overline{R}`).</figcaption></figure><p>Si les entrées sont actives à l'état BAS (`\overline{S}`, `\overline{R}`), alors l'état `\overline{S}=0, \overline{R}=0` est interdit (il forcerait Q=1 et `\overline{Q}=1`).</p><p><strong>Priorité :</strong> Selon la réalisation, le comportement pour l'état interdit (S=1, R=1 pour portes NOR, ou `\overline{S}=0, \overline{R}=0` pour portes NAND) peut être défini.</p><ul><li><strong>Priorité à l'enclenchement (Set) :</strong> Si S=R=1, force Q=1. (Exemple: `Q_{t+1} = S + \overline{R} Q_t`)</li><li><strong>Priorité au déclenchement (Reset) :</strong> Si S=R=1, force Q=0. (Exemple: `Q_{t+1} = (S + Q_t) \overline{R}`)</li><li>Le texte mentionne "enclenchement prioritaire" forçant Q=1 si `X=1 -> Q` pour `S=1, R=1`. Cela correspond à une bascule RS où Set domine Reset en cas de conflit.</li></ul><p>L'implémentation à base de somme de produits (ET-OU) ou avec des portes NAND correspond généralement à une priorité naturelle (souvent Set pour S=1, R=1 avec NAND, ou indéfini/oscillation). L'implémentation avec des portes NOR (voir page suivante) est plus courante pour une bascule RS simple active haut.</p>
    <div class="page-footer"><span>Page 94</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 5 (Chapitre VIII) -->
    <h5>Réalisation (avec portes NOR)</h5><p>Une bascule RS peut aussi être réalisée avec deux portes NOR interconnectées.</p><figure><div class="placeholder">[Placeholder: Circuit diagram of an RS flip-flop using two cross-coupled NOR gates]</div><figcaption>Réalisation d'une bascule RS avec des portes NOR. Les entrées S et R sont actives à l'état HAUT.</figcaption><p>Avec les portes NOR, l'état S=1, R=1 force `Q=0` et `\overline{Q}=0`, ce qui est incohérent. C'est l'état interdit.</p></figure><p>Le texte mentionne "déclenchement prioritaire" forçant Q=0 si `X=0 -> Q` pour `S=1, R=1`. Cela correspond à une bascule RS où Reset domine Set en cas de conflit, ou au comportement naturel de la bascule NOR (Q=0, Q_bar=0).</p><p>L'implémentation à base de produit de sommes (OU-ET) ou avec des portes NOR est la réalisation standard pour une bascule RS active haut.</p><div class="remark"><h5>► Remarque 8.1 : Problème de l'état interdit</h5><p>Dans les deux cas (NAND ou NOR), l'état où les deux entrées sont actives simultanément (S=R=1 pour NOR, `\overline{S}=\overline{R}=0` pour NAND) est problématique. Non seulement il mène à des sorties Q et `\overline{Q}` qui ne sont plus complémentaires (`Q=Q_bar=0` pour NOR, `Q=Q_bar=1` pour NAND), mais surtout, si on passe de cet état (ex: R=S=1) à l'état de mémorisation (R=S=0), le résultat est imprévisible.</p><p>L'état final (`Q=0` ou `Q=1`) dépendra de quelle entrée (R ou S) revient à 0 en dernier, même par une différence infime de temps (condition de course - race condition). Selon la rapidité relative des signaux et des portes, la sortie peut prendre aussi bien l'état `Q=1` que `Q=0`.</p><p>⇒ Il faut donc <strong>interdire</strong> la combinaison R=S=1 (pour NOR) ou `\overline{R}=\overline{S}=0` (pour NAND) ou, si elle ne peut être évitée, s'assurer de ne jamais passer directement de cet état à l'état R=S=0.</p></div><h5>Fonctionnement détaillé de la bascule avec des NOR (Actives Haut)</h5><ul><li><strong>Cas 1 : R=0, S=0 (Mémorisation)</strong><ul><li>Si `Q_{t}=0` (donc `\overline{Q}_{t}=1`), alors l'entrée du NOR du haut est (S=0, Q=0) => `\overline{Q}=1`. L'entrée du NOR du bas est (R=0, `\overline{Q}=1`) => `Q=0`. L'état est stable (`Q=0`).</li><li>Si `Q_{t}=1` (donc `\overline{Q}_{t}=0`), alors l'entrée du NOR du haut est (S=0, Q=1) => `\overline{Q}=0`. L'entrée du NOR du bas est (R=0, `\overline{Q}=0`) => `Q=1`. L'état est stable (`Q=1`).</li><li>Conclusion : Si R=S=0, la bascule conserve son état antérieur `Q_t`.</li></ul></li><li><strong>Cas 2 : S=1, R=0 (Set)</strong><ul><li>L'entrée S=1 sur le NOR du haut force sa sortie `\overline{Q}` à 0, quelles que soient les autres entrées.</li><li>Cette sortie `\overline{Q}=0` est appliquée au NOR du bas. Avec R=0, l'entrée du NOR du bas est (R=0, `\overline{Q}=0`) => `Q=1`.</li><li>L'état stable est `Q=1`. C'est l'opération de <strong>SET</strong> (mise à 1).</li></ul><figure><div class="placeholder">[Placeholder: NOR Latch diagram during SET operation S=1, R=0]</div><figcaption>Fonctionnement SET (S=1, R=0) pour la bascule NOR.</figcaption></figure></li><li><strong>Cas 3 : S=0, R=1 (Reset)</strong><ul><li>L'entrée R=1 sur le NOR du bas force sa sortie `Q` à 0, quelles que soient les autres entrées.</li><li>Cette sortie `Q=0` est appliquée au NOR du haut. Avec S=0, l'entrée du NOR du haut est (S=0, Q=0) => `\overline{Q}=1`.</li><li>L'état stable est `Q=0`. C'est l'opération de <strong>RESET</strong> (mise à 0).</li></ul><figure><div class="placeholder">[Placeholder: NOR Latch diagram during RESET operation S=0, R=1]</div><figcaption>Fonctionnement RESET (S=0, R=1) pour la bascule NOR.</figcaption></figure></li><li><strong>Cas 4 : S=1, R=1 (Interdit)</strong><ul><li>S=1 force `\overline{Q}=0`.</li><li>R=1 force `Q=0`.</li><li>L'état `Q=0` et `\overline{Q}=0` est incohérent.</li></ul></li></ul>
    <div class="page-footer"><span>Page 95</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 6 (Chapitre VIII) -->
    <ul><li><strong>Récapitulatif des opérations :</strong><ul><li>R=0, S=0 : Mémorise Q.</li><li>R=0, S=1 : Force Q=1 (SET).</li><li>R=1, S=0 : Force Q=0 (RESET).</li><li>R=1, S=1 : État interdit (`Q=0`, `\overline{Q}=0`).<ul><li>Condition indésirable, puisque Q et `\overline{Q}` doivent être l'inverse l'un de l'autre.</li><li>De plus, incertitude lorsque S et R reviennent à 0 (condition de course).</li><li>⇒ La combinaison R=S=1 ne doit pas être utilisée en pratique pour une bascule RS simple.</li></ul></li></ul></li></ul><p>L'avantage principal (unique?) de la bascule RS est sa <strong>simplicité</strong>.</p><p>Ses principaux inconvénients sont :</p><ul><li>Le fait qu'elle soit <strong>asynchrone</strong> : sa sortie réagit immédiatement (au délai de propagation près) aux changements sur S et R.</li><li>Sa <strong>sensibilité aux parasites</strong> : tout bruit (glitch) suffisamment ample et long présent sur l'une des entrées S ou R peut modifier l'état de la sortie de manière intempestive.</li><li>Le fait qu'il existe un <strong>état interdit</strong> pour R=S=1.</li></ul><h2>VIII.4 Bascule RS synchrone ou bascule RSH (ou RST)</h2><p>La bascule RSH<sup>1</sup> est une bascule RS rendue <strong>synchrone</strong> par l'ajout d'un signal de contrôle, typiquement une entrée d'horloge H (parfois appelée Clk, E, G - Clock, Enable, Gate).</p><p>Le fonctionnement est le suivant :</p><ul><li>Lorsque l'entrée de contrôle H est au niveau <strong>inactif</strong> (souvent niveau bas '0'), les entrées R et S sont ignorées. La bascule fonctionne comme une mémoire : elle conserve son état précédent.</li><li>Lorsque l'entrée de contrôle H est au niveau <strong>actif</strong> (souvent niveau haut '1'), la bascule fonctionne comme une bascule RS classique : les entrées R et S déterminent l'état de la sortie Q.</li></ul><p>Elle conserve donc l'état interdit de la bascule RS lorsque H est actif et R=S=1.</p><p><em><sup>1</sup>Note de bas de page du document: La bascule RSH est également appelée bascule RST; on préférera néanmoins le terme RSH, plus explicite (R, S, H). Parfois aussi appelée RS Gated Latch.</em></p><h5>Symbole</h5><figure><div class="placeholder">[Placeholder: Symbol of a synchronous RS flip-flop (RSH Latch) with R, S, H inputs and Q, Q_bar outputs]</div><figcaption>Symbole logique d'une bascule RSH (RS synchrone par niveau).</figcaption><table><tbody><tr><td>R</td><td rowspan="3" style="border: none; min-width: 50px; text-align: center;">Bascule<br>RSH</td><td>Q</td></tr><tr><td>S</td><td>`\overline{Q}`</td></tr><tr><td>H (ou Clk, En)</td><td></td></tr></tbody></table></figure><p>L'état de la sortie Q est souvent noté `Q_N` (ou `Q_t`) avant l'instant de décision (pendant que H est inactif ou juste avant qu'il devienne actif) et `Q_{N+1}` (ou `Q_{t+1}`) après la prise en compte des entrées (pendant que H est actif).</p><p>S et R n'influencent Q que lorsque l'horloge (H) est au niveau haut (actif).</p><h5>Table de vérité</h5><table><caption>Table de vérité RSH (synchrone niveau haut)</caption><thead><tr><th>S</th><th>R</th><th>H</th><th>`Q_{N+1}`</th><th>Mode</th></tr></thead><tbody><tr><td>X</td><td>X</td><td>0</td><td>`Q_N`</td><td>Mémorisation (H inactif)</td></tr><tr><td>0</td><td>0</td><td>1</td><td>`Q_N`</td><td>Mémorisation (H actif)</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>Reset (H actif)</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>Set (H actif)</td></tr><tr><td>1</td><td>1</td><td>1</td><td>X</td><td>Interdit (H actif)</td></tr></tbody></table><h5>Réalisation</h5><p>Une bascule RSH peut être réalisée en ajoutant deux portes ET (AND gates) à l'entrée d'une bascule RS asynchrone simple (par exemple, celle à base de NOR). L'entrée H contrôle ces portes ET.</p>
    <div class="page-footer"><span>Page 96</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 7 (Chapitre VIII) -->
    <figure><div class="placeholder">[Placeholder: Circuit diagram of an RSH latch using an RS NOR latch and AND gates controlled by H]</div><figcaption>Réalisation d'une bascule RSH : Les entrées S et R sont conditionnées par l'entrée H via des portes ET avant d'attaquer une bascule RS (ici, implicitement à base de NOR).</figcaption></figure><figure><div class="placeholder">[Placeholder: Alternative realization using NAND gates, inputs S, R, H, outputs Q, Q_bar]</div><figcaption>Réalisation d'une bascule RSH avec des portes NAND.</figcaption></figure><div class="example"><h5>▷ Exemple 8.2 : Diagramme temporel RSH</h5><figure><div class="placeholder">[Placeholder: Timing diagram for RSH latch showing H, S, R inputs and Q output]</div><figcaption>Diagramme temporel : Q ne change que lorsque H est à 1. Si H=1 et S=1/R=0, Q passe à 1. Si H=1 et R=1/S=0, Q passe à 0. Si H=1 et S=R=0, Q garde son état. Si H=0, Q garde son état quelles que soient S et R.</figcaption></figure></div><p>L'avantage de la bascule RSH par rapport à la bascule RS asynchrone est sa <strong>sensibilité moindre aux parasites</strong> sur les entrées S et R. Comme la bascule n'est sensible au bruit sur S et R que lorsque l'horloge H est au niveau haut, plus la durée de l'état haut de l'horloge sera brève, moins la bascule sera sensible aux parasites pendant cet intervalle.</p><p>Cependant, elle reste sensible pendant toute la durée où H est actif.</p><h2>VIII.5 Bascule à verrouillage (D-latch ou Verrou D)</h2><p>La bascule D-latch (Data latch) est dérivée de la bascule RSH (ou RST) pour laquelle on n'a conservé que les deux combinaisons d'entrée utiles et non interdites : Reset (S=0, R=1) et Set (S=1, R=0). Pour cela, on utilise une seule entrée de donnée, nommée D :</p><ul><li>L'entrée S est connectée à D.</li><li>L'entrée R est connectée à `\overline{D}` (l'inverse de D, obtenu via un inverseur).</li></ul><p>Ainsi, on ne peut avoir que S=0/R=1 (si D=0) ou S=1/R=0 (si D=1). L'état S=R=0 (mémorisation de la RSH quand H=1) et l'état S=R=1 (interdit) sont éliminés lorsque H=1.</p><h5>Symbole</h5><figure><div class="placeholder">[Placeholder: Symbol of a D-latch with D input, En (or H, Clk, G) input, and Q, Q_bar outputs]</div><figcaption>Symbole logique d'un verrou D (D-latch). L'entrée de contrôle est souvent appelée Enable (En), Gate (G), ou parfois Clock (Clk).</figcaption><table><tbody><tr><td>D</td><td rowspan="2" style="border: none; min-width: 50px; text-align: center;">Verrou<br>D</td><td>Q</td></tr><tr><td>En (ou H)</td><td>`\overline{Q}`</td></tr></tbody></table></figure><h5>Table de vérité</h5><table><caption>Table de vérité D-Latch (actif niveau haut)</caption><thead><tr><th>En</th><th>D</th><th>`Q_{N+1}`</th><th>Mode</th></tr></thead><tbody><tr><td>0</td><td>X</td><td>`Q_N`</td><td>Mémorisation / Verrouillé</td></tr><tr><td>1</td><td>0</td><td>0</td><td>Reset / Transparent (suit D)</td></tr><tr><td>1</td><td>1</td><td>1</td><td>Set / Transparent (suit D)</td></tr></tbody></table><p>Lorsque En=1, la sortie `Q` suit la valeur de l'entrée `D` (`Q_{N+1} = D`). On dit que le verrou est <strong>transparent</strong>.</p><p>Lorsque En=0, la sortie `Q` conserve la dernière valeur qu'elle avait lorsque En est passé de 1 à 0. Le verrou est <strong>mémorisé</strong> ou <strong>verrouillé</strong>.</p><h5>Réalisation</h5><p>On part de la réalisation d'une bascule RSH et on ajoute un inverseur pour générer R à partir de S (ou D).</p><figure><div class="placeholder">[Placeholder: Circuit diagram of a D-latch using an RSH latch structure with an inverter on the D input to create R=Not(D)]</div><figcaption>Réalisation d'un verrou D à partir d'une structure RSH.</figcaption></figure>
    <div class="page-footer"><span>Page 97</span><span>© M. Siadat & C. Diou</span></div>
    <hr>

    <!-- Page 8 (Chapitre VIII) -->
    <h5>Fonctionnement du D-Latch</h5><ul><li>Quand l'entrée d'horloge/validation (Clk/En/H) est à <strong>0</strong> : Les portes d'entrée (ET ou NAND conditionnées par H) sont bloquées. La bascule RS interne est en mode mémorisation (ses entrées effectives sont S=0, R=0). L'entrée D n'a aucun effet. La sortie Q conserve sa valeur précédente. => <strong>Mémorisation</strong>.</li><li>Quand l'entrée d'horloge/validation (Clk/En/H) est à <strong>1</strong> : Les portes d'entrée sont actives.<ul><li>Si D=1, alors S=1 et R=0 sont appliqués à la bascule RS interne => Q passe à 1 (ou y reste).</li><li>Si D=0, alors S=0 et R=1 sont appliqués à la bascule RS interne => Q passe à 0 (ou y reste).</li></ul>Dans ce mode, la sortie Q suit les changements de l'entrée D. => La bascule est <strong>transparente</strong>.</li></ul><p>Le D-latch n'a pas d'état interdit. Il est dit transparent sur le <strong>niveau haut</strong> de l'horloge (ou Enable).</p><div class="remark"><h5>► Remarque 8.2 : Symbole d'horloge</h5><p>Notez l'absence du symbole `>` (indicateur de sensibilité à un front) sur l'entrée d'horloge/validation (H ou En) du D-latch. Cela signifie qu'il est sensible au <strong>niveau</strong> de l'horloge, et non à ses transitions (fronts).</p></div><h2>VIII.6 Bascules maître-esclave</h2><p>Les bascules maître-esclaves ont été développées pour diminuer la sensibilité aux parasites et pour résoudre certains problèmes de synchronisation dans les systèmes complexes. L'idée est de réduire ou d'éliminer la période pendant laquelle la bascule est "transparente" aux entrées.</p><p>La structure maître-esclave est constituée de <strong>deux bascules RSH (ou RST) montées en cascade</strong> :</p><ul><li>Le premier étage est appelé le <strong>maître</strong> (master).</li><li>Le deuxième étage est appelé l'<strong>esclave</strong> (slave).</li></ul><p>Elles sont commandées par deux signaux d'horloge en <strong>opposition de phase</strong> (l'un est l'inverse de l'autre). Souvent, on utilise un seul signal d'horloge H, et son inverse `\overline{H}` est généré en interne ou en externe.</p><p>La fonction globale réalisée est la même que celle d'une seule bascule, mais le comportement temporel est différent : la bascule maître-esclave n'est plus sensible au niveau de l'horloge, mais à une de ses <strong>transitions (front)</strong>.</p><p><strong>Fonctionnement typique (pour une bascule RS maître-esclave sensible au front descendant) :</strong></p><ul><li><svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M10 12.5a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v9zm-1.5-7a.5.5 0 0 0 0-1H3V12h5.5V5.5z"></path></svg> <strong>Sur le niveau bas de l'horloge (H=0, `\overline{H}=1`) :</strong><ul><li>Le premier étage (maître) est bloqué (mode « mémorisation »). Ses entrées R et S externes n'ont pas d'effet sur lui.</li><li>Le deuxième étage (esclave) est actif (transparent). Il recopie l'état de la sortie du maître. La sortie finale Q de la bascule est donc stable et égale à l'état du maître.</li></ul></li><li><svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><path fill-rule="evenodd" d="M6 3.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-9zm1.5 7a.5.5 0 0 0 0 1H13V4H7.5v6.5z"></path></svg> <strong>Sur le niveau haut de l'horloge (H=1, `\overline{H}=0`) :</strong><ul><li>Le premier étage (maître) est actif (mode RS). Il prend l'état déterminé par les entrées R et S externes.</li><li>Le deuxième étage (esclave) est bloqué (mode « mémorisation »). Il conserve l'état qu'il avait précédemment (qui était l'état du maître lorsque H était bas). La sortie finale Q de la bascule ne change pas pendant ce niveau haut.</li></ul></li><li><svg width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor"><path d="M7.247 11.14L.923 4.817l.707-.707L8 9.728l6.37-6.37.707.707L8.707 11.14a1 1 0 0 1-1.414 0z"></path></svg> <strong>Sur le front descendant de l'horloge (passage H de 1 à 0) :</strong><ul><li>Le maître se bloque, mémorisant l'état défini par R et S juste avant le front.</li><li>L'esclave devient actif et recopie l'état que le maître vient de mémoriser.</li><li>C'est à cet instant précis (le front descendant) que la sortie Q de la bascule peut changer d'état.</li></ul></li></ul><p>La période pendant laquelle la bascule est sensible aux parasites sur ses entrées R et S se résume donc à la durée de commutation de
