<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Électronique Numérique - Chapitre 4 (Fin) & Chapitre 5</title>
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <!-- KaTeX JS -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <!-- KaTeX auto-render extension -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            padding: 15px;
            counter-reset: page 30; /* Start page numbering from 31 (PDF page 101) */
        }

        header,
        footer {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #555;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-bottom: 15px;
            position: relative;
        }

        footer::after {
          counter-increment: page;
          content: "Page " counter(page);
          position: absolute;
          right: 0;
        }

        footer {
            border-top: 1px solid #ccc;
            border-bottom: none;
            margin-top: 15px;
            padding-top: 5px;
            text-align: center; /* Center text potentially, but page number is on the right */
        }

        h1, h2, h3, h4, h5 {
            margin-top: 1.5em;
            margin-bottom: 0.8em;
        }

        h1 { font-size: 2em; text-align: center; }
        h2 { font-size: 1.8em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        h3 { font-size: 1.6em; margin-top: 2em; }
        h4 { font-size: 1.4em; margin-top: 1.8em; }
        h5 { font-size: 1.2em; margin-top: 1.5em; }
        h6 { font-size: 1.1em; font-style: italic; }


        img.placeholder {
            display: block;
            max-width: 90%; /* Slightly larger max-width */
            min-height: 100px;
            border: 1px dashed #aaa;
            margin: 15px auto;
            padding: 10px;
            text-align: center;
            color: #888;
            background-color: #f9f9f9;
        }

        .caption {
            text-align: center;
            font-style: italic;
            margin-top: 5px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        table {
            border-collapse: collapse;
            margin: 15px auto;
            border: 1px solid #ccc;
        }

        th, td {
            border: 1px solid #ccc;
            padding: 6px 10px;
            text-align: center;
            vertical-align: middle;
        }

        th {
            background-color: #f2f2f2;
        }

        ul, ol {
            margin-left: 20px;
            margin-bottom: 1em;
        }
        li {
            margin-bottom: 8px;
        }
        .footnote {
            font-size: 0.85em;
            margin-top: 15px;
            color: #444;
        }
        .page-break {
            page-break-before: always;
        }

        /* Adjust KaTeX display alignment */
        .katex-display {
            text-align: center;
            margin: 1em 0;
        }
        .katex-display > .katex {
            display: inline-block;
            text-align: initial;
        }
         .exercise-section h3, .exercise-section h4, .exercise-section h5 {
            margin-top: 1.5em; /* Reduced top margin for exercise headings */
            border-top: none; /* Remove top border */
            padding-top: 0; /* Remove padding */
        }
        .correction-section h4 {
             margin-top: 2em;
             border-top: 2px solid #ccc;
             padding-top: 1em;
        }
    </style>
</head>

<body>

    <!-- Start Previous Content (Pages 1-30 / PDF 71-100) -->
    <!-- ... [HTML content from the previous responses would go here] ... -->
    <!-- End Previous Content -->

    <!-- Start Page 31 Content (PDF Page 101) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <div>
        <img src="placeholder_figure38.png" alt="Figure 38: Chronogramme complété pour l'exercice 4 (bascule T)" class="placeholder">
        <p class="caption">Figure 38</p>
        <p style="text-align: center;">(Description: Chronogramme de l'exercice 4 complété. Montre les signaux E, R1, S1, Q1, $\bar{Q1}$, R2, S2, Q. Des annotations indiquent l'état (mémoire/set/reset) du maître et de l'esclave pendant les phases de E. Le signal Q bascule à chaque front descendant de E.)</p>
    </div>

    <p style="margin-left: 20px;">
        6. La sortie $Q$ change de valeur à chaque transition $1 \to 0$ sur l'entrée E: Il s'agit d'une <strong>bascule T</strong> (Toggle) active sur front descendant. On peut également voir ce système comme un <strong>diviseur de fréquence par 2</strong> (la fréquence du signal sur la sortie $Q$ est deux fois plus petite que sur l'entrée E).
    </p>

    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 31 Content -->

    <!-- Start Page 32 Content (PDF Page 102) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <!-- Page largely blank -->
    <div style="min-height: 60vh;"></div>

    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 32 Content -->

    <!-- Start Page 33 Content (PDF Page 103) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <h1>Chapitre 5</h1>
    <h2>Compteurs, registres et mémoires.</h2>

    <p>
        Dans ce chapitre nous allons combiner entre elles plusieurs bascules synchrones (flip-flops) pour réaliser des fonctions logiques plus évoluées. Nous nous attarderons sur trois types de circuits numériques extrêmement répandus : les compteurs, les registres et les mémoires. Ces circuits constituent des blocs fondamentaux dans la conception de systèmes numériques complexes.
    </p>

    <h3>5.1. Généralités sur les compteurs.</h3>
    <p>
        Les compteurs sont des systèmes séquentiels très utilisés. Leur fonction principale est de compter, c'est-à-dire de coder, dans un système de numérotation approprié (le plus souvent binaire ou BCD), le nombre d'impulsions (événements, fronts d'horloge) survenant en un point d'un circuit. Ils mémorisent ce nombre et le rendent disponible sur leurs sorties.
    </p>

    <h4>5.1.1. Compteurs binaires.</h4>
    <p>
        Un <strong>compteur binaire modulo $2^n$</strong> (ou compteur par $2^n$) compte les impulsions arrivant sur son entrée d'horloge, et présente le résultat en <strong>binaire naturel</strong> sur ses $n$ sorties. La valeur comptée augmente de 1 à chaque impulsion active d'horloge. Lorsque le compteur atteint sa valeur maximale ($2^n - 1$), l'impulsion suivante le fait revenir à 0, et le cycle recommence (comptage modulo $2^n$).
    </p>
    <p>
        Un tel compteur possède donc au minimum une entrée synchrone (entrée d'horloge), qui reçoit les impulsions à compter, et $n$ sorties, notées $Q_{n-1} Q_{n-2} \dots Q_1 Q_0$. $Q_0$ est le bit de poids faible (LSB - Least Significant Bit, poids $2^0$) et $Q_{n-1}$ est le bit de poids fort (MSB - Most Significant Bit, poids $2^{n-1}$). Sa capacité de comptage est ainsi comprise entre 0 (état $00\dots0$) et $2^n - 1$ (état $11\dots1$).
    </p>
    <p>
        Considéré comme un système synchrone, un compteur binaire est, par définition, un circuit séquentiel possédant $2^n$ états stables distincts. Chaque état correspond à une combinaison particulière des $n$ sorties binaires. Le compteur évolue cycliquement d'un état à l'état suivant au fur et à mesure des impulsions d'horloge qu'il reçoit.
    </p>
    <p>
        Le tableau suivant représente la table de transition (ou séquence de comptage) d'un compteur binaire par 8 (modulo $2^3$, donc $n=3$). Comme précédemment, l'état $n$ est l'état juste avant l'impulsion d'horloge (état présent) et l'état $n+1$ celui juste après l'impulsion (état futur). Le compteur possède trois bits de sortie $Q_C, Q_B, Q_A$ affectés respectivement des poids $2^2, 2^1$ et $2^0$. Le bit $Q_A$ est donc le bit de poids faible (LSB) et $Q_C$ le bit de poids fort (MSB).
    </p>

    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 33 Content -->

    <!-- Start Page 34 Content (PDF Page 104) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <div style="display: flex; justify-content: space-around; align-items: center; flex-wrap: wrap; margin-bottom: 20px;">
        <!-- Block Diagram -->
        <div style="text-align: center; margin: 10px;">
             <img src="placeholder_counter_block.png" alt="Bloc compteur par 2^3" class="placeholder" style="width: 250px;">
             <p class="caption">Schéma bloc d'un compteur modulo 8</p>
        </div>
        <!-- Transition Table -->
        <div style="margin: 10px;">
            <p style="text-align: center;">Table de transition (Compteur Modulo 8)</p>
            <table>
                 <thead>
                    <tr><th colspan="3">Etat n</th> <th colspan="3">Etat n+1</th> <th>Décimal</th></tr>
                    <tr><th>$Q_C$</th><th>$Q_B$</th><th>$Q_A$</th> <th>$Q_C$</th><th>$Q_B$</th><th>$Q_A$</th> <th>(n+1)</th></tr>
                </thead>
                 <tbody>
                    <tr><td>0</td><td>0</td><td>0</td> <td>0</td><td>0</td><td>1</td> <td>1</td></tr>
                    <tr><td>0</td><td>0</td><td>1</td> <td>0</td><td>1</td><td>0</td> <td>2</td></tr>
                    <tr><td>0</td><td>1</td><td>0</td> <td>0</td><td>1</td><td>1</td> <td>3</td></tr>
                    <tr><td>0</td><td>1</td><td>1</td> <td>1</td><td>0</td><td>0</td> <td>4</td></tr>
                    <tr><td>1</td><td>0</td><td>0</td> <td>1</td><td>0</td><td>1</td> <td>5</td></tr>
                    <tr><td>1</td><td>0</td><td>1</td> <td>1</td><td>1</td><td>0</td> <td>6</td></tr>
                    <tr><td>1</td><td>1</td><td>0</td> <td>1</td><td>1</td><td>1</td> <td>7</td></tr>
                    <tr><td>1</td><td>1</td><td>1</td> <td>0</td><td>0</td><td>0</td> <td>0</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <h4>5.1.2. Réalisation d'un compteur binaire.</h4>
    <p>
        La réalisation d'un compteur binaire repose sur l'observation du comportement des bits de sortie lors du comptage. On peut facilement vérifier les constatations suivantes sur la table de transition ci-dessus:
    </p>
    <ol>
        <li>Le bit de poids faible ($Q_A$) commute (change d'état $0 \leftrightarrow 1$) à <strong>chaque</strong> impulsion d'horloge.</li>
        <li>Un bit de sortie $Q_i$ (pour $i > 0$) commute ($0 \leftrightarrow 1$) si, et seulement si, <strong>tous les bits de poids plus faible</strong> ($Q_{i-1}, \dots, Q_A$) sont au niveau 1 juste avant l'impulsion d'horloge. (Ex: $Q_B$ commute quand $Q_A=1$; $Q_C$ commute quand $Q_B=1$ ET $Q_A=1$).</li>
        <li>Un bit de sortie $Q_i$ (pour $i > 0$) commute ($0 \leftrightarrow 1$) si, et seulement si, le bit de poids <strong>immédiatement inférieur</strong> ($Q_{i-1}$) passe de 1 à 0 au moment de l'impulsion d'horloge. (Ex: $Q_B$ commute quand $Q_A$ passe de 1 à 0; $Q_C$ commute quand $Q_B$ passe de 1 à 0).</li>
    </ol>
    <p>
        Les points 2 et 3 sont des conditions équivalentes pour le comptage binaire naturel, mais ils conduisent à la réalisation de deux types de compteurs différents (compteurs synchrones et compteurs asynchrones, voir section 5.1.3) ayant chacun leurs avantages et leurs inconvénients.
    </p>
    <p>
        Quelle que soit l'hypothèse retenue pour sa réalisation (basée sur la condition 2 ou 3), un compteur est constitué de cellules élémentaires (bascules) qui commutent, ou pas, à chaque impulsion d'horloge active. Chaque bit de comptage ($Q_A, Q_B, \dots$) correspond en pratique à la sortie d'une bascule. Puisque le comportement souhaité est souvent de commuter ($0 \to 1 \to 0 \to \dots$), la <strong>bascule T (Toggle)</strong> est la cellule de base naturelle pour construire un compteur. Une bascule T est une bascule synchrone dont la sortie change d'état à chaque front actif de l'horloge si son entrée T est active (T=1). Elle peut être réalisée soit avec une bascule JK dont les deux entrées sont maintenues à 1 ($J = K = 1$), soit avec une bascule D synchrone dont la sortie $\bar{Q}$ est rebouclée sur l'entrée D ($\bar{Q}_n \to D_n$), comme illustré Figure 39 (page suivante).
    </p>


    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 34 Content -->

     <!-- Start Page 35 Content (PDF Page 105) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <div style="display: flex; justify-content: space-around; align-items: flex-start;">
         <img src="placeholder_figure39a_dff.png" alt="Figure 39 Bascule T avec D-FF" class="placeholder" style="width: 45%;">
         <img src="placeholder_figure39b_jkff.png" alt="Figure 39 Bascule T avec JK-FF" class="placeholder" style="width: 45%;">
    </div>
    <p class="caption">Figure 39: Réalisation d'une bascule T (Toggle). Gauche: avec une bascule D ($\bar{Q}$ connectée à D). Droite: avec une bascule JK (J=K=1, connecté à Vcc ou niveau haut 'Avec').</p>

    <h4>5.1.3. Compteur synchrone / compteur asynchrone.</h4>
    <p>
        Précisons immédiatement que, au sens où nous l'avons entendu jusqu'à présent (chapitre 4), <strong>tous les compteurs</strong> (utiles) sont des systèmes <strong>synchrones</strong> puisqu'ils ne changent d'état (comptent) qu'au moment où ils reçoivent une impulsion d'horloge (un front actif).
    </p>
    <p>
        Cependant, dans le contexte spécifique des compteurs, les termes <strong>synchrone</strong> et <strong>asynchrone</strong> ont des significations différentes qui se rapportent à la manière dont les bascules internes sont interconnectées et commandées par l'horloge. Nous allons maintenant expliquer ces deux architectures.
    </p>
    <ul>
        <li>
            <strong>Compteur Synchrone:</strong><br>
            Lorsqu'un compteur est basé sur le principe qu'un bit de sortie $Q_i$ commute si, et seulement si, tous les bits de poids plus faible ($Q_{i-1} \dots Q_A$) sont au niveau 1 (condition 2 de 5.1.2), il est qualifié de <strong>synchrone</strong>. Dans cette architecture, l'entrée d'horloge externe est appliquée <strong>simultanément</strong> à toutes les bascules du compteur. Des portes logiques supplémentaires sont utilisées pour générer les signaux de commande (par exemple, l'entrée T ou les entrées J/K) de chaque bascule, en fonction de l'état des bascules précédentes, afin qu'elles commutent ou non au prochain coup d'horloge. <br>
            L'avantage clé est que toutes les bascules qui doivent changer d'état le font (presque) exactement au même moment, synchronisées par le même front d'horloge. Supposons que les $p$ premiers bits de poids faible soient à 1 ($Q_{p-1} \dots Q_A = 1\dots1$) et que le bit de rang $p+1$ ($Q_p$) soit à 0. Au moment de l'impulsion d'horloge, les $p$ premiers bits passent simultanément à 0 et le bit $Q_p$ passe à 1. Les $p+1$ premiers bits du compteur commutent donc (pratiquement) au même moment<sup>9</sup>. D'où le qualificatif de synchrone.
        </li>
        <li>
            <strong>Compteur Asynchrone (ou Compteur à propagation / Ripple Counter):</strong><br>
            Lorsqu'un compteur est basé sur l'idée qu'un bit de sortie $Q_i$ commute si, et seulement si, le bit de poids immédiatement inférieur ($Q_{i-1}$) passe de 1 à 0 (condition 3 de 5.1.2), il est qualifié d'<strong>asynchrone</strong> ou à propagation ("ripple"). Dans cette architecture, seule l'entrée d'horloge de la première bascule (celle du LSB, $Q_A$) reçoit directement le signal d'horloge externe. L'entrée d'horloge de chaque bascule suivante ($Q_i$) est commandée par la sortie (souvent Q ou $\bar{Q}$) de la bascule précédente ($Q_{i-1}$).<br>
            Supposons toujours que les $p$ premiers bits soient à 1 ($1\dots1$) et le suivant $Q_p$ à 0. Au moment de l'impulsion d'horloge externe, la première bascule ($Q_A$) commute, passant de 1 à 0. Cette transition $1 \to 0$ sur $Q_A$ sert d'horloge pour la deuxième bascule ($Q_B$), qui commute donc à son tour de 1 à 0, et ainsi de suite. La commutation se propage en cascade ("ripple") à travers les étages. Cette cascade s'arrête au bit de rang $p+1$ ($Q_p$) qui reçoit une transition $1 \to 0$ de $Q_{p-1}$ et passe donc de 0 à 1. Le changement d'état de $Q_p$ se produit avec un retard, par rapport à l'impulsion initiale, égal à $p \times t_{prop}$ (où $t_{prop}$ est le temps de propagation d'une bascule). Dans cette approche, les bascules commutent les unes après les autres, et non simultanément, d'où le qualificatif de compteur asynchrone (bien que le comptage global reste synchronisé sur l'horloge externe pour le LSB).
        </li>
    </ul>
    <p class="footnote">
       <sup>9</sup> Aux différences (généralement faibles) de temps de commutation des bascules près.
    </p>

    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 35 Content -->

     <!-- Start Page 36 Content (PDF Page 106) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <h4>5.1.4. Compteurs à cycle incomplet ou non binaire.</h4>
    <p>
        En pratique, on a souvent besoin d'un compteur qui ne suit pas le cycle binaire complet $0 \to 2^n-1$. Par exemple, pour compter jusqu'à 10 (compteur décennal ou BCD), on a besoin d'un compteur modulo N avec N différent de $2^n$.
    </p>
    <p>
        Il arrive également que l'on ait besoin d'un compteur affichant le résultat dans d'autres codes que le code binaire naturel (par exemple, code Gray).
    </p>
    <p>
        Dans ces situations, les solutions envisageables sont entre autres:
    </p>
    <ul>
        <li>
            <strong>Une synthèse complète du compteur</strong>: Concevoir le circuit séquentiel état par état pour suivre la séquence de comptage désirée. Ceci est nécessaire si le code utilisé est différent du code binaire et/ou si les règles de commutation énoncées au paragraphe 5.1.2 ne sont plus applicables (cycle tronqué ou arbitraire).
        </li>
        <li>
            <strong>Le décodage de la valeur finale et rétroaction (reset)</strong>: Pour obtenir un compteur modulo N à partir d'un compteur binaire modulo $2^n$ (avec $2^n > N$), on peut détecter l'état N (ou parfois N-1) à l'aide d'une porte logique et utiliser ce signal pour activer l'entrée de remise à zéro (CLEAR asynchrone ou synchrone) des bascules à l'impulsion d'horloge suivante (ou immédiatement si asynchrone). Le compteur compte alors de 0 à N-1 puis revient à 0. Cette solution n'est bien sûr valable que pour le comptage en code binaire naturel tronqué.
        </li>
    </ul>

    <h3>5.2. Les compteurs asynchrones (Ripple Counters).</h3>

    <h4>5.2.1. Les compteurs binaires asynchrones.</h4>
    <p>
        Dans un compteur asynchrone, comme mentionné (condition 3 de 5.1.2), le bit de poids $p$ ($Q_p$) commute si, et seulement si, le bit de poids $p-1$ ($Q_{p-1}$) passe du niveau haut au niveau bas ($1 \to 0$). À partir de ce constat, on aboutit à un schéma très simple.
    </p>
    <p>
        Le compteur est réalisé avec des bascules T (typiquement JK avec J=K=1) déclenchées sur <strong>fronts descendants</strong> (negative edge triggered). L'entrée d'horloge externe ($CLK_{in}$) est appliquée uniquement à la première bascule ($Q_A$). L'entrée d'horloge de chaque cellule suivante ($CLK_i$) est alimentée par la sortie $Q$ de la bascule précédente ($Q_{i-1}$), sauf pour la première qui est reliée directement à l'entrée du compteur. Ainsi, lorsque $Q_{i-1}$ passe de 1 à 0, cela crée un front descendant qui déclenche la bascule $i$, la faisant commuter.
    </p>
    <p>
        On a représenté sur la Figure 40 (page suivante) le schéma d'un compteur asynchrone modulo 16 (4 bits) typique, basé sur le circuit intégré standard 7493. Ces compteurs sont simples et leur mise en série pour augmenter la capacité de comptage est immédiate (la sortie du dernier bit du premier compteur pilote l'entrée du second).
    </p>
    <p>
        Le 7493, par exemple, est constitué en interne d'un compteur par 2 (une bascule JK, entrée A, sortie $Q_A$) et d'un compteur par 8 (trois bascules JK en cascade, entrée B, sorties $Q_B, Q_C, Q_D$). La mise en série de ces deux sections ($B = Q_A$, c'est-à-dire connecter la sortie $Q_A$ à l'entrée B) donne un compteur par $2 \times 8 = 16$. De la même façon, on obtient un compteur par 256 (8 bits) en connectant la sortie $Q_D$ du premier 7493 sur l'entrée A (ou B) d'un second 7493 identique.
    </p>


    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 36 Content -->

     <!-- Start Page 37 Content (PDF Page 107) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <div>
        <img src="placeholder_figure40.png" alt="Figure 40: Compteur asynchrone par 16 (type 7493)." class="placeholder">
        <p class="caption">Figure 40 Compteur asynchrone par 16 de référence 7493. Le comptage par 16 est obtenu en connectant la sortie du compteur par 2 ($Q_A$) avec l'entrée B du compteur par 8.</p>
        <p style="text-align: center;">(Description: Quatre bascules JK (avec J=K=1 implicite ou connecté à Vcc, non montré). L'entrée A (horloge externe) va à CLK de la 1ère bascule (sortie $Q_A$). La sortie $Q_A$ va à l'entrée B (qui est connectée à CLK de la 2ème bascule, sortie $Q_B$). $Q_B$ va à CLK de la 3ème ($Q_C$), $Q_C$ va à CLK de la 4ème ($Q_D$). Les entrées CLK ont un cercle, indiquant un déclenchement sur front descendant. Des entrées CLEAR asynchrones sont aussi présentes.)</p>
    </div>

    <p>
        Les compteurs binaires asynchrones présentent certains avantages. Ils sont en particulier faciles à concevoir et à mettre en série, et permettent aisément d'atteindre de grandes capacités de comptage (beaucoup de bits) avec une structure simple. Ils présentent néanmoins plusieurs inconvénients :
    </p>
    <ul>
        <li>
            <strong>Délai de propagation cumulatif :</strong> Les bits commutant les uns après les autres, sur un compteur de grande capacité (beaucoup d'étages), le bit de poids fort (MSB) peut commuter "bien longtemps" (plusieurs délais de propagation de bascule cumulés) après le bit de poids faible (LSB). Ce décalage peut être source de problèmes si l'état du compteur doit être lu ou utilisé à un instant précis.
        </li>
        <li>
            <strong>États transitoires et aléas (Glitches) :</strong> L'inconvénient principal réside dans la succession d'états transitoires incorrects lors du basculement en cascade des cellules élémentaires. Par exemple, lors du passage de 7 (binaire 0111) à 8 (binaire 1000) dans un compteur 4 bits:
            <ol>
                <li>$Q_A$ passe de 1 à 0. (État devient 0110 = 6)</li>
                <li>La transition de $Q_A$ fait passer $Q_B$ de 1 à 0. (État devient 0100 = 4)</li>
                <li>La transition de $Q_B$ fait passer $Q_C$ de 1 à 0. (État devient 0000 = 0)</li>
                <li>La transition de $Q_C$ fait passer $Q_D$ de 0 à 1. (État final devient 1000 = 8)</li>
            </ol>
            Le compteur passe donc par les valeurs intermédiaires (fausses) 6, 4 et 0 avant d'atteindre la valeur correcte 8. Bien que ces états transitoires ne soient présents qu'un faible laps de temps (quelques temps de propagation), ils peuvent entraîner des aléas (glitches) s'ils sont utilisés pour commander d'autres logiques (par exemple, dans un décodeur). Ces aléas limitent également la <strong>fréquence maximum</strong> ($f_{max}$) à laquelle le compteur peut compter les impulsions de manière fiable (typiquement $f_{max} \approx 16$ MHz dans le cas du compteur 7493 en technologie TTL standard, cette fréquence diminue avec le nombre d'étages).
        </li>
    </ul>

    <h4>5.2.2. Les compteurs asynchrones par 10 (Décade).</h4>
    <p>
        Pour illustrer le fonctionnement des compteurs à cycle incomplet (modulo N), nous allons étudier en détail le compteur asynchrone par 10 (modulo 10, ou compteur décade BCD) de référence 7490.
    </p>

    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 37 Content -->

     <!-- Start Page 38 Content (PDF Page 108) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <h6>a. Fonctionnement.</h6>
    <p>
        Ces compteurs, très utilisés à cause du code <strong>BCD</strong> (Binary Coded Decimal) qu'ils génèrent (chaque chiffre décimal 0-9 est codé sur 4 bits), sont en général constitués, comme le 7493, d'un compteur par 2 (une bascule, entrée A, sortie $Q_A$) et d'un compteur modulo 5 (trois bascules, entrée B, sorties $Q_D, Q_C, Q_B$) dont le cycle de comptage est tronqué<sup>10</sup>. Pour obtenir un comptage BCD de 0 à 9, on connecte $Q_A$ (poids $2^0$) à l'entrée B du compteur par 5, dont les sorties $Q_B, Q_C, Q_D$ représentent les poids $2^1, 2^2, 2^3$.
    </p>
    <p>
        Le compteur par 5 interne compte suivant le cycle 0, 1, 2, 3, 4, puis revient à 0 (au lieu de continuer jusqu'à 7 pour un compteur binaire 3 bits). Le premier étage de ce compteur par 5 ($Q_B$, LSB du groupe) et le dernier étage ($Q_D$, MSB du groupe) ont donc un fonctionnement particulier par rapport à un compteur binaire standard. En effet, après l'état $Q_D Q_C Q_B = 100$ (qui représente la valeur 4 dans ce compteur modulo 5), l'impulsion suivante doit faire revenir l'état à $000$. Le bit $Q_D$ doit donc revenir à 0, tandis que le bit $Q_C$ reste à 0. Cela est indiqué sur la table de transitions (partielle, pour le compteur modulo 5 seul) ci-dessous :
    </p>
     <table>
        <thead>
            <tr><th colspan="3">Etat n (Mod 5)</th> <th colspan="3">Etat n+1 (Mod 5)</th> <th>Décimal</th></tr>
            <tr><th>$Q_D$</th><th>$Q_C$</th><th>$Q_B$</th> <th>$Q_D$</th><th>$Q_C$</th><th>$Q_B$</th> <th>(n+1)</th></tr>
        </thead>
         <tbody>
            <tr><td>0</td><td>0</td><td>0</td> <td>0</td><td>0</td><td>1</td> <td>1</td></tr>
            <tr><td>0</td><td>0</td><td>1</td> <td>0</td><td>1</td><td>0</td> <td>2</td></tr>
            <tr><td>0</td><td>1</td><td>0</td> <td>0</td><td>1</td><td>1</td> <td>3</td></tr>
            <tr><td>0</td><td>1</td><td>1</td> <td>1</td><td>0</td><td>0</td> <td>4</td></tr>
            <tr><td>1</td><td>0</td><td>0</td> <td>0</td><td>0</td><td>0</td> <td>0</td></tr>
        </tbody>
    </table>

    <p>
        Les bits $Q_B$ (LSB du compteur par 5) et $Q_D$ (MSB du compteur par 5) ne suivent donc pas les règles relatives aux compteurs binaires asynchrones énoncées dans le paragraphe 5.2.1 (notamment la règle 3: $Q_i$ commute quand $Q_{i-1}$ fait $1 \to 0$). Il en résulte que l'horloge du dernier étage ($Q_D$) ne peut pas être directement commandée par la sortie $Q_C$. Les transitions $0 \to 1$ et $1 \to 0$ de la bascule représentant le MSB ($Q_D$) se faisant dans des conditions particulières, on n'utilisera pas une simple bascule JK montée en bascule T (avec J=K=1) comme pour les étages précédents ($Q_A, Q_C$), mais plutôt une bascule synchrone de type RS ou JK dont les entrées seront spécifiquement calculées.
    </p>

    <h6>b. Réalisation (du compteur Modulo 5 interne du 7490).</h6>
    <p>
        Dans le compteur 7490, le bit de poids fort $Q_D$ du compteur modulo 5 est réalisé avec une bascule RS (ou équivalent). Nous allons déterminer quel doit être le « câblage » (les équations logiques) des entrées $R$ et $S$ de cette bascule pour assurer un comportement du bit $Q_D$ conforme à l'évolution décrite dans la table précédente. Pour cela, nous analyserons l'évolution de $Q_D$ à chaque état du cycle de comptage (000 à 100) et nous utiliserons la table de commande (excitation) de la bascule RS (vue page 89 / HTML page 29) pour déterminer les conditions requises sur S et R.
    </p>
     <p class="footnote">
        <sup>10</sup> Le cycle de comptage compte 5 états au lieu de 8 habituellement pour un compteur binaire sur 3 bits.
    </p>


    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 38 Content -->

     <!-- Start Page 39 Content (PDF Page 109) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <p>Analyse des transitions de $Q_D$ pour le compteur modulo 5 ($Q_D Q_C Q_B$):</p>
    <ul>
        <li>
            Transition $011 \to 100$: $Q_D$ passe de 0 à 1. D'après la table d'excitation RS ($0 \to 1$), il faut $S=1$ et $R=0$. Cette condition doit être vraie lorsque $Q_D Q_C Q_B = 011$.
        </li>
        <li>
            Transition $100 \to 000$: $Q_D$ passe de 1 à 0. Il faut $S=0$ et $R=1$. Cette condition doit être vraie lorsque $Q_D Q_C Q_B = 100$.
        </li>
        <li>
            Pour les trois autres états ($000, 001, 010$), le bit de poids fort $Q_D$ doit rester à 0 ($Q_D: 0 \to 0$). Il faut donc $S=0$ et $R=\phi$ (indifférent, peut être 0 ou 1) pour ces états.
        </li>
    </ul>

    <p>On déduit facilement de ces remarques les tables de Karnaugh pour les entrées $S$ et $R$ de la bascule $Q_D$, en fonction de l'état $Q_D, Q_C, Q_B$ (les états non utilisés dans le cycle 0-4 sont marqués $\phi$ car leur comportement n'importe pas a priori):</p>

    <div style="display: flex; justify-content: space-around; align-items: flex-start; flex-wrap: wrap;">
        <!-- K-Map for S -->
        <div style="margin: 10px;">
            <p style="text-align: center;">K-Map pour S ($Q_D$)</p>
             <table>
                <thead><tr><th>$Q_D \setminus Q_C Q_B$</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead>
                <tbody>
                    <tr><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
                    <tr><td>1</td><td>0</td><td>$\phi$</td><td>$\phi$</td><td>$\phi$</td></tr>
                </tbody>
            </table>
            <p style="text-align: center;">$S$</p>
        </div>
         <!-- K-Map for R -->
        <div style="margin: 10px;">
            <p style="text-align: center;">K-Map pour R ($Q_D$)</p>
            <table>
                <thead><tr><th>$Q_D \setminus Q_C Q_B$</th><th>00</th><th>01</th><th>11</th><th>10</th></tr></thead>
                 <tbody>
                    <tr><td>0</td><td>$\phi$</td><td>$\phi$</td><td>0</td><td>$\phi$</td></tr>
                    <tr><td>1</td><td>1</td><td>$\phi$</td><td>$\phi$</td><td>$\phi$</td></tr>
                </tbody>
            </table>
             <p style="text-align: center;">$R$</p>
        </div>
    </div>

    <p>On obtient après simplification (en utilisant les $\phi$ judicieusement):</p>
    <p style="text-align:center; font-size:1.2em;">
        $S = Q_B \cdot Q_C \qquad$ (Le 1 est isolé)
        <br>
        $R = Q_D \qquad$ (On groupe la ligne $Q_D=1$)
    </p>
    <p>(Note : Les K-maps du PDF sont légèrement différentes mais aboutissent au même résultat.)</p>

    <p>
        Analyse du bit de poids faible $Q_B$ du compteur modulo 5: Ce bit est matérialisé par une bascule JK. Il a également un comportement atypique par rapport au fonctionnement des compteurs binaires. Il commute (toggle) à chaque impulsion d'horloge (appliquée à l'entrée B) sauf au moment de la transition de 4 (100) à 0 (000), au cours de laquelle il doit rester à 0 ($Q_B: 0 \to 0$).
    </p>
    <ul>
        <li>Pour les états $Q_D Q_C Q_B = 000, 001, 010, 011$, $Q_B$ doit basculer. D'après la table d'excitation JK, il faut $J_B=\phi, K_B=\phi$ (si $Q_B$ change) ou $J_B=\phi, K_B=0$ (si $Q_B: 1\to 1$) ou $J_B=0, K_B=\phi$ (si $Q_B: 0 \to 0$). Pour obtenir le toggle ($J=1, K=1$) dans ces cas, on peut poser $J_B = K_B = 1$.</li>
        <li>En revanche, pour l'état $Q_D Q_C Q_B = 100$ (état 4), la transition suivante est $000$, donc $Q_B$ doit rester à 0 ($Q_B: 0 \to 0$). Il est nécessaire que $J_B=0$ et $K_B=\phi$. Pour satisfaire toutes les conditions, on voit qu'il faut inhiber le toggle (mettre J=0) uniquement quand $Q_D=1$.</li>
    </ul>
    <p>
        La solution est donc de câbler la bascule JK représentant le bit de poids faible $Q_B$ avec :
    </p>
     <p style="text-align:center; font-size:1.2em;">
        $J_B = \overline{Q_D} \quad \text{et} \quad K_B = 1$
    </p>
    <p>
        Ainsi, la bascule représentant le bit $Q_B$ fonctionne donc toujours en bascule T ($J=K=1$ si $Q_D=0$) sauf lorsque $Q_D = 1$ (c'est-à-dire uniquement lors du passage de 4 à 0), où elle est forcée en mode Reset ($J=0, K=1$) et reste donc à 0.
    </p>


    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 39 Content -->

     <!-- Start Page 40 Content (PDF Page 110) -->
    <div class="page-break"></div>
    <header>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </header>

    <h6>c. Schéma</h6>
    <p>
        Le schéma de ce compteur asynchrone par 10 (type 7490) est représenté sur la Figure 41. Il correspond au compteur TTL de référence 7490. Notons que ne figurent pas sur ce schéma simplifié les entrées de remise à 0 (Reset to 0, souvent R0(1) et R0(2)) et de remise à 9 (Reset to 9, R9(1) et R9(2)) présentes dans le compteur réel 7490, qui permettent de forcer le compteur à l'état 0000 ou 1001 de manière asynchrone. Toutes les entrées J et K non connectées explicitement sur le schéma sont au niveau 1 (Vcc) par défaut dans la technologie TTL ou doivent être connectées à Vcc.
    </p>
     <div>
        <img src="placeholder_figure41.png" alt="Figure 41: Compteur asynchrone par 10 (type 7490)." class="placeholder">
        <p class="caption">Figure 41 Compteur asynchrone par 10 (type 7490). Toutes les entrées J et K non connectées sur le dessin sont en réalité au niveau haut.</p>
        <p style="text-align: center;">(Description: Bascule $Q_A$ (JK type T, entrée A). Bascules $Q_B, Q_C, Q_D$. $Q_A$ horloge $Q_B$ via entrée B. $Q_B$ horloge $Q_C$. $Q_C$ ne pilote pas directement $Q_D$. $Q_B$ est une JK avec $J_B=\overline{Q_D}$ et $K_B=1$. $Q_C$ est une JK type T. $Q_D$ est une RS avec $S=Q_B \cdot Q_C$ et $R=Q_D$ (réalisé via portes internes). L'horloge de $Q_D$ semble pilotée par $Q_A$ ou l'entrée B, non $Q_C$. Structure asynchrone globale.)</p>
    </div>


    <h6>d. Evolution des états non compris dans le cycle de comptage.</h6>
    <p>
        Le fonctionnement d'un compteur peut être représenté sous la forme d'un diagramme d'états, un graphe sur lequel on indique les différents états possibles (ici, les 5 états $Q_D Q_C Q_B$ du compteur modulo 5 : 000, 001, 010, 011, 100) et les transitions entre ces états à chaque coup d'horloge. La Figure 42.a) (non fournie, mais on l'imagine comme un cycle 000 -> 001 -> 010 -> 011 -> 100 -> 000) représente le cycle de comptage normal du compteur par 5 que nous venons d'étudier.
    </p>
    <p>
        On remarque aisément que trois des huit ($2^3$) combinaisons possibles des bits $Q_D Q_C Q_B$ ne sont pas utilisées dans le cycle de comptage normal; ce sont les combinaisons 101 (5), 110 (6) et 111 (7). La question se pose alors de savoir comment évolue le compteur lorsqu'il se trouve (par exemple, à la mise sous tension) dans l'un de ces états "interdits" ou non utilisés<sup>11</sup>? Peut-il y rester bloqué, ou va-t-il rejoindre le cycle "normal" (0 à 4) après une ou plusieurs impulsions d'horloge? Il est essentiel pour un compteur fiable qu'il ne puisse pas rester bloqué dans un état non désiré et qu'il rejoigne le cycle principal. L'analyse du comportement à partir de ces états est donc importante. (Cette analyse n'est pas faite ici mais serait nécessaire pour une conception complète).
    </p>
     <p class="footnote">
        <sup>11</sup> Cette situation peut se produire à la mise sous tension lorsque l'état initial des bascules est aléatoire, ou à cause d'une perturbation externe. Le compteur se retrouve alors aléatoirement dans l'un des huit états possibles.
    </p>


    <footer>
        <span>Licence d'Ingénierie Electrique 1<sup>ère</sup> année</span>
        <span>Électronique Numérique</span>
    </footer>
    <!-- End Page 40 Content -->


    <!-- KaTeX render script configuration -->
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                // customised options
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                macros: {
                    "\\bar": "\\overline", // Define \bar as \overline for consistency
                    "\\arrow": "\\rightarrow",
                    "\\phi": "\\times" // Use 'X' or times symbol for don't care
                },
                // • rendering keys, e.g.:
                throwOnError : false
            });
        });
    </script>

</body>
</html>
